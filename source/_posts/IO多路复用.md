---
title: IO多路复用
date: 2024-10-09 15:52:04
categories: 后端
tags: Redis
---

# 多路复用要解决的问题

在多路复用之前，并发多客户端连接，最简单和典型的方案是：同步阻塞网络IO模型。

这种模式的特点就是用一个进程来处理一个网络连接（一个网络请求）。

优点是这种方式容易理解，但缺点是性能差，每个用户请求都需要占用一个进程来处理。

而进程在Linux上是个不小的开销，不说创建，光是上下文切换也需要耗费资源。所以为了高效地对海量用户提供服务，必须要让一个进程能同时处理多个TCP连接。

那么进程如何发现是哪个连接可读了或者可写了？循环遍历这种方式显然太低级。Linux操作系统其实已经帮我们做好了，那就是多路复用机制。

这里的复用是指对进程的复用。

>这里的进程也可以理解为线程层次，个人理解为1个worker对应多个socket。

<br/>

# Redis的IO多路复用

Redis利用epoll来实现IO多路复用，将连接信息和事件放到队列中，依次放到文件事件分派器，事件分派器 将事件分发给 事件处理器。

![IO多路复用-1](IO多路复用-1.png)

Redis是跑在单线程中的，所有的操作都是按照顺序线性执行的，但是**由于读写操作等待用户输入或输出都是阻塞的**，所以IO操作在一般情况下往往不能直接返回，这会导致某一文件的IO阻塞导致整个进程无法对其他客户提供服务，而IO多路复用就是为了解决这个问题而出现的。

所谓IO多路复用机制，就是说通过一种机制可以监视多个描述符，一旦某个描述符就绪（一般是读就绪或者写就绪），就能够通知程序进行相应的读写操作。这种机制的使用需要select、poll、epoll来配合。**多个连接共用一个阻塞对象，应用程序只需要在一个阻塞对象上等待，无需阻塞等待所有连接。当某条连接有新数据可以处理时，操作系统通知应用程序，线程从阻塞状态返回，开始进行业务处理。**

Redis服务采用Reactor的方式来实现文件事件处理器（每一个网络连接都对应一个文件描述符）

Redis基于Reactor模式开发了网络事件处理器，这个处理器被称为**文件事件处理器**。它由四部分组成：多个套接字、IO多路复用程序、文件事件分派器、事件处理器。

因为文件事件分派器队列的消费是单线程的，所以Redis才叫单线程模型。

<br/>

补充：从Redis6开始，将网络数据读写、请求协议解析通过多个IO线程来处理，解决网络IO问题。

![IO多路复用-2](IO多路复用-2.png)

<br/>

# IO中的阻塞、非阻塞、同步、异步

举一个生活中的案例：

你去餐厅点餐，服务员拿到你的订单后，把订单交给厨师，然后等待厨师把餐做完，而不去关注其他食客，这种情况就叫做阻塞。

如果服务员把订单交给厨师后，继续去服务其他食客，这种情况就叫做非阻塞。

服务员把订单交给厨师后，不断主动向厨师询问菜好了没有，这就是同步（主动获取）。

如果厨师把菜做完后，告知服务员菜已经好了，这就是异步（被动通知）。

总结：阻塞/非阻塞关注的是线程在**等待消息时候的状态**，同步/异步关注的是**消息通知的方式**

由此引申出来四种组合，我们还是继续通过上面的例子来说明：

* 同步阻塞

  服务员拿到订单，交给厨师后，等待厨师出餐，并不断询问出餐状态，直到出餐完成

* 异步阻塞

  服务员拿到订单，交给厨师后，等待厨师出餐，厨师出餐完成后通知服务员

  >通过这个例子可以看出，消息已经被动通知了，线程完全没有必要阻塞等待，所以异步阻塞IO实际上是不存在的

* 同步非阻塞

  服务员拿到订单，交给厨师后，继续服务其他食客，期间不断向厨师询问出餐状态

* 异步非阻塞

  服务员拿到订单，交给厨师后，继续服务其他食客，厨师出餐完成后通知服务员

<br/>

# Unix网络编程中的五种IO模型

* 阻塞IO
* 非阻塞IO
* IO多路复用
* 信号驱动IO
* 异步IO

>https://www.cnblogs.com/flashsun/p/14591563.html

<br/>

# IO多路复用的实现方式

* select
* poll
* epoll


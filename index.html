<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1"><meta name="format-detection" content="telephone=no"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="black"><link rel="icon" href="/image/site/favicon/favicon-16x16.png?v=2.6.2" type="image/png" sizes="16x16"><link rel="icon" href="/image/site/favicon/favicon-32x32.png?v=2.6.2" type="image/png" sizes="32x32"><link rel="apple-touch-icon" href="/image/site/favicon/favicon-180x180.png?v=2.6.2" sizes="180x180"><meta property="og:type" content="website">
<meta property="og:title" content="LonelyTaker&#39;s Blog">
<meta property="og:url" content="https://lonelytaker.cn/index.html">
<meta property="og:site_name" content="LonelyTaker&#39;s Blog">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="LonelyTaker">
<meta property="article:tag" content="个人博客">
<meta name="twitter:card" content="summary"><title>LonelyTaker's Blog</title><link ref="canonical" href="https://lonelytaker.cn/index.html"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.12.1/css/all.min.css" type="text/css"><link rel="stylesheet" href="/css/index.css?v=2.6.2"><script>var Stun = window.Stun || {};
var CONFIG = {
  root: '/',
  algolia: undefined,
  assistSearch: undefined,
  fontIcon: {"prompt":{"success":"fas fa-check-circle","info":"fas fa-arrow-circle-right","warning":"fas fa-exclamation-circle","error":"fas fa-times-circle"},"copyBtn":"fas fa-copy"},
  sidebar: {"offsetTop":"20px","tocMaxDepth":6},
  header: {"enable":true,"showOnPost":false,"scrollDownIcon":true},
  postWidget: {"endText":true},
  nightMode: {"enable":true},
  back2top: {"enable":true},
  codeblock: {"style":"default","highlight":"light","wordWrap":false},
  reward: false,
  fancybox: false,
  zoomImage: {"gapAside":"20px"},
  galleryWaterfall: undefined,
  lazyload: false,
  pjax: undefined,
  externalLink: {"icon":{"enable":true,"name":"fas fa-external-link-alt"}},
  shortcuts: undefined,
  prompt: {"copyButton":"复制","copySuccess":"复制成功","copyError":"复制失败"},
  sourcePath: {"js":"js","css":"css","images":"images"},
};

window.CONFIG = CONFIG;</script><meta name="generator" content="Hexo 6.0.0"></head><body><div class="container" id="container"><header class="header" id="header"><div class="header-inner"><nav class="header-nav header-nav--fixed"><div class="header-nav-inner"><div class="header-nav-menubtn"><i class="fas fa-bars"></i></div><div class="header-nav-menu"><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/"><span class="header-nav-menu-item__icon"><i class="fas fa-home"></i></span><span class="header-nav-menu-item__text">首页</span></a></div><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/archives/"><span class="header-nav-menu-item__icon"><i class="fas fa-folder-open"></i></span><span class="header-nav-menu-item__text">归档</span></a></div><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/categories/"><span class="header-nav-menu-item__icon"><i class="fas fa-layer-group"></i></span><span class="header-nav-menu-item__text">分类</span></a></div><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/tags/"><span class="header-nav-menu-item__icon"><i class="fas fa-tags"></i></span><span class="header-nav-menu-item__text">标签</span></a></div></div><div class="header-nav-mode"><div class="mode"><div class="mode-track"><span class="mode-track-moon"></span><span class="mode-track-sun"></span></div><div class="mode-thumb"></div></div></div></div></nav><div class="header-banner"><div class="header-banner-info"><div class="header-banner-info__title">LonelyTaker's Blog</div><div class="header-banner-info__subtitle">走好自己的路，迈好自己的步</div></div><div class="header-banner-arrow"><div class="header-banner-arrow__icon"><i class="fas fa-angle-down"></i></div></div></div></div></header><main class="main" id="main"><div class="main-inner"><div class="content-wrap" id="content-wrap"><div class="content content-home" id="content"><section class="postlist"><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/2022/03/15/vue-router%E7%9A%84%E4%B8%A4%E7%A7%8D%E6%A8%A1%E5%BC%8F/">vue-router的两种模式</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">发表于</span><span class="post-meta-item__value">2022-03-15</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__info">更新于</span><span class="post-meta-item__value">2022-03-15</span></span></div></header><div class="post-body"><div class="post-excerpt"><ol>
<li>对于一个URL来说，什么是hash值？<code>#</code>以及其后面的内容就是hash值。</li>
<li>hash值不会包含在http请求中，即：hash值不会带给服务器。</li>
<li>hash模式：<ul>
<li>地址中带有<code>/#/</code>，不美观。</li>
<li>若以后将地址通过第三方手机APP分享，如果APP校验严格，地址可能会被标记为不合法。</li>
<li>兼容性较好</li>
</ul>
</li>
<li>history模式：<ul>
<li>地址干净美观。</li>
<li>兼容性和hash模式相比略差。</li>
<li>应用部署上线时需要后端人员支持，解决页面刷新导致404的问题。</li>
</ul>
</li>
</ol>
</div></div></article><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/2022/03/11/%E4%B8%80%E4%BA%9B%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95/">一些常用算法</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">发表于</span><span class="post-meta-item__value">2022-03-11</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__info">更新于</span><span class="post-meta-item__value">2022-03-11</span></span></div></header><div class="post-body"><div class="post-excerpt"><br>


        <h1 id="1-快速排序">
          <a href="#1-快速排序" class="heading-link"><i class="fas fa-link"></i></a><a href="#1-快速排序" class="headerlink" title="1.快速排序"></a>1.快速排序</h1>
      <p>标准版本：</p>
<figure class="highlight javascript"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">quickSort</span>(<span class="params">list, start, end</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (end &lt;= start) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> left = start;</span><br><span class="line">    <span class="keyword">let</span> right = end;</span><br><span class="line">    <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">        <span class="keyword">while</span> (list[right] &gt; list[start]) &#123;</span><br><span class="line">            right--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (list[left] &lt;= list[start]) &#123;</span><br><span class="line">            left++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (left &lt; right) &#123;</span><br><span class="line">            <span class="keyword">let</span> temp = list[left];</span><br><span class="line">            list[left] = list[right];</span><br><span class="line">            list[right] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> temp = list[right];</span><br><span class="line">    list[right] = list[start];</span><br><span class="line">    list[start] = temp;</span><br><span class="line">    quickSort(list, start, right - <span class="number">1</span>);</span><br><span class="line">    quickSort(list, right + <span class="number">1</span>, end);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>另一种实现方式：</p>
<figure class="highlight javascript"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">quickSort</span>(<span class="params">list</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (list.length &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> left = [];</span><br><span class="line">    <span class="keyword">let</span> right = [];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; list.length; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (list[i] &lt;= list[<span class="number">0</span>]) &#123;</span><br><span class="line">            left.push(list[i]);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            right.push(list[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> quickSort(left).concat(list[<span class="number">0</span>], quickSort(right));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 也可以用ES6数组的filter方法缩写上述代码</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">quickSort</span>(<span class="params">list</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (list.length &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> left = list.filter(<span class="function">(<span class="params">x, i</span>) =&gt;</span> x &lt;= list[<span class="number">0</span>] &amp;&amp; i != <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">let</span> right = list.filter(<span class="function">(<span class="params">x</span>) =&gt;</span> x &gt; list[<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">return</span> quickSort(left).concat(list[<span class="number">0</span>], quickSort(right));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<br>
</div></div></article><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/2022/03/11/%E9%98%B2%E6%8A%96%E8%8A%82%E6%B5%81/">防抖节流</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">发表于</span><span class="post-meta-item__value">2022-03-11</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__info">更新于</span><span class="post-meta-item__value">2022-03-11</span></span></div></header><div class="post-body"><div class="post-excerpt"><br>


        <h1 id="1-防抖">
          <a href="#1-防抖" class="heading-link"><i class="fas fa-link"></i></a><a href="#1-防抖" class="headerlink" title="1.防抖"></a>1.防抖</h1>
      <p>在规定时间后执行函数，如果函数在规定时间内再次被触发，将重新计时。</p>
<figure class="highlight javascript"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">debounce</span>(<span class="params">func, gapTime = <span class="number">1500</span></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> timer = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (timer !== <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="built_in">clearTimeout</span>(timer);</span><br><span class="line">        &#125;</span><br><span class="line">        timer = <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">            func.apply(<span class="built_in">this</span>, <span class="built_in">arguments</span>);</span><br><span class="line">        &#125;, gapTime)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<br>


        <h1 id="2-节流">
          <a href="#2-节流" class="heading-link"><i class="fas fa-link"></i></a><a href="#2-节流" class="headerlink" title="2.节流"></a>2.节流</h1>
      <p>规定时间内只执行一次函数。</p>
<figure class="highlight javascript"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">throttle</span>(<span class="params">func, gapTime = <span class="number">1500</span></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> lastTime = <span class="literal">null</span></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">let</span> nowTime = <span class="built_in">Date</span>.now()</span><br><span class="line">        <span class="keyword">if</span> (nowTime - lastTime &gt; gapTime || !lastTime) &#123;</span><br><span class="line">            func.apply(<span class="built_in">this</span>, <span class="built_in">arguments</span>)</span><br><span class="line">            lastTime = nowTime</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

</div></div></article><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/2022/03/11/%E6%B7%B1%E6%8B%B7%E8%B4%9D/">深拷贝</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">发表于</span><span class="post-meta-item__value">2022-03-11</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__info">更新于</span><span class="post-meta-item__value">2022-03-11</span></span></div></header><div class="post-body"><div class="post-excerpt"><br>


        <h1 id="1-JSON转换">
          <a href="#1-JSON转换" class="heading-link"><i class="fas fa-link"></i></a><a href="#1-JSON转换" class="headerlink" title="1.JSON转换"></a>1.JSON转换</h1>
      <p>这是最简单的一种方式：</p>
<figure class="highlight javascript"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">JSON</span>.parse(<span class="built_in">JSON</span>.stringify(对象));</span><br></pre></td></tr></table></div></figure>

<p>但这种方式有很大缺陷，由于它是依赖于JSON，因此它不支持JSON不支持的其他格式，通过<span class="exturl"><a class="exturl__link" href="https://link.juejin.cn/?target=https://www.json.org/json-en.html">JSON</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span>的官网可知，JSON只支持<code>Object</code>、<code>Array</code>、<code>String</code>、<code>Number</code>、<code>Boolean</code>、<code>Null</code>这几种数据类型，其他的比如<code>Function</code>、<code>Undefined</code>、<code>Date</code>、<code>RegExp</code>等数据类型都不支持。对于它不支持的数据都会直接忽略该属性。</p>
<p>另外，如果对象存在循环引用的情况，会导致栈溢出。</p>
<br>


        <h1 id="2-递归函数">
          <a href="#2-递归函数" class="heading-link"><i class="fas fa-link"></i></a><a href="#2-递归函数" class="headerlink" title="2.递归函数"></a>2.递归函数</h1>
      <p>通过JSON转换有那么多问题，那我们就需要自己手写一个深拷贝方法，最常用的就是通过递归实现。</p>

        <h2 id="1-基础版本">
          <a href="#1-基础版本" class="heading-link"><i class="fas fa-link"></i></a><a href="#1-基础版本" class="headerlink" title="(1) 基础版本"></a>(1) 基础版本</h2>
      <figure class="highlight javascript"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">clone</span>(<span class="params">target</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (target <span class="keyword">instanceof</span> <span class="built_in">Object</span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> cloneTarget = &#123;&#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> target) &#123;</span><br><span class="line">            cloneTarget[key] = clone(target[key]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cloneTarget;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> target;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></div></figure>

<p>这种方式只能拷贝最简单的对象，还没有考虑其他引用类型：如数组、函数等。</p>

        <h2 id="2-拷贝数组">
          <a href="#2-拷贝数组" class="heading-link"><i class="fas fa-link"></i></a><a href="#2-拷贝数组" class="headerlink" title="(2) 拷贝数组"></a>(2) 拷贝数组</h2>
      <figure class="highlight javascript"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">clone</span>(<span class="params">target</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (target <span class="keyword">instanceof</span> <span class="built_in">Object</span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> cloneTarget = <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (target <span class="keyword">instanceof</span> <span class="built_in">Array</span>) &#123;</span><br><span class="line">            <span class="comment">// 如果是数组</span></span><br><span class="line">            cloneTarget = [];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            cloneTarget = &#123;&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> target) &#123;</span><br><span class="line">            cloneTarget[key] = clone(target[key]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cloneTarget;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> target;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>


        <h2 id="3-拷贝函数">
          <a href="#3-拷贝函数" class="heading-link"><i class="fas fa-link"></i></a><a href="#3-拷贝函数" class="headerlink" title="(3) 拷贝函数"></a>(3) 拷贝函数</h2>
      <p>对于函数的拷贝其实是有争议的，我认为函数不应该有深拷贝，因为对于函数，绝大多数情况都是用来调用执行，很少用来操作函数对象，所以对于函数的拷贝，我认为只需要拷贝引用即可。</p>
<figure class="highlight javascript"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">clone</span>(<span class="params">target</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (target <span class="keyword">instanceof</span> <span class="built_in">Object</span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> cloneTarget = <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (target <span class="keyword">instanceof</span> <span class="built_in">Array</span>) &#123;</span><br><span class="line">            cloneTarget = [];</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (target <span class="keyword">instanceof</span> <span class="built_in">Function</span>) &#123;</span><br><span class="line">            <span class="comment">// 如果是函数</span></span><br><span class="line">            cloneTarget = target;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            cloneTarget = &#123;&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> target) &#123;</span><br><span class="line">            cloneTarget[key] = clone(target[key]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cloneTarget;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> target;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>


        <h2 id="4-拷贝正则表达式">
          <a href="#4-拷贝正则表达式" class="heading-link"><i class="fas fa-link"></i></a><a href="#4-拷贝正则表达式" class="headerlink" title="(4) 拷贝正则表达式"></a>(4) 拷贝正则表达式</h2>
      <figure class="highlight javascript"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> re = <span class="regexp">/test/g</span>;</span><br></pre></td></tr></table></div></figure>

<p>一个正则表达式由模式和修饰符组成，<code>/test/</code>为正则模式，<code>g</code>为修饰符。拷贝一个正则表达式，只需获取这两部分即可。通过正则对象的<code>source</code>属性可以获取正则规则，<code>flags</code>属性可以获取修饰符。</p>
<figure class="highlight javascript"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">clone</span>(<span class="params">target</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (target <span class="keyword">instanceof</span> <span class="built_in">Object</span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> cloneTarget = <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (target <span class="keyword">instanceof</span> <span class="built_in">Array</span>) &#123;</span><br><span class="line">            cloneTarget = [];</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (target <span class="keyword">instanceof</span> <span class="built_in">Function</span>) &#123;</span><br><span class="line">            cloneTarget = target;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (target <span class="keyword">instanceof</span> <span class="built_in">RegExp</span>)&#123;</span><br><span class="line">            <span class="comment">// 如果是正则表达式</span></span><br><span class="line">            cloneTarget = <span class="keyword">new</span> <span class="built_in">RegExp</span>(target.source, target.flags);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            cloneTarget = &#123;&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> target) &#123;</span><br><span class="line">            cloneTarget[key] = clone(target[key]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cloneTarget;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> target;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>


        <h2 id="5-拷贝日期">
          <a href="#5-拷贝日期" class="heading-link"><i class="fas fa-link"></i></a><a href="#5-拷贝日期" class="headerlink" title="(5) 拷贝日期"></a>(5) 拷贝日期</h2>
      <figure class="highlight javascript"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">clone</span>(<span class="params">target</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (target <span class="keyword">instanceof</span> <span class="built_in">Object</span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> cloneTarget = <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (target <span class="keyword">instanceof</span> <span class="built_in">Array</span>) &#123;</span><br><span class="line">            cloneTarget = [];</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (target <span class="keyword">instanceof</span> <span class="built_in">Function</span>) &#123;</span><br><span class="line">            cloneTarget = target;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (target <span class="keyword">instanceof</span> <span class="built_in">RegExp</span>) &#123;</span><br><span class="line">            cloneTarget = <span class="keyword">new</span> <span class="built_in">RegExp</span>(target.source, target.flags);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (target <span class="keyword">instanceof</span> <span class="built_in">Date</span>) &#123;</span><br><span class="line">            <span class="comment">// 如果是日期</span></span><br><span class="line">            cloneTarget = <span class="keyword">new</span> <span class="built_in">Date</span>(target);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            cloneTarget = &#123;&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> target) &#123;</span><br><span class="line">            cloneTarget[key] = clone(target[key]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cloneTarget;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> target;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<hr>
<p>到目前为止，我们已经写出了一个可以使用的深拷贝函数，但是这个函数仍存在很多可以优化的地方。</p>
<br>


        <h1 id="3-进一步优化">
          <a href="#3-进一步优化" class="heading-link"><i class="fas fa-link"></i></a><a href="#3-进一步优化" class="headerlink" title="3.进一步优化"></a>3.进一步优化</h1>
      
        <h2 id="1-忽略原型上的属性">
          <a href="#1-忽略原型上的属性" class="heading-link"><i class="fas fa-link"></i></a><a href="#1-忽略原型上的属性" class="headerlink" title="(1) 忽略原型上的属性"></a>(1) 忽略原型上的属性</h2>
      <p>我们在遍历对象属性的时候，使用的是<code>for in</code>，<code>for in</code>会遍历包括原型上的所有可迭代属性，但是事实上我们不应该这么做。所以我们需要通过<code>hasOwnProperty</code>筛选出自身的属性。</p>
<figure class="highlight javascript"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">clone</span>(<span class="params">target</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (target <span class="keyword">instanceof</span> <span class="built_in">Object</span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> cloneTarget = <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (target <span class="keyword">instanceof</span> <span class="built_in">Array</span>) &#123;</span><br><span class="line">            cloneTarget = [];</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (target <span class="keyword">instanceof</span> <span class="built_in">Function</span>) &#123;</span><br><span class="line">            cloneTarget = target;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (target <span class="keyword">instanceof</span> <span class="built_in">RegExp</span>) &#123;</span><br><span class="line">            cloneTarget = <span class="keyword">new</span> <span class="built_in">RegExp</span>(target.source, target.flags);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (target <span class="keyword">instanceof</span> <span class="built_in">Date</span>) &#123;</span><br><span class="line">            cloneTarget = <span class="keyword">new</span> <span class="built_in">Date</span>(target);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            cloneTarget = &#123;&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> target) &#123;</span><br><span class="line">            <span class="comment">// 筛选自身属性</span></span><br><span class="line">            <span class="keyword">if</span> (target.hasOwnProperty(key)) &#123;</span><br><span class="line">                cloneTarget[key] = clone(target[key]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cloneTarget;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> target;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<br>


        <h2 id="2-循环引用问题">
          <a href="#2-循环引用问题" class="heading-link"><i class="fas fa-link"></i></a><a href="#2-循环引用问题" class="headerlink" title="(2) 循环引用问题"></a>(2) 循环引用问题</h2>
      <p>解决循环引用问题的关键点在于判断一个对象是否已经被拷贝过，如果拷贝过直接返回拷贝后的对象。所以我们需要一个东西帮我们记录，最好的方式就是<code>map</code>。</p>
<figure class="highlight javascript"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> cache = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">clone</span>(<span class="params">target</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 如果已经拷贝过，直接返回拷贝后的对象</span></span><br><span class="line">    <span class="keyword">if</span> (cache.get(target)) &#123;</span><br><span class="line">        <span class="keyword">return</span> cache.get(target);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (target <span class="keyword">instanceof</span> <span class="built_in">Object</span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> cloneTarget = <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (target <span class="keyword">instanceof</span> <span class="built_in">Array</span>) &#123;</span><br><span class="line">            cloneTarget = [];</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (target <span class="keyword">instanceof</span> <span class="built_in">Function</span>) &#123;</span><br><span class="line">            cloneTarget = target;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (target <span class="keyword">instanceof</span> <span class="built_in">RegExp</span>) &#123;</span><br><span class="line">            cloneTarget = <span class="keyword">new</span> <span class="built_in">RegExp</span>(target.source, target.flags);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (target <span class="keyword">instanceof</span> <span class="built_in">Date</span>) &#123;</span><br><span class="line">            cloneTarget = <span class="keyword">new</span> <span class="built_in">Date</span>(target);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            cloneTarget = &#123;&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 记录拷贝对象</span></span><br><span class="line">        cache.set(target, cloneTarget);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> target) &#123;</span><br><span class="line">            <span class="keyword">if</span> (target.hasOwnProperty(key)) &#123;</span><br><span class="line">                cloneTarget[key] = clone(target[key]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cloneTarget;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> target;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<hr>
<br>

<blockquote>
<p>参考：</p>
<p><span class="exturl"><a class="exturl__link" target="_blank" rel="noopener" href="https://juejin.cn/post/6844903929705136141">https://juejin.cn/post/6844903929705136141</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
<p><span class="exturl"><a class="exturl__link" target="_blank" rel="noopener" href="https://juejin.cn/post/6889327058158092302">https://juejin.cn/post/6889327058158092302</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
</blockquote>
</div></div></article><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/2022/03/11/this/">this</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">发表于</span><span class="post-meta-item__value">2022-03-11</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__info">更新于</span><span class="post-meta-item__value">2022-03-11</span></span></div></header><div class="post-body"><div class="post-excerpt"><br>


        <h1 id="1-this指向">
          <a href="#1-this指向" class="heading-link"><i class="fas fa-link"></i></a><a href="#1-this指向" class="headerlink" title="1.this指向"></a>1.this指向</h1>
      <ul>
<li>全局环境中的this -&gt; 指向<code>window</code>对象</li>
<li>普通函数中的this -&gt; 严格模式下指向<code>undefined</code>，非严格模式下指向<code>window</code>对象</li>
<li>构造函数中的this -&gt; 指向<code>new</code>出来的对象</li>
<li><code>call、apply、bind</code>调用 -&gt; 指向这三个方法的第一个参数，如果参数为<code>null</code>或者<code>undefined</code>，在非严格模式下指向<code>window</code>对象</li>
<li>箭头函数中的this -&gt; 取决于箭头函数外的this指向</li>
</ul>
<blockquote>
<p>在<strong>非严格模式</strong>下，this指向不能是<code>undefined</code>或<code>null</code>，如果得出this将指向<code>undefined</code>或者<code>null</code>，那么this会指向<code>window</code>对象。</p>
<p>在浏览器环境下是<code>window</code>对象，在Node环境下是<code>global</code>。</p>
</blockquote>
<p>简单一句话概括就是：谁调用，this就指向谁。</p>
<br>


        <h1 id="2-优先级">
          <a href="#2-优先级" class="heading-link"><i class="fas fa-link"></i></a><a href="#2-优先级" class="headerlink" title="2.优先级"></a>2.优先级</h1>
      <p>当有多种情况决定this指向时，优先级依次为：</p>
<ol>
<li>箭头函数</li>
<li>new</li>
<li>bind</li>
<li>apply和call</li>
<li>对象调用方法</li>
<li>直接调用函数</li>
<li>全局环境</li>
</ol>
<p>例如：</p>
<figure class="highlight javascript"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> func = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">this</span>);</span><br><span class="line">&#125;</span><br><span class="line">func.bind(&#123;&#125;)(); <span class="comment">// 输出window，而不是空对象</span></span><br></pre></td></tr></table></div></figure>

<br>


        <h1 id="3-apply、call和bind">
          <a href="#3-apply、call和bind" class="heading-link"><i class="fas fa-link"></i></a><a href="#3-apply、call和bind" class="headerlink" title="3.apply、call和bind"></a>3.apply、call和bind</h1>
      <p>这三个方法都会改变函数中的this指向，那他们有什么区别呢？以下方代码为例：</p>
<figure class="highlight javascript"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params">x, y</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>, x, y);</span><br><span class="line">&#125;</span><br><span class="line">test();    <span class="comment">// window undefined undefined</span></span><br></pre></td></tr></table></div></figure>

<br>


        <h2 id="1-call">
          <a href="#1-call" class="heading-link"><i class="fas fa-link"></i></a><a href="#1-call" class="headerlink" title="(1) call"></a>(1) call</h2>
      <p><code>call</code>方法接收多个参数，第一个参数为要改变的this指向，后边参数为函数自身的参数。</p>
<figure class="highlight javascript"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> temp = &#123; <span class="attr">name</span>: <span class="string">&quot;小明&quot;</span> &#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params">x, y</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>, x, y);</span><br><span class="line">&#125;</span><br><span class="line">test.call(temp,<span class="number">1</span>,<span class="number">2</span>);    <span class="comment">// temp对象 1 2</span></span><br></pre></td></tr></table></div></figure>

<p>接下来我们尝试自己去实现一下<code>call</code>方法。</p>
<p>我们思考一下，怎么做才能让函数中的this指向一个对象？如果这个函数是对象体内的方法，那通过对象调用这个方法，函数中的this是不是就指向调用的对象。然后在调用完函数后，将这个方法删除掉，对象内容不变：</p>
<figure class="highlight javascript"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> temp = &#123; <span class="attr">name</span>: <span class="string">&quot;小明&quot;</span> &#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params">x, y</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>, x, y);</span><br><span class="line">&#125;</span><br><span class="line">temp.fn = test;</span><br><span class="line">temp.fn(<span class="number">1</span>, <span class="number">2</span>);    <span class="comment">// temp对象 1 2</span></span><br><span class="line"><span class="keyword">delete</span> temp.fn;</span><br></pre></td></tr></table></div></figure>

<p>按照这个思路，我们试着自己去写一个<code>call</code>方法：</p>
<figure class="highlight javascript"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype._call = <span class="function"><span class="keyword">function</span> (<span class="params">context</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 如果没有传入指定对象，默认为window</span></span><br><span class="line">    context = context || <span class="built_in">window</span>;</span><br><span class="line">    <span class="comment">// 将函数作为对象的方法，为了保证方法名唯一，使用Symbol</span></span><br><span class="line">    <span class="comment">// this指向函数</span></span><br><span class="line">    <span class="keyword">const</span> fn = <span class="built_in">Symbol</span>();</span><br><span class="line">    context[fn] = <span class="built_in">this</span>;</span><br><span class="line">    <span class="comment">// 执行方法</span></span><br><span class="line">    <span class="keyword">const</span> res = context[fn](...[...arguments].slice(<span class="number">1</span>));</span><br><span class="line">    <span class="comment">// 删除方法</span></span><br><span class="line">    <span class="keyword">delete</span> context[fn];</span><br><span class="line">    <span class="comment">// 返回结果</span></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> temp = &#123; <span class="attr">name</span>: <span class="string">&quot;小明&quot;</span> &#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params">x, y</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>, x, y);</span><br><span class="line">&#125;</span><br><span class="line">test._call(temp, <span class="number">1</span>, <span class="number">2</span>);    <span class="comment">// temp对象 1 2</span></span><br></pre></td></tr></table></div></figure>

<br>


        <h2 id="2-apply">
          <a href="#2-apply" class="heading-link"><i class="fas fa-link"></i></a><a href="#2-apply" class="headerlink" title="(2) apply"></a>(2) apply</h2>
      <p><code>apply</code>方法接收两个参数，第一个参数为要改变的this指向，第二个参数为函数自身的参数，以数组的形式传入。<code>apply</code>与<code>call</code>方法不同的地方就是传参的形式。</p>
<figure class="highlight javascript"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> temp = &#123; <span class="attr">name</span>: <span class="string">&quot;小明&quot;</span> &#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params">x, y</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>, x, y);</span><br><span class="line">&#125;</span><br><span class="line">test.apply(temp,[<span class="number">1</span>,<span class="number">2</span>]);    <span class="comment">// temp对象 1 2</span></span><br></pre></td></tr></table></div></figure>

<p>接下来我们尝试自己去实现一下<code>apply</code>方法。</p>
<p><code>apply</code>方法和<code>call</code>方法一样，只不过是传入参数的方式不同而已：</p>
<figure class="highlight javascript"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype._apply = <span class="function"><span class="keyword">function</span> (<span class="params">context</span>) </span>&#123;</span><br><span class="line">    context = context || <span class="built_in">window</span>;</span><br><span class="line">    <span class="keyword">const</span> fn = <span class="built_in">Symbol</span>();</span><br><span class="line">    context[fn] = <span class="built_in">this</span>;</span><br><span class="line">    <span class="keyword">let</span> res = <span class="literal">null</span>;</span><br><span class="line">    <span class="comment">// 如果存在第二个参数</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">arguments</span>[<span class="number">1</span>]) &#123;</span><br><span class="line">        res = context[fn](...arguments[<span class="number">1</span>]);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        res = context[fn]();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">delete</span> context[fn];</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> temp = &#123; <span class="attr">name</span>: <span class="string">&quot;小明&quot;</span> &#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params">x, y</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>, x, y);</span><br><span class="line">&#125;</span><br><span class="line">test._apply(temp, [<span class="number">1</span>, <span class="number">2</span>]);    <span class="comment">// temp对象 1 2</span></span><br></pre></td></tr></table></div></figure>

<br>


        <h2 id="3-bind">
          <a href="#3-bind" class="heading-link"><i class="fas fa-link"></i></a><a href="#3-bind" class="headerlink" title="(3) bind"></a>(3) bind</h2>
      <p><code>bind</code>方法接收多个参数，第一个参数是要改变的this指向，后边参数为函数自身的参数。它与上边两个方法不同的是，它不会立刻执行函数，而是返回一个新函数。</p>
<figure class="highlight javascript"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> temp = &#123; <span class="attr">name</span>: <span class="string">&quot;小明&quot;</span> &#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params">x, y</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>, x, y);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 下面这样是不会执行的</span></span><br><span class="line"><span class="comment">// test.bind(temp, 1, 2);</span></span><br><span class="line"><span class="keyword">let</span> fn = test.bind(temp, <span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">fn();  <span class="comment">// temp对象 1 2</span></span><br><span class="line"><span class="comment">// 或者</span></span><br><span class="line">test.bind(temp, <span class="number">1</span>, <span class="number">2</span>)();    <span class="comment">// temp对象 1 2</span></span><br><span class="line"><span class="comment">// 另外可以将函数的参数进行拆分</span></span><br><span class="line">test.bind(temp)(<span class="number">1</span>, <span class="number">2</span>);    <span class="comment">// temp对象 1 2</span></span><br><span class="line">test.bind(temp, <span class="number">1</span>)(<span class="number">2</span>);    <span class="comment">// temp对象 1 2</span></span><br></pre></td></tr></table></div></figure>

<p>接下来我们尝试自己去实现一下<code>bind</code>方法。</p>
<p><code>bind</code>返回的是一个新函数，所以实现起来和上面两个有所不同：</p>
<figure class="highlight javascript"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype._bind = <span class="function"><span class="keyword">function</span> (<span class="params">context</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> args = [...arguments].slice(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">const</span> fn = <span class="built_in">this</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> fn.apply(</span><br><span class="line">            context,</span><br><span class="line">            <span class="comment">// 这个arguments是指返回的函数的参数</span></span><br><span class="line">            <span class="comment">// 这部分涉及函数柯里化</span></span><br><span class="line">            args.concat(...arguments)</span><br><span class="line">        );</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> temp = &#123; <span class="attr">name</span>: <span class="string">&quot;小明&quot;</span> &#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>, x, y);</span><br><span class="line">&#125;</span><br><span class="line">test._bind(temp, <span class="number">1</span>, <span class="number">2</span>)(); <span class="comment">// temp对象 1 2</span></span><br><span class="line">test._bind(temp, <span class="number">1</span>)(<span class="number">2</span>); <span class="comment">// temp对象 1 2</span></span><br></pre></td></tr></table></div></figure>

<p>但是这样还有个瑕疵，在MDN中有这么一句话：</p>
<blockquote>
<p>bind()中的第一个参数：调用绑定函数时作为this参数传递给目标函数的值。 如果使用new运算符构造绑定函数，则忽略该值。</p>
</blockquote>
<p>这句话中的绑定函数指<code>bind</code>返回的函数，那这句话是什么意思呢？由于<code>bind</code>方法返回的是一个函数，那么这个函数可以作为构造函数使用，当这个函数作为构造函数使用时，原来函数中的this指向的应该是这个构造函数创建的实例对象，而不是<code>bind</code>绑定的对象。</p>
<p>我们还是看回这个例子：</p>
<figure class="highlight javascript"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> temp = &#123; <span class="attr">name</span>: <span class="string">&quot;小明&quot;</span> &#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>, x, y);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 这里输出的不再是temp对象，而是新创建的obj对象</span></span><br><span class="line"><span class="keyword">let</span> obj = <span class="keyword">new</span> (test.bind(temp, <span class="number">1</span>, <span class="number">2</span>))();</span><br></pre></td></tr></table></div></figure>

<p>如果用我们上面自己的写的<code>bind</code>方法，当返回函数作为构造函数时，this指向还是temp对象，所以要进一步修改：</p>
<figure class="highlight javascript"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype._bind = <span class="function"><span class="keyword">function</span> (<span class="params">context</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> args = [...arguments].slice(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">const</span> fn = <span class="built_in">this</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">Fn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> fn.apply(</span><br><span class="line">            <span class="built_in">this</span> <span class="keyword">instanceof</span> Fn ? <span class="built_in">this</span> : context,</span><br><span class="line">            args.concat(...arguments)</span><br><span class="line">        );</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></div></figure>

<hr>
<br>

<blockquote>
<p>参考：</p>
<p><span class="exturl"><a class="exturl__link" target="_blank" rel="noopener" href="https://juejin.cn/post/6844903746984476686">https://juejin.cn/post/6844903746984476686</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
<p><span class="exturl"><a class="exturl__link" target="_blank" rel="noopener" href="https://juejin.cn/post/6946021671656488991">https://juejin.cn/post/6946021671656488991</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
</blockquote>
</div></div></article><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/2022/03/09/new%E6%93%8D%E4%BD%9C%E7%AC%A6/">new操作符</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">发表于</span><span class="post-meta-item__value">2022-03-09</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__info">更新于</span><span class="post-meta-item__value">2022-03-09</span></span></div></header><div class="post-body"><div class="post-excerpt"><br>

<p>以下方代码为例</p>
<figure class="highlight javascript"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> xiaoming = <span class="keyword">new</span> Person(<span class="string">&#x27;xiaoming&#x27;</span>);</span><br></pre></td></tr></table></div></figure>

<p>我们知道创建一个对象是通过<code>new</code>操作符，那么<code>new</code>操作符到底做了哪些事情呢？</p>
<p>实际上它帮我们做了四件事情：</p>
<ol>
<li><p>创建一个空的对象</p>
</li>
<li><p>将空对象原型<code>__proto__</code>指向函数的原型对象<code>prototype</code></p>
</li>
<li><p>函数的this指向这个空对象，并执行代码</p>
</li>
<li><p>将这个对象返回</p>
<p> 构造函数返回值取决于函数的<code>return</code>：</p>
<ul>
<li>不写return -&gt; 返回默认创建的对象</li>
<li>return this -&gt; 返回默认创建的对象</li>
<li>return 基本数据类型 -&gt; 返回默认创建的对象</li>
<li>return 对象 -&gt; 返回该对象而非创建的对象</li>
</ul>
</li>
</ol>
<p>那么上面的代码，我们可以这样理解：</p>
<figure class="highlight javascript"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> xiaoming = <span class="keyword">new</span> Person(<span class="string">&#x27;xiaoming&#x27;</span>);</span><br><span class="line"><span class="comment">// 上面这句代码可以看成这样</span></span><br><span class="line"><span class="keyword">let</span> temp = &#123;&#125;;</span><br><span class="line">temp.__proto__ = Person.prototype;</span><br><span class="line"><span class="keyword">let</span> res = Person.apply(temp, [<span class="string">&quot;xiaoming&quot;</span>]);</span><br><span class="line"><span class="keyword">let</span> xiaoming = <span class="keyword">typeof</span> res === <span class="string">&#x27;object&#x27;</span> ? res:temp;</span><br></pre></td></tr></table></div></figure>

<p>再扩展一下，我们可以自己封装一个<code>new</code>函数：</p>
<figure class="highlight javascript"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">_new</span>(<span class="params">Context</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> temp = &#123;&#125;;</span><br><span class="line">    temp.__proto__ = Context.prototype;</span><br><span class="line">    <span class="keyword">let</span> res = Context.apply(temp, [...arguments].slice(<span class="number">1</span>));</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">typeof</span> res === <span class="string">&quot;object&quot;</span> ? res : temp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> xiaoming = _new(Person, <span class="string">&quot;xiaoming&quot;</span>);    <span class="comment">// 效果和 new Person(&quot;xiaoming&quot;) 一样</span></span><br></pre></td></tr></table></div></figure>

<blockquote>
<p>在讲原型和原型链的时候我们说<code>__proto__</code>属性不能直接使用，这是由于在ES6之前没有标准的方法能够直接操作隐式原型，所以才有了<code>__proto__</code>属性，通过它我们可以访问到对象的原型，所以<code>__proto__</code>属性其实是可以使用的，但是并不建议，因为不是所有的浏览器都支持通过<code>__proto__</code>来访问。我们这里只是用来模拟<code>new</code>操作符的实现，必须要用到<code>__proto__</code>而已。</p>
</blockquote>
<hr>
</div></div></article><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/2022/03/07/%E5%8E%9F%E5%9E%8B%E4%B8%8E%E5%8E%9F%E5%9E%8B%E9%93%BE/">原型与原型链</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">发表于</span><span class="post-meta-item__value">2022-03-07</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__info">更新于</span><span class="post-meta-item__value">2022-03-08</span></span></div></header><div class="post-body"><div class="post-excerpt"><br>


        <h1 id="1-前置知识">
          <a href="#1-前置知识" class="heading-link"><i class="fas fa-link"></i></a><a href="#1-前置知识" class="headerlink" title="1.前置知识"></a>1.前置知识</h1>
      <p>在聊原型和原型链之前，我们需要知道几个概念：构造函数和普通函数、函数对象和实例对象。</p>
<br>


        <h2 id="1-构造函数和普通函数">
          <a href="#1-构造函数和普通函数" class="heading-link"><i class="fas fa-link"></i></a><a href="#1-构造函数和普通函数" class="headerlink" title="(1) 构造函数和普通函数"></a>(1) 构造函数和普通函数</h2>
      <figure class="highlight javascript"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Test</span>(<span class="params">hi</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.hi = hi</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.hi);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;这是普通函数&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> t = <span class="keyword">new</span> Test(<span class="string">&quot;这是构造函数&quot;</span>);</span><br><span class="line">test();</span><br></pre></td></tr></table></div></figure>

<p>在函数声明的时候，无法判断一个函数是否为构造函数。只有使用<code>new</code>操作符创建对象时，调用的函数才叫做构造函数。</p>
<p>两者区别：</p>
<ol>
<li><p>作用不同</p>
<p> 普通函数的作用自然是执行函数体内的代码以实现某种功能。构造函数的作用是用来创建对象。</p>
</li>
<li><p>调用方式不同</p>
<p> 普通函数直接调用：<code>函数名()</code></p>
<p> 构造函数是为了创建对象，所以需要使用<code>new</code>关键字来调用：<code>new 函数名()</code></p>
</li>
<li><p>书写习惯不同</p>
<p> 为了区别普通函数和构造函数，构造函数的函数名一般大写开头。</p>
</li>
<li><p>this指向不同</p>
<p> 普通函数中的this指向window对象，构造函数中的this则是指向它创建的对象。</p>
</li>
<li><p>写法不同</p>
<p> 构造函数中一般不写<code>return</code>。</p>
</li>
</ol>
<p>所以上述代码中<code>test</code>为普通函数，<code>Test</code>为构造函数。</p>
<br>


        <h2 id="2-函数对象和实例对象">
          <a href="#2-函数对象和实例对象" class="heading-link"><i class="fas fa-link"></i></a><a href="#2-函数对象和实例对象" class="headerlink" title="(2) 函数对象和实例对象"></a>(2) 函数对象和实例对象</h2>
      <p>以下面的代码为例：</p>
<figure class="highlight javascript"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Student</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> st1 = <span class="keyword">new</span> Student(<span class="string">&#x27;小明&#x27;</span>);</span><br></pre></td></tr></table></div></figure>

<p>在JavaScript中，函数也是对象，所以从这个角度讲，上述代码中<code>Student</code>构造函数也称为函数对象，而通过<code>new</code>操作符创建的对象，称为实例对象，上述代码中<code>st1</code>就是通过<code>Student</code>构造函数创建的实例对象。</p>
<blockquote>
<p>不仅仅是构造函数，任何函数从对象的角度讲或者当做对象去使用时，都可以称为函数对象。</p>
<p>这里所说的函数对象不是JS内置的Function对象。</p>
</blockquote>
<br>


        <h1 id="2-原型">
          <a href="#2-原型" class="heading-link"><i class="fas fa-link"></i></a><a href="#2-原型" class="headerlink" title="2.原型"></a>2.原型</h1>
      <p>什么是原型？我们还是通过上面的代码来讲解：</p>
<figure class="highlight javascript"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Student</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> st1 = <span class="keyword">new</span> Student(<span class="string">&#x27;小明&#x27;</span>);</span><br></pre></td></tr></table></div></figure>

<p>假设现在我们需要给<code>st1</code>添加一个<code>speak</code>方法，可以这么做：</p>
<figure class="highlight javascript"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Student</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> st1 = <span class="keyword">new</span> Student(<span class="string">&#x27;小明&#x27;</span>);</span><br><span class="line">st1.speak = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;my name is&quot;</span>, <span class="built_in">this</span>.name);</span><br><span class="line">&#125;</span><br><span class="line">st1.speak();    <span class="comment">// my name is 小明</span></span><br></pre></td></tr></table></div></figure>

<p>但假如我要给每一个<code>Student</code>创建出来的实例对象都添加上这个<code>speak</code>方法，可以这么做：</p>
<figure class="highlight javascript"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Student</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.name = name;</span><br><span class="line">    <span class="built_in">this</span>.speak = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;my name is&quot;</span>, <span class="built_in">this</span>.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> st1 = <span class="keyword">new</span> Student(<span class="string">&#x27;小明&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> st2 = <span class="keyword">new</span> Student(<span class="string">&#x27;小红&#x27;</span>);</span><br><span class="line">st1.speak();    <span class="comment">// my name is 小明</span></span><br><span class="line">st2.speak();    <span class="comment">// my name is 小红</span></span><br></pre></td></tr></table></div></figure>

<p>这种方式每创建一个实例对象，就会创建一个新的<code>speak</code>方法，也就是说每个实例对象的<code>speak</code>方法都是唯一的。</p>
<img src="/2022/03/07/%E5%8E%9F%E5%9E%8B%E4%B8%8E%E5%8E%9F%E5%9E%8B%E9%93%BE/%E5%8E%9F%E5%9E%8B-1.png" class>

<p>但这种方式有个问题：如果我们创建出来的实例对象越来越多，在内存中占用的空间是不是也越来越多。</p>
<p>我们仔细想想，这个<code>speak</code>方法需要每个实例对象都唯一吗？能不能共用一个？答案是可以共用，因为每个实例对象的<code>speak</code>方法做的事情都是一样的。</p>
<p>那么我们要怎么修改呢？可以这么做：</p>
<figure class="highlight javascript"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Student</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.name = name;</span><br><span class="line">    <span class="built_in">this</span>.speak = _speak;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 将方法提取到全局作用域下</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">_speak</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;my name is&quot;</span>, <span class="built_in">this</span>.name);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> st1 = <span class="keyword">new</span> Student(<span class="string">&#x27;小明&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> st2 = <span class="keyword">new</span> Student(<span class="string">&#x27;小红&#x27;</span>);</span><br><span class="line">st1.speak();    <span class="comment">// my name is 小明</span></span><br><span class="line">st2.speak();    <span class="comment">// my name is 小红</span></span><br></pre></td></tr></table></div></figure>

<p>这时候的内存空间：</p>
<img src="/2022/03/07/%E5%8E%9F%E5%9E%8B%E4%B8%8E%E5%8E%9F%E5%9E%8B%E9%93%BE/%E5%8E%9F%E5%9E%8B-2.png" class>

<p>这种方式看上去很不错，但是仍然会带来一些问题：</p>
<ol>
<li><code>_speak</code>是在全局作用域下声明的，可能会污染全局作用域（变量冲突）。</li>
<li>随着全局作用域下的函数声明越来越多，全局作用域会变得越来越臃肿。</li>
</ol>
<br>

<p>因此，JS就提出了原型的概念。每一个函数对象身上都有一个<code>prototype</code>属性，该属性指向一个对象。</p>
<figure class="highlight javascript"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Student</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(Student.prototype);    <span class="comment">// Object</span></span><br></pre></td></tr></table></div></figure>

<p>这个对象叫做<strong>原型对象</strong>，每个函数对象都有自己的原型对象。</p>
<blockquote>
<p>不管是构造函数还是普通函数，都有<code>prototype</code>属性，只不过在普通函数上这一个属性没有什么作用。所以在讲原型时，我们比较强调构造函数，下文中的函数对象也都指构造函数。</p>
</blockquote>
<p>另外，创建实例对象时，实例对象身上会有一个属性<code>__proto__</code>，它指向创建该实例对象的函数对象的原型对象。同一个函数对象创建的每一个实例对象，它们的<code>__proto__</code>属性都指向同一个原型对象。</p>
<figure class="highlight javascript"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Student</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> st1 = <span class="keyword">new</span> Student(<span class="string">&quot;小明&quot;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(Student.prototype === st1.__proto__);  <span class="comment">// true</span></span><br></pre></td></tr></table></div></figure>

<img src="/2022/03/07/%E5%8E%9F%E5%9E%8B%E4%B8%8E%E5%8E%9F%E5%9E%8B%E9%93%BE/%E5%8E%9F%E5%9E%8B-3.png" class>

<p>这就意味着，如果我们在函数对象的原型对象中添加属性和方法，该函数对象创建的实例对象也可以访问到。JS就是这么做的，JS中对于对象属性和方法的访问顺序是从对象本身到对象的原型，如果对象本身中就有要找的属性或方法，直接使用对象本身中的属性或方法，否则从对象的原型中找。比如：</p>
<figure class="highlight javascript"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Student</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line">Student.prototype.school = <span class="string">&quot;xx大学&quot;</span>;</span><br><span class="line"><span class="keyword">var</span> st1 = <span class="keyword">new</span> Student(<span class="string">&quot;小明&quot;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(st1.school);    <span class="comment">// xx大学</span></span><br><span class="line">st1.school = <span class="string">&quot;yy大学&quot;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(st1.school);    <span class="comment">// yy大学</span></span><br></pre></td></tr></table></div></figure>

<img src="/2022/03/07/%E5%8E%9F%E5%9E%8B%E4%B8%8E%E5%8E%9F%E5%9E%8B%E9%93%BE/%E5%8E%9F%E5%9E%8B-4.png" class>

<img src="/2022/03/07/%E5%8E%9F%E5%9E%8B%E4%B8%8E%E5%8E%9F%E5%9E%8B%E9%93%BE/%E5%8E%9F%E5%9E%8B-5.png" class>

<p>那么为了实现我们上面所说的对于<code>speak</code>方法的操作，可以这么做：</p>
<figure class="highlight javascript"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Student</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line">Student.prototype.speak = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;my name is&quot;</span>, <span class="built_in">this</span>.name);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> st1 = <span class="keyword">new</span> Student(<span class="string">&#x27;小明&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> st2 = <span class="keyword">new</span> Student(<span class="string">&#x27;小红&#x27;</span>);</span><br><span class="line">st1.speak();    <span class="comment">// my name is 小明</span></span><br><span class="line">st2.speak();    <span class="comment">// my name is 小红</span></span><br></pre></td></tr></table></div></figure>

<img src="/2022/03/07/%E5%8E%9F%E5%9E%8B%E4%B8%8E%E5%8E%9F%E5%9E%8B%E9%93%BE/%E5%8E%9F%E5%9E%8B-6.png" class>

<p>再补充一点，原型对象在函数声明时一同创建，然后挂载到函数对象的<code>prototype</code>属性上，另外原型对象上有一个<code>constructor</code>属性，指向创建它的函数对象，这样两者的关系就紧密结合起来了。</p>
<p>完整关系图：</p>
<img src="/2022/03/07/%E5%8E%9F%E5%9E%8B%E4%B8%8E%E5%8E%9F%E5%9E%8B%E9%93%BE/%E5%8E%9F%E5%9E%8B-7.png" class>

<p>总结：</p>
<ol>
<li>函数对象上有一个<code>prototype</code>属性，该属性称为显示原型。它指向一个对象，该对象称为原型对象。</li>
<li>函数对象创建的每个实例对象都有一个 <code>__proto__</code>属性 ，该属性称为隐式原型。它指向创建该实例对象的函数对象的原型对象。</li>
<li>原型对象上有一个<code>constructor</code>属性，它指向创建该原型对象的函数对象。</li>
</ol>
<p>所以原型就是一个对象，它的作用是所有实例对象共享属性和方法。</p>
<blockquote>
<p>一般是共享方法，因为属性一般都是实例对象独有的，不同实例对象他们的属性不同，比如上面的<code>st1</code>和<code>st2</code>，他们的<code>name</code>属性各不相同，不应该把<code>name</code>放入<code>Student</code>原型对象中。</p>
</blockquote>
<blockquote>
<p>有些人可能会问：为什么一定要通过函数对象的<code>prototype</code>往原型对象上添加方法和属性，能不能通过实例对象的<code>__proto__</code>去添加呢？答案是不行的，实例对象的<code>__proto__</code>属性的意义在于为对象的查找机制提供一个方向或者说一条线路，但它是一个非标准属性，因此实际开发中不可以使用这个属性，这也是为什么称它为隐式原型的原因。</p>
</blockquote>
<br>


        <h1 id="3-原型链">
          <a href="#3-原型链" class="heading-link"><i class="fas fa-link"></i></a><a href="#3-原型链" class="headerlink" title="3.原型链"></a>3.原型链</h1>
      <p>理解了原型之后，原型链理解起来就比较容易。我们还是从上面的例子入手：</p>
<figure class="highlight javascript"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Student</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line">Student.prototype.speak = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;my name is&quot;</span>, <span class="built_in">this</span>.name);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> st1 = <span class="keyword">new</span> Student(<span class="string">&#x27;小明&#x27;</span>);</span><br><span class="line">st1.speak();    <span class="comment">// my name is 小明</span></span><br><span class="line"><span class="built_in">console</span>.log(st1.toString());    <span class="comment">// [object Object]</span></span><br></pre></td></tr></table></div></figure>

<p>我们会发现上述第九行代码，会输出<code>[object Object]</code>，也就是说<code>st1</code>能够执行<code>toString()</code>方法。但是<code>st1</code>这个实例对象本身和它<code>__proto__</code>所指向的原型对象上都没有这个方法。那这个方法是哪来的呢？</p>
<p>我们知道，<code>Object</code>对象是所有对象的“祖先”，既然原型对象也是一个对象，那它也不例外，所以其实<strong>原型对象是Object对象的实例对象</strong>。既然是实例对象，那它身上就会有一个<code>__proto__</code>属性，指向<code>Object</code>对象的原型对象。</p>
<img src="/2022/03/07/%E5%8E%9F%E5%9E%8B%E4%B8%8E%E5%8E%9F%E5%9E%8B%E9%93%BE/%E5%8E%9F%E5%9E%8B%E9%93%BE-1.png" class>

<p>我们简化一下这张图：</p>
<img src="/2022/03/07/%E5%8E%9F%E5%9E%8B%E4%B8%8E%E5%8E%9F%E5%9E%8B%E9%93%BE/%E5%8E%9F%E5%9E%8B%E9%93%BE-2.png" class>

<p>接着我们来看下<code>Object</code>对象的原型对象上有没有<code>toString()</code>方法：</p>
<img src="/2022/03/07/%E5%8E%9F%E5%9E%8B%E4%B8%8E%E5%8E%9F%E5%9E%8B%E9%93%BE/%E5%8E%9F%E5%9E%8B%E9%93%BE-3.png" class>

<p>果然有，这说明了什么？说明JS对于对象属性和方法的查找规则是这样的：</p>
<p>先从对象本身去找，如果找不到，就去该对象的原型对象上去找，如果还是没有找到，就去原型对象的原型对象上去找……但原型对象不可能永无止境，<code>Object</code>对象的原型对象<code>__proto__</code>属性值为<code>null</code>，也就是说查找到<code>Object</code>对象的原型对象就结束了，如果还是没有找到，则返回<code>undefined</code>。</p>
<img src="/2022/03/07/%E5%8E%9F%E5%9E%8B%E4%B8%8E%E5%8E%9F%E5%9E%8B%E9%93%BE/%E5%8E%9F%E5%9E%8B%E9%93%BE-4.png" class>

<p>像图上这条被<code>__proto__</code>链接起来的链式关系，就叫<strong>原型链</strong>。它直接反应了JS对于对象属性和方法的查找顺序。</p>
<br>


        <h1 id="4-补充">
          <a href="#4-补充" class="heading-link"><i class="fas fa-link"></i></a><a href="#4-补充" class="headerlink" title="4.补充"></a>4.补充</h1>
      <p>理解完了原型和原型链，我们再想一想，所有的函数都可以通过<code>new Function()</code>的方式创建，那么也就是说所有的函数都是<code>Function</code>对象的实例对象。既然是实例对象，那它身上就会有一个<code>__proto__</code>属性，并且这一属性指向<code>Function</code>对象的原型对象。</p>
<img src="/2022/03/07/%E5%8E%9F%E5%9E%8B%E4%B8%8E%E5%8E%9F%E5%9E%8B%E9%93%BE/Function%E5%AF%B9%E8%B1%A1-1.png" class>

<p>那么<code>Function</code>对象是谁的实例对象呢？</p>
<p>我们刚说所有函数都是<code>Function</code>对象的实例对象，而<code>Function</code>对象也是构造函数，那么不就成了<code>Function</code>对象创建了<code>Function</code>对象？其实不必太过纠结这一点，因为<code>Function</code>对象是JS的内置对象，在脚本还没开始执行，就已经创建好了。所以<code>Function.__proto__ === Function.prototype</code>，记住这一个特殊情况就好了。</p>
<img src="/2022/03/07/%E5%8E%9F%E5%9E%8B%E4%B8%8E%E5%8E%9F%E5%9E%8B%E9%93%BE/Function%E5%AF%B9%E8%B1%A1-2.png" class>

<blockquote>
<p><code>Object</code>对象和<code>Function</code>对象都是函数对象，也就是构造函数。只不过它们两个都是JS的内置对象，所以没有特别标注函数对象。</p>
</blockquote>
<p>这里有一张非常流行的关于原型的图，就是我们刚刚讲到的所有内容：</p>
<img src="/2022/03/07/%E5%8E%9F%E5%9E%8B%E4%B8%8E%E5%8E%9F%E5%9E%8B%E9%93%BE/%E5%8E%9F%E5%9E%8B%E5%92%8C%E5%8E%9F%E5%9E%8B%E9%93%BE.png" class>

<br>


        <h1 id="5-继承">
          <a href="#5-继承" class="heading-link"><i class="fas fa-link"></i></a><a href="#5-继承" class="headerlink" title="5.继承"></a>5.继承</h1>
      <p>继承是面向对象编程的一个概念。继承可以使子类具有父类的属性和方法，同时可以在子类中重新定义或追加属性和方法。继承是类与类之间的关系。</p>
<p>但是JavaScript并没有类的概念，只有对象。那怎么会有继承呢？因为JavaScript是非常灵活的，我们可以通过构造函数和原型来模拟类的继承。</p>
<blockquote>
<p>如果熟悉面向对象编程的语言，我们会发现JS中的构造函数和类有点相似。在ES6中，JS也提出了类的概念，但ES6中的类其实是一个语法糖，它的本质还是构造函数，感兴趣的可以自行了解。</p>
</blockquote>
<br>


        <h2 id="1-通过构造函数继承属性">
          <a href="#1-通过构造函数继承属性" class="heading-link"><i class="fas fa-link"></i></a><a href="#1-通过构造函数继承属性" class="headerlink" title="(1) 通过构造函数继承属性"></a>(1) 通过构造函数继承属性</h2>
      <p>假如我们现在有一个<code>Father</code>构造函数，并且希望有另一个构造函数继承<code>Father</code>构造函数，我们可以这么做：</p>
<figure class="highlight javascript"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 父构造函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Father</span>(<span class="params">name,age</span>)</span>&#123;</span><br><span class="line">    <span class="comment">// this 指向父构造函数的实例对象</span></span><br><span class="line">    <span class="built_in">this</span>.name = name;</span><br><span class="line">    <span class="built_in">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 子构造函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Son</span>(<span class="params">name,age</span>)</span>&#123;</span><br><span class="line">    <span class="comment">// this 指向子构造函数的实例对象</span></span><br><span class="line">    <span class="comment">// 要想继承父构造函数的属性，必须调用父构造函数，并且将父构造函数中的this改为当前构造函数中的this</span></span><br><span class="line">    Father.call(<span class="built_in">this</span>, name, age);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> son = <span class="keyword">new</span> Son(<span class="string">&#x27;小明&#x27;</span>, <span class="number">18</span>);</span><br></pre></td></tr></table></div></figure>

<p>但是这样还不够，因为这样<code>Son</code>构造函数只继承了<code>Father</code>构造函数的属性，没有继承<code>Father</code>构造函数的方法：</p>
<figure class="highlight javascript"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 父构造函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Father</span>(<span class="params">name,age</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.name = name;</span><br><span class="line">    <span class="built_in">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line">Father.prototype.money = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">1000</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 子构造函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Son</span>(<span class="params">name,age</span>)</span>&#123;</span><br><span class="line">    Father.call(<span class="built_in">this</span>, name, age);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> son = <span class="keyword">new</span> Son(<span class="string">&#x27;小明&#x27;</span>, <span class="number">18</span>);</span><br><span class="line">son.money();    <span class="comment">// 报错，son无法调用money方法，或者说根本找不到money方法</span></span><br></pre></td></tr></table></div></figure>

<img src="/2022/03/07/%E5%8E%9F%E5%9E%8B%E4%B8%8E%E5%8E%9F%E5%9E%8B%E9%93%BE/%E7%BB%A7%E6%89%BF-1.png" class>

<p>接下去，我们就需要让<code>Son</code>构造函数继承<code>Father</code>构造函数的方法。</p>
<br>


        <h2 id="2-通过原型对象继承方法">
          <a href="#2-通过原型对象继承方法" class="heading-link"><i class="fas fa-link"></i></a><a href="#2-通过原型对象继承方法" class="headerlink" title="(2) 通过原型对象继承方法"></a>(2) 通过原型对象继承方法</h2>
      <p>由上面的图像结合原型链的知识，我们可以发现，如果让<code>Son</code>原型对象链接到<code>Father</code>原型对象，那我们<code>Son</code>构造函数创建的实例对象，是不是就可以使用<code>Father</code>原型对象上的方法了？</p>
<img src="/2022/03/07/%E5%8E%9F%E5%9E%8B%E4%B8%8E%E5%8E%9F%E5%9E%8B%E9%93%BE/%E7%BB%A7%E6%89%BF-2.png" class>

<p>原型对象的链接是依靠<code>__proto__</code>属性去操作的，所以最简单的方式：</p>
<figure class="highlight javascript"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Son.prototype.__proto__ = Father.prototype;</span><br></pre></td></tr></table></div></figure>

<p>但是我们说过<code>__proto__</code>属性不能直接使用。那有没有什么办法同样能实现上述代码的效果？我们可以这么做：</p>
<figure class="highlight javascript"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 父构造函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Father</span>(<span class="params">name,age</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.name = name;</span><br><span class="line">    <span class="built_in">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line">Father.prototype.money = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">1000</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 子构造函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Son</span>(<span class="params">name,age</span>)</span>&#123;</span><br><span class="line">    Father.call(<span class="built_in">this</span>, name, age);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 将Son构造函数的prototype指向Father构造函数创建的实例对象</span></span><br><span class="line"><span class="comment">// 由于Father构造函数创建的实例对象中有__proto__属性，并且指向Father构造函数的原型对象</span></span><br><span class="line"><span class="comment">// 这样就达到了我们预先的目的</span></span><br><span class="line">Son.prototype = <span class="keyword">new</span> Father();</span><br><span class="line"><span class="keyword">var</span> son = <span class="keyword">new</span> Son(<span class="string">&#x27;小明&#x27;</span>, <span class="number">18</span>);</span><br><span class="line">son.money();    <span class="comment">// 1000</span></span><br></pre></td></tr></table></div></figure>

<img src="/2022/03/07/%E5%8E%9F%E5%9E%8B%E4%B8%8E%E5%8E%9F%E5%9E%8B%E9%93%BE/%E7%BB%A7%E6%89%BF-3.png" class>

<p>这样<code>Father</code>构造函数创建的实例对象就变成了<code>Son</code>构造函数的原型对象，<code>Son</code>构造函数<code>new</code>出来的实例对象，也指向这一个<code>Father</code>构造函数创建的实例对象。从而达到我们预先的目的。</p>
<img src="/2022/03/07/%E5%8E%9F%E5%9E%8B%E4%B8%8E%E5%8E%9F%E5%9E%8B%E9%93%BE/%E7%BB%A7%E6%89%BF-4.png" class>

<p>除此之外还差一步，我们原先说过原型对象中有一个<code>constructor</code>属性指向构造函数，我们修改了构造函数的原型对象，那就需要将新的原型对象中的<code>constructor</code>属性指向构造函数。</p>
<figure class="highlight javascript"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 父构造函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Father</span>(<span class="params">name,age</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.name = name;</span><br><span class="line">    <span class="built_in">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line">Father.prototype.money = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">1000</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 子构造函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Son</span>(<span class="params">name,age</span>)</span>&#123;</span><br><span class="line">    Father.call(<span class="built_in">this</span>, name, age);</span><br><span class="line">&#125;</span><br><span class="line">Son.prototype = <span class="keyword">new</span> Father();</span><br><span class="line"><span class="comment">// 修改constructor</span></span><br><span class="line">Son.prototype.constructor = Son;</span><br><span class="line"><span class="keyword">var</span> son = <span class="keyword">new</span> Son(<span class="string">&#x27;小明&#x27;</span>, <span class="number">18</span>);</span><br><span class="line">son.money();    <span class="comment">// 1000</span></span><br></pre></td></tr></table></div></figure>

<img src="/2022/03/07/%E5%8E%9F%E5%9E%8B%E4%B8%8E%E5%8E%9F%E5%9E%8B%E9%93%BE/%E7%BB%A7%E6%89%BF-5.png" class>

<br>

<p>上述这种继承方式叫做<strong>组合继承</strong>。</p>
<hr>
<br>

<blockquote>
<p>参考：</p>
<p><span class="exturl"><a class="exturl__link" target="_blank" rel="noopener" href="https://juejin.cn/post/6996583771952644110">https://juejin.cn/post/6996583771952644110</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
<p><span class="exturl"><a class="exturl__link" target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1Kt411w7MP">https://www.bilibili.com/video/BV1Kt411w7MP</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
</blockquote>
</div></div></article><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/2022/02/21/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/">浏览器工作原理</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">发表于</span><span class="post-meta-item__value">2022-02-21</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__info">更新于</span><span class="post-meta-item__value">2022-03-13</span></span></div></header><div class="post-body"><div class="post-excerpt">
        <h1 id="前置知识">
          <a href="#前置知识" class="heading-link"><i class="fas fa-link"></i></a><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h1>
      
        <h2 id="1-浏览器的组成结构">
          <a href="#1-浏览器的组成结构" class="heading-link"><i class="fas fa-link"></i></a><a href="#1-浏览器的组成结构" class="headerlink" title="(1) 浏览器的组成结构"></a>(1) 浏览器的组成结构</h2>
      <p>浏览器一般由七个模块组成：</p>
<ul>
<li><p>用户界面（ <em>User Interface</em> ）</p>
<p>包括地址栏、后退/前进按钮、书签目录等，也就是除了标签页窗口之外的其他部分。</p>
</li>
<li><p>浏览器引擎（ <em>Browser Engine</em> ）</p>
<p>可以在用户界面和渲染引擎之间传送指令或在客户端本地缓存中读写数据等，是浏览器中各个部分之间相互通信的核心。</p>
</li>
<li><p>渲染引擎（ <em>Rendering Engine</em> ）</p>
<p>渲染引擎负责渲染用户请求的页面内容。在渲染引擎下还有很多小的功能模块，比如网络模块、JS 解释器等。</p>
</li>
<li><p>网络（ <em>Networking</em> ）</p>
<p>用来完成网络调用或资源下载的模块。</p>
</li>
<li><p>JS 解释器（ <em>JavaScript Interpreter</em> ）</p>
<p>用来解释执行 JS 脚本的模块。</p>
</li>
<li><p>UI 后端（ <em>UI Backend</em> ）</p>
<p>用来绘制基本的浏览器窗口内控件，如输入框、按钮、单选按钮等，根据浏览器不同绘制的视觉效果也不同，但功能都是一样的。</p>
</li>
<li><p>数据持久化存储（ <em>Date Persistence</em> ）</p>
<p>浏览器在硬盘中保存 <em>cookie、localStorage</em> 等各种数据，可通过浏览器引擎提供的 API 进行调用。</p>
</li>
</ul>
<img src="/2022/02/21/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/%E6%B5%8F%E8%A7%88%E5%99%A8-%E7%BB%84%E6%88%90%E7%BB%93%E6%9E%84.png" class>

<p>从浏览器的组成结构来讲，我们常说的浏览器内核，指的就是渲染引擎。</p>
<br>


        <h2 id="2-浏览器的多进程结构">
          <a href="#2-浏览器的多进程结构" class="heading-link"><i class="fas fa-link"></i></a><a href="#2-浏览器的多进程结构" class="headerlink" title="(2) 浏览器的多进程结构"></a>(2) 浏览器的多进程结构</h2>
      
        <h3 id="1-进程-线程">
          <a href="#1-进程-线程" class="heading-link"><i class="fas fa-link"></i></a><a href="#1-进程-线程" class="headerlink" title="1) 进程/线程"></a>1) 进程/线程</h3>
      <p>进程是资源分配的最小单位，线程是 CPU 调度的最小单位。</p>
<p>早期浏览器是单进程的，单进程导致了许多问题：</p>
<ol>
<li><p>不稳定</p>
<p>一个页面卡死会导致整个浏览器不能正常使用</p>
</li>
<li><p>不安全</p>
<p>浏览器之间共享数据</p>
</li>
<li><p>不流畅</p>
<p>一个进程负责太多的事情，效率低</p>
</li>
</ol>
<p>故现在的浏览器采用了<strong>多进程结构</strong></p>
<br>


        <h3 id="2-浏览器的进程">
          <a href="#2-浏览器的进程" class="heading-link"><i class="fas fa-link"></i></a><a href="#2-浏览器的进程" class="headerlink" title="2) 浏览器的进程"></a>2) 浏览器的进程</h3>
      <p>浏览器的主要进程有：（以谷歌浏览器为例）</p>
<ul>
<li><p>浏览器进程（ <em>Browser process</em> ）</p>
<p>控制浏览器除标签页外的用户界面，包括地址栏、书签、后退和前进按钮，以及负责和浏览器的其他进程协调工作。</p>
</li>
<li><p>插件进程（ <em>Plugin process</em> ）</p>
<p>控制网站所使用的所有插件，如 Flash。</p>
</li>
<li><p>渲染进程（ <em>Renderer process</em> ）</p>
<p>控制显示 tab 标签页内的所有内容，主要作用为页面渲染，脚本执行，事件处理等。浏览器在默认情况下会为每个标签页创建一个进程（这取决于浏览器选择的进程模型）</p>
<p>渲染进程是多线程的：</p>
<ul>
<li><p>JS 引擎线程</p>
<p>负责处理 Javascript 脚本程序。</p>
</li>
<li><p>GUI 渲染线程</p>
<p>负责渲染标签页内容，解析 HTML、CSS，构建 DOM 树，布局和绘制等。</p>
</li>
<li><p>事件触发线程</p>
<p>主要负责将准备好的事件交给 JS 引擎线程执行，比如 setTimeout 定时器计数结束，ajax 等异步请求成功并触发回调函数，或者用户触发点击事件时，该线程会将整装待发的事件依次加入到任务队列的尾部，等待 JS 引擎线程的执行。</p>
</li>
<li><p>定时触发器线程</p>
<p>负责执行异步定时器一类的函数的线程，如 setInterval，setTimeout 等。</p>
</li>
<li><p>异步 http 请求线程</p>
<p>负责异步请求一类的函数的线程，如 Promise，axios，ajax 等。</p>
</li>
<li><p>…</p>
</li>
</ul>
</li>
<li><p>GPU 进程（ <em>GPU process</em> ）</p>
<p>负责整个浏览器界面的渲染。</p>
<blockquote>
<p>其实，Chrome 刚开始发布的时候是没有 GPU 进程的。而 GPU 的使用初衷是为了实现 3D CSS 的效果，只是随后网页、Chrome 的 UI 界面都选择采用 GPU 来绘制，这使得 GPU 成为浏览器普遍的需求。最后，Chrome 在其多进程架构上也引入了 GPU 进程。</p>
</blockquote>
</li>
<li><p>…</p>
</li>
</ul>
<img src="/2022/02/21/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/%E6%B5%8F%E8%A7%88%E5%99%A8-%E5%A4%9A%E8%BF%9B%E7%A8%8B.png" class>

<p>从浏览器的进程角度来讲，浏览器内核指的是渲染进程。</p>
<br>

<hr>
<p>从浏览器输入 URL 开始，到页面渲染完成，浏览器做了哪些事情？</p>
<p>这是一个经典问题，也是作为前端程序员必须要掌握和理解的知识点。</p>
<p>整个过程可以分为以下几步：</p>
<ol>
<li>DNS 域名解析</li>
<li>建立 TCP 连接</li>
<li>发送 HTTP 请求</li>
<li>服务器处理请求并返回响应</li>
<li>浏览器解析并渲染页面</li>
<li>断开 TCP 连接</li>
</ol>
<p>接下来我们展开说说，以谷歌浏览器为例。</p>
<br>


        <h1 id="1-DNS-域名解析">
          <a href="#1-DNS-域名解析" class="heading-link"><i class="fas fa-link"></i></a><a href="#1-DNS-域名解析" class="headerlink" title="1.DNS 域名解析"></a>1.DNS 域名解析</h1>
      <p><strong>浏览器进程</strong>的<strong>UI 线程</strong>会捕捉输入框输入的内容，如果是网址，则 UI 线程会启动一个<strong>网络线程</strong>请求 DNS 进行域名解析；如果输入的不是网址而是关键字，就会使用默认配置的搜索引擎来查询。</p>
<p>我们重点关注 DNS 域名解析。</p>
<br>


        <h2 id="1-域名结构">
          <a href="#1-域名结构" class="heading-link"><i class="fas fa-link"></i></a><a href="#1-域名结构" class="headerlink" title="(1) 域名结构"></a>(1) 域名结构</h2>
      <p>以<code>www.bilibili.com</code>为例，我们通常认为它就是一个域名，但从严格意义上来讲，<code>bilibili.com</code>才是域名，<code>www</code>是服务器名，它表示在<code>bilibili.com</code>域名下，有一台叫做<code>www</code>的服务器。<code>服务器名.域名</code>称为完全限定域名，或者叫<strong>主机名</strong>。一个域名下可以有多个服务器，比如除了<code>www</code>外，<code>bilibili.com</code>域名下还有<code>mail</code>、<code>space</code>等服务器。</p>
<p>域名是由<code>.</code>进行划分的，<code>bilibili.com</code>中<code>bilibili</code>为二级域名，它又受<code>com</code>域名管理。<code>com</code>域名又叫做顶级域名，常见的顶级域名还有<code>cn</code>、<code>edu</code>等。那这些顶级域名又受谁管理呢？其实<code>www.bilibili.com</code>的完整写法应该是<code>www.bilibili.com.root</code>，或者简写成<code>www.bilibili.com.</code>，我们把最后这个<code>.</code>称为根域名，只不过一般我们会把这个<code>.</code>省略。</p>
<p>所以一个主机名的完整结构是：</p>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">服务器名.二级域名.顶级域名.根域名</span><br></pre></td></tr></table></div></figure>

<blockquote>
<p>有些人会把主机名也当做是域名，把服务器名也当做是一级域。所以会产生 <em><span class="exturl"><a class="exturl__link" target="_blank" rel="noopener" href="http://www.baidu.com/">www.baidu.com</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></em> 究竟是二级域名还是三级域名的讨论。这就看个人理解了。如果你认为 <em>baidu.com</em> 才是域名，<em>www</em> 是服务器名，那它就是二级域名；如果认为 <em><span class="exturl"><a class="exturl__link" target="_blank" rel="noopener" href="http://www.baidu.com/">www.baidu.com</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></em> 是域名，那它就是三级域名。</p>
</blockquote>
<br>


        <h2 id="2-DNS">
          <a href="#2-DNS" class="heading-link"><i class="fas fa-link"></i></a><a href="#2-DNS" class="headerlink" title="(2) DNS"></a>(2) DNS</h2>
      <p><em>DNS（Domain Name System）</em> ：域名系统。我们知道每一台主机都有一个 IP 地址，浏览器要想向输入的 URL 的主机名所对应的服务器发送请求，那就需要知道服务器的 IP 地址。DNS 的作用就是<strong>将主机名转换成 IP 地址</strong>。</p>
<p>DNS 是一个由分层的 DNS 服务器实现的<strong>分布式数据库</strong>，整个系统由分散在世界各地的许多台 DNS 服务器组成，每台 DNS 服务器上都保存了一些数据，这些数据能够让我们最终查询到主机名对应的 IP。</p>
<p>所以，DNS 域名解析，本质上就是去向 DNS 服务器查询 IP 地址。</p>
<br>


        <h2 id="3-DNS-服务器">
          <a href="#3-DNS-服务器" class="heading-link"><i class="fas fa-link"></i></a><a href="#3-DNS-服务器" class="headerlink" title="(3) DNS 服务器"></a>(3) DNS 服务器</h2>
      <p>DNS 服务器，也叫做<strong>域名服务器</strong>。</p>
<p>它有 3 种类型：</p>
<ul>
<li><p>根域名服务器</p>
<p>它的作用就是管理下一级，也就是顶级域名服务器。通过查询根域名服务器，我们可以知道一个主机名所对应的顶级域名服务器 IP 是多少，再继续向顶级域名服务器发起查询请求。</p>
</li>
<li><p>顶级域名服务器</p>
<p>_Top Level Domain（TLD）_：顶级域名服务器。除了刚刚提到的<code>com</code>外，常见的顶级域名还有<code>cn</code>、<code>org</code>、<code>edu</code>等。顶级域名服务器提供了下一级权威域名服务器的 IP 地址。</p>
</li>
<li><p>权威域名服务器</p>
<p>权威域名服务器管理自己域名下主机（服务器）的 IP 地址，最终可以返回<code>主机名 - IP</code>的映射。</p>
</li>
</ul>
<p>层次结构图：</p>
<img src="/2022/02/21/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/DNS-DNS%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84.png" class>

<p>除了上述讲到的三种类型的 DNS 服务器，还有一个<strong>本地域名服务器</strong>，但是严格来讲，本地域名服务器并不属于 DNS 服务器的层次结构，但是它对 DNS 有着重要作用。当主机发起 DNS 请求时，该请求会被发送到本地域名服务器，本地域名服务器起着<strong>代理</strong>的作用，负责将该请求<strong>转发</strong>到 DNS 服务器的层次结构中。</p>
<p>下面我们还是用一个例子展示 DNS 的查询过程。</p>
<br>


        <h2 id="4-查询过程">
          <a href="#4-查询过程" class="heading-link"><i class="fas fa-link"></i></a><a href="#4-查询过程" class="headerlink" title="(4) 查询过程"></a>(4) 查询过程</h2>
      <p>假设想要获取<code>www.bilibili.com</code>的 IP 地址。</p>
<ol>
<li><p>首先主机会向本地域名服务器发送一个 DNS 查询报文，其中包含了需要被转换的主机名<code>www.bilibili.com</code>。</p>
</li>
<li><p>本地域名服务器将该报文转发到根域名服务器。</p>
<p>注意：根域名服务器不止一台，全球共有 13 台根域名服务器，本地域名服务器会找最近的根域名服务器。</p>
</li>
<li><p>根域名服务器注意到该主机名的<code>com</code>前缀，就会向本地域名服务器返回<code>com</code>所对应的顶级域名服务器的 IP 地址<strong>列表</strong>。</p>
<p>意思就是，我并不知道<code>www.bilibili.com</code>的 IP，不过这些顶级域名服务器可能知道，你去问下他们吧。</p>
</li>
<li><p>本地域名服务器就向那些顶级域名服务器发送查询报文。</p>
</li>
<li><p>顶级域名服务器注意到了<code>bilibili.com</code>的前缀，就会向本地域名服务器返回对应的权威域名服务器的 IP 地址列表。</p>
<p>意思就是，我并不知道<code>www.bilibili.com</code>的 IP，不过这些权威域名服务器可能知道，你去问下他们吧。</p>
</li>
<li><p>本地域名服务器就向那些权威域名服务器发送查询报文。</p>
</li>
<li><p>最终在某一权威服务器中找到并返回<code>www.bilibili.com</code>的 IP 地址。</p>
<p>注意：如果域名被注册，必然能在域名服务器中找到对应的 IP 地址。</p>
</li>
</ol>
<img src="/2022/02/21/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/DNS-%E6%9F%A5%E8%AF%A2%E8%BF%87%E7%A8%8B-%E8%BF%AD%E4%BB%A3.png" class>

<p>如图所示，本地域名服务器向其他域名服务器发送查询请求的方式，就是<strong>迭代查询</strong>，所有请求都是由本地域名服务器发出，并且所有的响应都是直接返回给本地域名服务器。</p>
<p>还有另外一种查询方式叫做<strong>递归查询</strong>，如图：</p>
<img src="/2022/02/21/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/DNS-%E6%9F%A5%E8%AF%A2%E8%BF%87%E7%A8%8B-%E9%80%92%E5%BD%92.png" class>

<p>响应结果并不直接返回给本地域名服务器，而是由当前域名服务器向下一级域名服务器继续查找，直到找到目标 IP 地址，再逐级返回。</p>
<br>


        <h2 id="5-DNS-缓存">
          <a href="#5-DNS-缓存" class="heading-link"><i class="fas fa-link"></i></a><a href="#5-DNS-缓存" class="headerlink" title="(5) DNS 缓存"></a>(5) DNS 缓存</h2>
      <p>为了更快地获得 IP，DNS 广泛使用了缓存技术。</p>
<ol>
<li>在本地 DNS 服务器向根 DNS 服务器查询请求前，它会先去浏览器自身的 DNS 缓存中查找，如果存在，则解析结束。</li>
<li>如果浏览器自身的 DNS 缓存中没有，那么会尝试去读取操作系统中的 hosts 文件，看看是否有对应的映射关系，如果存在，则解析结束。</li>
<li>如果本地 hosts 文件中没有，则去查找本地 DNS 服务器（ISP 服务器，或者自己手动设置的 DNS 服务器）中的 DNS 缓存，如果存在，则解析结束。</li>
<li>如果上述三步中都不存在相应缓存，就开始进行查询请求。</li>
</ol>
<img src="/2022/02/21/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/DNS-%E7%BC%93%E5%AD%98.png" class>

<br>


        <h1 id="2-建立-TCP-连接">
          <a href="#2-建立-TCP-连接" class="heading-link"><i class="fas fa-link"></i></a><a href="#2-建立-TCP-连接" class="headerlink" title="2.建立 TCP 连接"></a>2.建立 TCP 连接</h1>
      <p>通过 DNS 域名解析，获取到目标 IP 地址后，需要和其建立 TCP 连接，也就是我们常说的三次握手。</p>
<br>


        <h2 id="1-格式">
          <a href="#1-格式" class="heading-link"><i class="fas fa-link"></i></a><a href="#1-格式" class="headerlink" title="(1) 格式"></a>(1) 格式</h2>
      <p>TCP 头部格式：</p>
<img src="/2022/02/21/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/TCP.jpg" class>

<p>其中有 6 个标志位：</p>
<ul>
<li>SYN（synchronous 建立联机）</li>
<li>ACK（acknowledgement 确认）</li>
<li>PSH（push 传送）</li>
<li>FIN（finish 结束）</li>
<li>RST（reset 重置）</li>
<li>URG（urgent 紧急）</li>
</ul>
<br>


        <h2 id="2-三次握手">
          <a href="#2-三次握手" class="heading-link"><i class="fas fa-link"></i></a><a href="#2-三次握手" class="headerlink" title="(2) 三次握手"></a>(2) 三次握手</h2>
      <img src="/2022/02/21/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/TCP-%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B.png" class>

<ol>
<li><p>SYN 连接请求(客户端)</p>
<p>主机 A 发送<code>seq=x，SYN=1</code>的数据包给主机 B，其中<code>seq=x</code>表示这条数据包的序号。</p>
<p>这就是第一次握手，由客户端发出，服务端接收。</p>
</li>
<li><p>SYN、ACK 确认(服务端)</p>
<p>主机 B 接收到后根据<code>SYN=1</code>知道了 A 要求建立连接。向 A 发送<code>seq=y，ack=x+1，SYN=1，ACK=1</code>的数据包，其中<code>seq=y</code>表示这条数据包的序号，<code>ack=x+1</code>表示这条数据包是对主机 A 之前发送的<code>seq=x</code>的数据包的确认，只有标志位<code>ACK=1</code>时，这个确认序列号，也就是<code>ack</code>才是有效的。</p>
<p>相当于告诉主机 A 我已经准备好了。这就是第二次握手，由服务端发出，客户端接收。</p>
</li>
<li><p>ACK 确认(客户端)</p>
<p>主机 A 收到后，检查<code>ACK</code>是否为 1，如果是，继续检查<code>ack</code>是否正确，即第一次发送数据包的<code>seq+1</code>，同时检查<code>SYN</code>是否为 1，如果都满足，则再次发送一条<code>seq=x+1，ack=y+1，ACK=1</code>的数据包，其中<code>seq=x+1</code>表示这条数据包的序号，<code>ack=y+1</code>表示这条数据包是对主机 B 返回的<code>seq=y</code>的数据包的确认。主机 B 收到后，检查<code>ACK、ack</code>是否正确，如果正确则连接建立成功。</p>
<p>这就是第三次握手，由客户端发出，服务端接收。</p>
</li>
</ol>
<blockquote>
<p>为什么要三次握手？</p>
<p>其实这是由 TCP 自身可靠传输的特点决定的。客户端和服务端要进行可靠传输，那么就需要确认双方的接收和发送能力。第一次握手可以确认客户端的发送能力，第二次握手，确认了服务端的发送能力和接收能力，所以第三次握手才可以确认客户端的接收能力。不然容易出现丢包的现象。</p>
</blockquote>
<br>


        <h1 id="3-发送-HTTP-请求">
          <a href="#3-发送-HTTP-请求" class="heading-link"><i class="fas fa-link"></i></a><a href="#3-发送-HTTP-请求" class="headerlink" title="3.发送 HTTP 请求"></a>3.发送 HTTP 请求</h1>
      <p>在成功和服务端建立连接之后，就可以发送 http 请求了。</p>
<br>


        <h2 id="1-格式-1">
          <a href="#1-格式-1" class="heading-link"><i class="fas fa-link"></i></a><a href="#1-格式-1" class="headerlink" title="(1) 格式"></a>(1) 格式</h2>
      <p><strong>请求报文：</strong></p>
<figure class="highlight javascript"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">行:GET url HTTP/<span class="number">1.1</span></span><br><span class="line">头:Content-Type:application/x-www-form-urlencoded</span><br><span class="line">空行</span><br><span class="line">体:...</span><br></pre></td></tr></table></div></figure>

<p><strong>响应报文：</strong></p>
<figure class="highlight javascript"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">行:HTTP/<span class="number">1.1</span> <span class="number">200</span> OK</span><br><span class="line">头:Content-Type: text/plain; charset=UTF-<span class="number">8</span></span><br><span class="line">空行</span><br><span class="line">体:...</span><br></pre></td></tr></table></div></figure>

<br>


        <h2 id="2-状态码">
          <a href="#2-状态码" class="heading-link"><i class="fas fa-link"></i></a><a href="#2-状态码" class="headerlink" title="(2) 状态码"></a>(2) 状态码</h2>
      <div class="table-container"><table>
<thead>
<tr>
<th>状态码</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>1xx</td>
<td>服务器收到请求</td>
</tr>
<tr>
<td>2xx</td>
<td>请求成功</td>
</tr>
<tr>
<td>3xx</td>
<td>重定向</td>
</tr>
<tr>
<td>4xx</td>
<td>客户端错误</td>
</tr>
<tr>
<td>5xx</td>
<td>服务端错误</td>
</tr>
</tbody></table></div>
<br>


        <h2 id="3-HTTP-缓存">
          <a href="#3-HTTP-缓存" class="heading-link"><i class="fas fa-link"></i></a><a href="#3-HTTP-缓存" class="headerlink" title="(3) HTTP 缓存"></a>(3) HTTP 缓存</h2>
      <p>什么是 HTTP 缓存？当客户端向服务端请求资源时，会先去缓存中找，如果缓存中存在该资源的副本，则直接从缓存中提取而不是去向服务端请求。</p>
<p>为什么需要 HTTP 缓存？因为网络请求相比较于 CPU 的计算和页面渲染是非常慢的。使用缓存可以加快页面加载速度，同时减少服务器的负担。</p>
<p>哪些资源可以被缓存？静态资源，比如 js、css、图片等。</p>
<blockquote>
<p>HTTP 缓存和 DNS 缓存是不一样的，DNS 缓存记录的是主机名到 IP 的映射关系，HTTP 缓存的是静态资源。除此之外，还有一个浏览器缓存，即<em>Cookie、SessionStorage、LocalStorage</em>等，不过这不是本文重点，感兴趣的可以另行查看。</p>
</blockquote>
<p>HTTP 缓存又两种类型：</p>
<ul>
<li>强缓存</li>
<li>协商缓存</li>
</ul>
<p>下面我们依次介绍</p>
<br>


        <h3 id="1-强缓存">
          <a href="#1-强缓存" class="heading-link"><i class="fas fa-link"></i></a><a href="#1-强缓存" class="headerlink" title="1) 强缓存"></a>1) 强缓存</h3>
      <p>强缓存就是向浏览器 HTTP 缓存查找该请求结果，并根据该结果的缓存规则来决定是否使用该结果的过程。</p>
<p>简单来讲，就是去设置资源的有效时间，当再次请求相同资源时，如果缓存仍然有效，直接从缓存中读取资源。</p>
<p>强缓存分了两种方式：<code>Expires</code>和<code>Cache-Control</code></p>
<ul>
<li><em>Expries</em><ul>
<li>版本：HTTP/1.0</li>
<li>来源：存在于服务端返回的响应头中</li>
<li>语法：Expires: Wed, 22 Nov 2019 08:41:00 GMT</li>
<li>缺点：服务器的时间和浏览器的时间可能并不一致导致失效</li>
</ul>
</li>
<li><em>Cache-Control</em><ul>
<li>版本：HTTP/1.1</li>
<li>来源：响应头和请求头</li>
<li>语法：Cache-Control:max-age=3600</li>
</ul>
</li>
</ul>
<p>当前 HTTP 版本为 1.1，所以强缓存更多的是采用 _Cache-Control_，我们重点来聊 _Cache-Control_。它的具体表现就是在请求头和响应头中添加了 <em>Cache-Control</em> 字段，用来判断该资源的缓存规则。</p>
<p>该字段常见的值如下：</p>
<div class="table-container"><table>
<thead>
<tr>
<th>值</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>max-age=delta-seconds</td>
<td>缓存最大过期时间为 delta-seconds 秒</td>
</tr>
<tr>
<td>no-cache</td>
<td>客户端可以存储资源，但是每次都要去和服务端做新鲜度校验，来决定是重新获取还是直接使用缓存</td>
</tr>
<tr>
<td>no-store</td>
<td>永远不在客户端存储资源，永远都是去原始服务器去获取资源</td>
</tr>
</tbody></table></div>
<img src="/2022/02/21/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/http-%E5%BC%BA%E7%BC%93%E5%AD%98-Cache-Control.png" class>

<blockquote>
<p>注意：虽然请求头和响应头中都能设置 <em>Cache-Control</em> 字段，但一般是响应头发挥作用，比如请求头设置 max-age 为 60s，响应头设置为 30s，最后结果是 30s 缓存就失效了，也就是说服务端的设置决定了缓存的有效时间，另外，只有服务端有能力开启缓存，如果请求头设置 _Cache-Control_，而服务端不设置，缓存是不生效的。那么请求头中的 <em>Cache-Control</em> 有什么用呢？只有请求头中设置了 <em>Cache-Control</em> 值为 no-store 或者 no-cache 或者 max-age=0，也就是客户端不想要走强缓存，那这个 <em>Cache-Control</em> 才是有用的。</p>
</blockquote>
<br>


        <h3 id="2-协商缓存">
          <a href="#2-协商缓存" class="heading-link"><i class="fas fa-link"></i></a><a href="#2-协商缓存" class="headerlink" title="2) 协商缓存"></a>2) 协商缓存</h3>
      <p>协商缓存就是在强制缓存失效后，浏览器携带缓存标识向服务器发起请求，由服务器根据缓存标识是否决定使用缓存的过程。</p>
<p>简单来讲，就是当强缓存失效时，我们需要去判断缓存中的资源是否仍然有效，如果仍然有效，依旧从缓存中读取资源。</p>
<p>协商缓存也有两种：</p>
<ul>
<li><p><em>Last-Modified / if-Modified-Since</em></p>
<ul>
<li>意义：资源最后修改时间</li>
<li>来源：<em>Last-Modified</em> 在响应头中，<em>if-Modified-Since</em> 在请求头中</li>
<li>判断：如果这两个值相同，表示资源并没有更新过，返回 304；不一致则表示资源更新过，就返回 200 和新的资源以及新的 <em>Last-Modified</em></li>
</ul>
<img src="/2022/02/21/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/http-%E5%8D%8F%E5%95%86%E7%BC%93%E5%AD%98-Last-Modified.png" class></li>
<li><p><em>Etag / if-None-Match</em></p>
<ul>
<li>意义：资源的唯一标识（一个字符串，类似于人类的指纹）</li>
<li>来源：<em>Etag</em> 在响应头中，<em>if-None-Match</em> 在请求头中</li>
<li>判断： 如果这两个值相同，表示资源并没有更新过，返回 304；不一致则表示资源更新过，就返回 200 和新的资源以及新的 <em>Etag</em></li>
</ul>
<img src="/2022/02/21/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/http-%E5%8D%8F%E5%95%86%E7%BC%93%E5%AD%98-Etag.png" class></li>
</ul>
<p>那么这两种方式有什么区别呢？其实 <em>Etag</em> 和 <em>Last-Modified</em> 判断资源的方式是一样，只不过后者是一个时间，前者是对资源按照一定方式计算出来的唯一标识，如果资源发生了更新，这个唯一标识必然会有变化。</p>
<p>两者比较：</p>
<ol>
<li>优先使用 <em>Etag</em></li>
<li><em>Last-Modified</em> 只能精确到秒</li>
<li>如果资源重复生成，但内容不变，使用 <em>Etag</em> 更精确</li>
</ol>
<br>


        <h3 id="3-综合流程">
          <a href="#3-综合流程" class="heading-link"><i class="fas fa-link"></i></a><a href="#3-综合流程" class="headerlink" title="3) 综合流程"></a>3) 综合流程</h3>
      <img src="/2022/02/21/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/http-%E7%BC%93%E5%AD%98-%E6%B5%81%E7%A8%8B.png" class>

<br>


        <h3 id="4-页面刷新对-HTTP-缓存的影响">
          <a href="#4-页面刷新对-HTTP-缓存的影响" class="heading-link"><i class="fas fa-link"></i></a><a href="#4-页面刷新对-HTTP-缓存的影响" class="headerlink" title="4) 页面刷新对 HTTP 缓存的影响"></a>4) 页面刷新对 HTTP 缓存的影响</h3>
      <p>有三中刷新类型：</p>
<ul>
<li><p>正常操作：浏览器输入 url、连接跳转、前进后退</p>
<p>强制缓存和协商缓存都有效</p>
</li>
<li><p>手动刷新：f5、点击刷新按钮、右键菜单刷新</p>
<p>强制缓存失效，协商缓存有效</p>
</li>
<li><p>强制刷新：ctrl + f5、shift + command + r</p>
<p>强制缓存和协商缓存都失效</p>
</li>
</ul>
<br>


        <h1 id="4-服务器处理请求并返回响应">
          <a href="#4-服务器处理请求并返回响应" class="heading-link"><i class="fas fa-link"></i></a><a href="#4-服务器处理请求并返回响应" class="headerlink" title="4.服务器处理请求并返回响应"></a>4.服务器处理请求并返回响应</h1>
      <p>每台服务器上都会安装处理请求的应用—— <em>Web Server</em> 。常见的 <em>Web Server</em> 产品有 <code>apache</code>、<code>nginx</code>、<code>IIS</code> 或 <code>Lighttpd</code> 等。</p>
<p>HTTP 请求一般可以分为两类，静态资源和动态资源。</p>
<p>请求访问静态资源，这个就直接根据 url 地址去服务器里找就好了。</p>
<p>请求动态资源的话，就需要 <em>web server</em> 把不同请求，委托给服务器上处理相应请求的程序进行处理，然后返回后台程序处理产生的结果作为响应，发送到客户端。</p>
<br>


        <h1 id="5-浏览器解析并渲染页面">
          <a href="#5-浏览器解析并渲染页面" class="heading-link"><i class="fas fa-link"></i></a><a href="#5-浏览器解析并渲染页面" class="headerlink" title="5.浏览器解析并渲染页面"></a>5.浏览器解析并渲染页面</h1>
      <p>当网络线程获取到数据后，终于要开始渲染页面了。</p>
<p>（如果是谷歌浏览器，当网络线程获取到数据后，需要通过<strong>SafeBrowsing</strong>检查站点是否是恶意站点，SafeBrowsing 是谷歌内部的一套站点安全系统，通过检测该站点的数据来判断是否安全，通过安全校验后，才进入渲染流程）</p>
<br>


        <h2 id="1-渲染流程">
          <a href="#1-渲染流程" class="heading-link"><i class="fas fa-link"></i></a><a href="#1-渲染流程" class="headerlink" title="(1) 渲染流程"></a>(1) 渲染流程</h2>
      <ol>
<li><p>浏览器进程会启动一个<strong>渲染进程</strong>，并将数据（也就是 html）通过<strong>IPC 管道</strong>传递给渲染进程，正式开始渲染流程。</p>
<blockquote>
<p>渲染进程的核心任务就是把 html、css、js、图片等资源渲染成用户能交互的 web 页面。</p>
</blockquote>
</li>
<li><p>渲染进程的主线程会将 html 进行解析，构造<strong>DOM 数据结构</strong>，html 首先通过<strong>Tokeniser 标记化</strong>，通过语法分析将 html 内容解析成多个标记，根据识别后的标记进行<strong>DOM 树构造</strong>，DOM 树构造过程中会创建<strong>document 对象</strong>，然后以 document 对象为根节点的 DOM 树不断进行修改，向其中添加各种元素。</p>
<blockquote>
<p>html 中引入的其他资源，如图片、css、js 等，图片和 CSS 等需要通过<strong>http 请求下载</strong>或者从<strong>http 缓存</strong>中直接加载，这些资源不会阻塞 html 的解析，因为它们不会影响 DOM 的生成，但如果解析过程中遇到 script 标签，就会暂停解析，<strong>先去加载解析并执行 js 脚本</strong>，因为 js 中可能会改变当前页面 html 结构。或者使用 <em>async</em> 或者 <em>defer</em> 属性来异步加载执行 js。</p>
<p>主线程就是指 JS 引擎线程和 GUI 渲染线程，这两个线程是互斥的，JS 引擎线程执行时，GUI 渲染线程不执行，反之亦然。</p>
</blockquote>
<img src="/2022/02/21/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/%E6%B8%B2%E6%9F%93%E6%B5%81%E7%A8%8B-1.png" class></li>
<li><p>DOM 树构建完毕后，主线程需要解析 CSS 并确定每个 DOM 节点的<strong>计算样式</strong>。</p>
<blockquote>
<p>即使你没有自定义样式，浏览器也会有自己的默认样式表。</p>
</blockquote>
<img src="/2022/02/21/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/%E6%B8%B2%E6%9F%93%E6%B5%81%E7%A8%8B-2.png" class></li>
<li><p>在知道 DOM 结构和每个节点的样式后，我们接下来需要知道每个节点放在页面上的哪个位置，也就是节点的坐标以及该节点需要占用多大的区域，这一阶段叫做<strong>Layout 布局</strong>。主线程通过遍历 DOM 树和计算好的样式来生成<strong>Layout 树</strong>，Layout 树上的每个节点都记录了 x，y 坐标和边框尺寸。</p>
<blockquote>
<p>DOM 树和 Layout 树并不是一一对应的，如设置了 <em>display:none</em> 的元素不会出现在 Layout 树中，而在 <em>before</em> 伪元素中添加了 <em>content</em> 值的元素，<em>content</em> 中的内容会出现在 Layout 树中，不会出现在 DOM 树中。这是因为 DOM 树是根据解析 html 所得，并不关心样式；而 Layout 树是根据 DOM 节点和计算好的样式来生成，和最终展示在页面上的节点是对应的。</p>
</blockquote>
<img src="/2022/02/21/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/%E6%B8%B2%E6%9F%93%E6%B5%81%E7%A8%8B-3.png" class></li>
<li><p>Layout 树创建完毕后，我们还需要知道这些元素要以什么样的顺序进行绘制（比如 z-index 就会影响绘制顺序），主线程遍历 Layout 树，创建一个<strong>绘制记录表</strong>，该表记录了绘制的顺序，这个阶段称为**绘制(Paint)**。</p>
<img src="/2022/02/21/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/%E6%B8%B2%E6%9F%93%E6%B5%81%E7%A8%8B-4.png" class></li>
<li><p>现在知道了元素的绘制顺序，就到了需要把这些信息真正转化成像素点，显示到屏幕上的时候了，这个阶段称为**栅格化(光栅化)**。</p>
</li>
<li><p>主线程遍历 Layout 树，生成<strong>Layer(图层)树</strong>，将这些信息传递给<strong>合成器线程</strong>，合成器线程将每个图层栅格化，生成<strong>合成器帧</strong>。</p>
<blockquote>
<p>早期的 Chrome 栅格化方案：只栅格化页面显示的内容，当页面滚动时，再栅格化更多的内容来填充缺失的部分，这种方式会导致展示延迟。</p>
<p>现在的 Chrome 采用更为复杂的栅格化方案，称为<strong>合成</strong>：将页面内的各个部分分成多个图层，分别对其进行栅格化，并在合成器线程中单独合成页面。上述操作即采用该方案。</p>
</blockquote>
<img src="/2022/02/21/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/%E6%B8%B2%E6%9F%93%E6%B5%81%E7%A8%8B-5.png" class>

<img src="/2022/02/21/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/%E6%B8%B2%E6%9F%93%E6%B5%81%E7%A8%8B-6.png" class></li>
<li><p>合成器帧通过 IPC 传送给<strong>浏览器进程</strong>，接着浏览器进程将合成器帧传送到<strong>GPU</strong>，最终渲染展示到屏幕上。当页面发生变化，如滚动了页面，合成器线程则会生成一个新的合成器帧，再重复上述操作。</p>
<img src="/2022/02/21/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/%E6%B8%B2%E6%9F%93%E6%B5%81%E7%A8%8B-7.png" class></li>
</ol>
<p>综述：</p>
<img src="/2022/02/21/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/%E6%B8%B2%E6%9F%93%E6%B5%81%E7%A8%8B-%E7%BB%BC%E8%BF%B0-1.png" class>

<img src="/2022/02/21/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/%E6%B8%B2%E6%9F%93%E6%B5%81%E7%A8%8B-%E7%BB%BC%E8%BF%B0-2.jpg" class>

<br>


        <h2 id="2-重排-重绘">
          <a href="#2-重排-重绘" class="heading-link"><i class="fas fa-link"></i></a><a href="#2-重排-重绘" class="headerlink" title="(2) 重排/重绘"></a>(2) 重排/重绘</h2>
      <ul>
<li><p><strong>重排</strong></p>
<p>当改变一个元素的尺寸位置属性时，会重新进行样式计算、布局(Layout)、绘制(Paint)以及后面的所有流程，这个行为称为重排，也叫作<strong>回流(reflow)</strong></p>
</li>
<li><p><strong>重绘</strong></p>
<p>当改变某个元素的颜色属性时，不会重新触发布局(Layout)，但还是会触发样式计算和绘制(Paint)，这个行为称为<strong>重绘(repaint)</strong></p>
</li>
</ul>
<blockquote>
<p>重排一定会引起重绘，而重绘不一定会引起重排。</p>
</blockquote>
<p>由于重排重绘会占用主线程、同时 JS 也会抢占主线程，这就会导致页面出现卡顿情况。同时，大量的重排重绘会造成额外的计算消耗。所以要尽量减少重排重绘。那么该如何减少重排重绘呢？</p>
<ul>
<li>最少化重排重绘，比如样式集中改变，使用添加新样式类名<code>.class</code>或<code>cssText</code>。</li>
<li>使用 <code>absolute</code> 或 <code>fixed</code>使元素脱离文档流，这在制作复杂的动画时对性能的影响比较明显。</li>
<li>开启 GPU 加速，利用 css 属性 <code>transform</code> 、<code>will-change</code> 等，因为它们不会触发重排重绘。</li>
</ul>
<br>


        <h1 id="6-断开-TCP-连接">
          <a href="#6-断开-TCP-连接" class="heading-link"><i class="fas fa-link"></i></a><a href="#6-断开-TCP-连接" class="headerlink" title="6.断开 TCP 连接"></a>6.断开 TCP 连接</h1>
      <p>当所有操作完，关闭页面，就会断开 TCP 连接。也就是我们常说的四次挥手。</p>
<blockquote>
<p>http1.1 是默认不断开 TCP 连接的，因为连接建立需要耗费资源，多个 HTTP 请求会复用 TCP 通道。所以当页面关闭时，TCP 连接才断开。</p>
</blockquote>
<br>


        <h2 id="1-四次挥手">
          <a href="#1-四次挥手" class="heading-link"><i class="fas fa-link"></i></a><a href="#1-四次挥手" class="headerlink" title="(1) 四次挥手"></a>(1) 四次挥手</h2>
      <img src="/2022/02/21/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/TCP-%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B.png" class>

<p>首先要明确一点，客户端和服务端都可以发起关闭连接请求。我们假设是客户端发起关闭请求。</p>
<ol>
<li><p>FIN 请求（客户端）</p>
<p>主机 A 发送一条<code>seq=x，FIN=1</code>的数据包给主机 B，其中<code>seq=x</code>表示这条数据包的序号。</p>
<p>这就是第一次挥手。</p>
</li>
<li><p>ACK 确认（服务端）</p>
<p>主机 B 接收到后根据<code>FIN=1</code>知道要断开连接。向 A 发送一条<code>seq=y，ack=x+1，ACK=1</code>的数据包，其中<code>seq=y</code>表示这条数据包的序号，<code>ack=x+1</code>表示这条数据包是对主机 A<code>seq=x</code>的数据包的确认。</p>
<p>这就是第二次挥手。告诉对方我已经知道了。但是这时候还没有立刻关闭，而是处于一个<code>关闭等待</code>的状态。因为这时候服务端可能还在发送数据，只有数据发送完了才能发送 FIN 数据包。</p>
</li>
<li><p>FIN、ACK 确认（服务端）</p>
<p>当数据发送完毕，主机 B 发送一条<code>seq=z，ack=x+1，ACK=1，FIN=1</code>的数据包给主机 A，其中<code>seq=z</code>表示这条数据包的序号，<code>ack=x+1</code>表示这条数据包是对主机 A<code>seq=x</code>的数据包的确认。</p>
<p>这就是第三次挥手。</p>
</li>
<li><p>ACK 确认（客户端）</p>
<p>主机 A 接收到后，检查<code>ACK</code>是否为 1，<code>ack</code>是否为第一次发送数据包的<code>seq+1</code>，检查<code>FIN</code>是否为 1，如果都正确，主机 A 向主机 B 发送一条<code>seq=x+1，ack=z+1，ACK=1</code>的数据包。主机 B 收到后，检查<code>ack、ACK</code>是否正确，正确则关闭连接。</p>
<p>这就是第四次挥手。</p>
<blockquote>
<p>客户端在发送 ACK 数据包后，不是立刻就关闭连接，而是需要等待一段时间，因为虽然理论上四个数据包发送完毕就可以直接关闭连接了，但是网络是不可靠的，可能存在最后这个 ACK 数据包没有被服务端接收到的情况，服务端在长时间没有收到 ACK 数据包后，会重新发送一次 FIN 数据包。如果客户端在发送 ACK 数据包后立刻关闭连接，就无法收到这条重发的 FIN 数据包，导致服务端关闭连接失败，造成资源的浪费。所以客户端在发送 ACK 数据包后，需要等待一段时间，等待时间长度为 2MSL，MSL（ <em>Maximum Segment Life</em> ）是 TCP 对数据包生存时间的限制，发送后超过这个时间还未被接收到，就认为这个数据包丢失，2MSL 能确保客户端收到重发的 FIN 数据包。</p>
</blockquote>
</li>
</ol>
<br>

<blockquote>
<p>参考：</p>
<p><span class="exturl"><a class="exturl__link" target="_blank" rel="noopener" href="https://blog.csdn.net/BonJean/article/details/78453547">https://blog.csdn.net/BonJean/article/details/78453547</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
<p><span class="exturl"><a class="exturl__link" target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/102149546">https://zhuanlan.zhihu.com/p/102149546</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
<p><span class="exturl"><a class="exturl__link" target="_blank" rel="noopener" href="https://juejin.cn/post/6935232082482298911">https://juejin.cn/post/6935232082482298911</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
<p><span class="exturl"><a class="exturl__link" target="_blank" rel="noopener" href="https://juejin.cn/post/6990344840181940261">https://juejin.cn/post/6990344840181940261</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
<p><span class="exturl"><a class="exturl__link" target="_blank" rel="noopener" href="https://juejin.cn/post/6998389354271866910">https://juejin.cn/post/6998389354271866910</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
<p><span class="exturl"><a class="exturl__link" target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1x54y1B7RE">https://www.bilibili.com/video/BV1x54y1B7RE</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
<p><span class="exturl"><a class="exturl__link" target="_blank" rel="noopener" href="https://www.imooc.com/wenda/detail/499811">https://www.imooc.com/wenda/detail/499811</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
</blockquote>
</div></div></article><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/2022/02/21/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">计算机网络</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">发表于</span><span class="post-meta-item__value">2022-02-21</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__info">更新于</span><span class="post-meta-item__value">2022-03-03</span></span></div></header><div class="post-body"><div class="post-excerpt">
        <h1 id="一-计算机网络概述">
          <a href="#一-计算机网络概述" class="heading-link"><i class="fas fa-link"></i></a><a href="#一-计算机网络概述" class="headerlink" title="一.计算机网络概述"></a>一.计算机网络概述</h1>
      
        <h2 id="1-计算机网络基本概念">
          <a href="#1-计算机网络基本概念" class="heading-link"><i class="fas fa-link"></i></a><a href="#1-计算机网络基本概念" class="headerlink" title="1.计算机网络基本概念"></a>1.计算机网络基本概念</h2>
      <p>计算机网络是<strong>互连</strong>的、<strong>自治</strong>的计算机的集合</p>
<ul>
<li><p><strong>协议</strong></p>
<p>协议是网络通信实体之间在数据交换过程中需要遵循的规则或约定，包括三个基本要素：</p>
<p>语法、语义、时序</p>
</li>
<li><p><strong>功能</strong></p>
<ul>
<li>硬件资源共享</li>
<li>软件资源共享</li>
<li>信息资源共享</li>
</ul>
</li>
<li><p><strong>分类</strong></p>
<ul>
<li><p>按照覆盖范围：个域网、局域网、城域网、广域网</p>
</li>
<li><p>按照拓扑结构：星形、总线型、环形、网状、树形、混合拓扑结构</p>
</li>
<li><p>按照交换方式：电路交换网络、报文交换网络、分组交换网络</p>
</li>
<li><p>按照网络用户属性：公用网、私有网</p>
</li>
</ul>
</li>
</ul>
<br>


        <h2 id="2-计算机网络结构">
          <a href="#2-计算机网络结构" class="heading-link"><i class="fas fa-link"></i></a><a href="#2-计算机网络结构" class="headerlink" title="2.计算机网络结构"></a>2.计算机网络结构</h2>
      <ul>
<li><p><strong>网络边缘</strong></p>
</li>
<li><p><strong>接入网络</strong></p>
<ul>
<li>电话拨号</li>
<li>非对称用户数字线 ADSL</li>
<li>混合光纤同轴电缆 HFC</li>
<li>局域网</li>
<li>移动接入网络</li>
</ul>
</li>
<li><p><strong>网络核心</strong></p>
<p>网络核心是由通信链路互连的分组交换设备构成的网络。作用是实现网络边缘中主机之间的数据中继和转发</p>
</li>
</ul>
<br>


        <h2 id="3-数据交换技术">
          <a href="#3-数据交换技术" class="heading-link"><i class="fas fa-link"></i></a><a href="#3-数据交换技术" class="headerlink" title="3.数据交换技术"></a>3.数据交换技术</h2>
      <ul>
<li><p><strong>电路交换</strong></p>
<p>首先需要通过中间交换结点为两台主机之间建立一条专用的通信线路，称为电路，然后再利用该电路进行通信，通信结束后再拆除电路。</p>
<ul>
<li><p>优点：</p>
<p><strong>实时性高</strong>，时延和时延抖动都较少</p>
</li>
<li><p>缺点：</p>
<p>对于突发性数据传输，<strong>信道利用率低</strong>，传输速率单一</p>
</li>
</ul>
</li>
<li><p><strong>报文交换</strong></p>
<p>以报文为单位在交换网络各结点之间以<strong>存储-转发</strong>的方式传送</p>
<ul>
<li><p>优点：</p>
<p><strong>不需要建立连接</strong>；只有当报文被转发时才占用相应的信道</p>
</li>
<li><p>缺点：</p>
<p>报文都需要缓冲存储，报文需要排队，<strong>增加了延时</strong></p>
</li>
</ul>
</li>
<li><p><strong>分组交换</strong></p>
<p>分组交换将一个完整报文拆分成若干个分组，分组传输过程通常也需要采用<strong>存储-转发</strong>交换方式</p>
<ul>
<li><p>优点：</p>
<p>交换设备<strong>存储容量要求低</strong></p>
<p>交换<strong>速度快</strong></p>
<p>可靠传输<strong>效率高</strong></p>
<p>更加<strong>公平</strong></p>
</li>
<li><p>分组长度确定：</p>
<p>分组长度与<strong>延迟时间</strong></p>
<p>分组长度与<strong>误码率</strong></p>
</li>
</ul>
</li>
</ul>
<br>


        <h2 id="4-网络性能">
          <a href="#4-网络性能" class="heading-link"><i class="fas fa-link"></i></a><a href="#4-网络性能" class="headerlink" title="4.网络性能"></a>4.网络性能</h2>
      <ul>
<li><p><strong>速率和带宽</strong></p>
<p><strong>速率</strong>：指网络单位时间内传送的数据量，也称为数据传输速率或数据速率。基本单位是 bit/s（位每秒）</p>
<p><strong>带宽</strong>：原本是指信号具有的频带宽度，即信号成分的最高频率和最低频率之差，单位是 Hz（赫兹）</p>
</li>
<li><p><strong>时延</strong></p>
<p>时延是指数据从网络的一个结点(主机或交换设备等)到达另一结点所需要的时间</p>
<p>分组的每跳传输过程主要产生 4 类时间延迟：</p>
<ul>
<li>节点处处理时延</li>
<li>排队时延</li>
<li>传输时延</li>
<li>传播时延</li>
</ul>
</li>
<li><p><strong>时延带宽积</strong></p>
<p>一段物理链路的传播时延与链路带宽的乘积</p>
<p>表示一段链路可以容纳的数据位数，也称为以位为单位的链路长度</p>
</li>
<li><p><strong>丢包率</strong></p>
<p>丢包率常被用于评价和衡量网络性能的指标，在很大程度上可以反应网络的<strong>拥塞程度</strong></p>
<p>丢包率 = 丢失分组总数 / 发送分组总数</p>
</li>
<li><p><strong>吞吐量</strong></p>
<p>单位时间内源主机通过网络向目的主机实际送达的数据量</p>
</li>
</ul>
<br>


        <h2 id="5-计算机网络体系结构">
          <a href="#5-计算机网络体系结构" class="heading-link"><i class="fas fa-link"></i></a><a href="#5-计算机网络体系结构" class="headerlink" title="5.计算机网络体系结构"></a>5.计算机网络体系结构</h2>
      <p><strong>分层思想</strong></p>
<ul>
<li><p><strong>OSI 参考模型</strong></p>
<p>物理层、数据链路层、网络层、传输层、会话层、展示层、应用层（从下而上）</p>
</li>
<li><p><strong>TCP/IP 参考模型</strong></p>
<p>网络接口层、网际层、运输层、应用层</p>
</li>
<li><p><strong>五层参考模型</strong></p>
<p>物理层、链路层、网络层、传输层、应用层</p>
</li>
</ul>
<p><strong>单位</strong></p>
<p>比特流（物理层）</p>
<p>帧（链路层）</p>
<p>数据报（网络层）</p>
<p>段（传输层）</p>
<p>报文（应用层）</p>
<br>


        <h1 id="二-网络应用">
          <a href="#二-网络应用" class="heading-link"><i class="fas fa-link"></i></a><a href="#二-网络应用" class="headerlink" title="二.网络应用"></a>二.网络应用</h1>
      
        <h2 id="1-计算机网络应用体系结构">
          <a href="#1-计算机网络应用体系结构" class="heading-link"><i class="fas fa-link"></i></a><a href="#1-计算机网络应用体系结构" class="headerlink" title="1.计算机网络应用体系结构"></a>1.计算机网络应用体系结构</h2>
      <ul>
<li><p><strong>客户/服务器（C/S）结构</strong></p>
<p>最主要的特征是通信只在客户与服务器之间进行，客户与客户之间不进行直接通信。</p>
</li>
<li><p><strong>P2P（Peer to Peer）结构</strong></p>
<p>每个对等端都同时具备 C/S 应用的客户与服务器的特征，是一个服务器和客户的结合体，对等端之间可以直接通信。</p>
</li>
<li><p><strong>混合结构</strong></p>
<p>既有中心服务器的存在，又有对等端（客户）间的直接通信。</p>
</li>
</ul>
<br>


        <h2 id="2-网络应用通信基本原理">
          <a href="#2-网络应用通信基本原理" class="heading-link"><i class="fas fa-link"></i></a><a href="#2-网络应用通信基本原理" class="headerlink" title="2.网络应用通信基本原理"></a>2.网络应用通信基本原理</h2>
      <p><strong>C/S 通信基本原理</strong></p>
<p> 服务端运行的是服务器进程，被动地等待客户请求服务。</p>
<p> 客户端运行的是客户进程，主动发起通信，请求服务器进程提供服务。</p>
<p> 应用进程间遵循<strong>应用层协议</strong>交换应用层报文</p>
<br>


        <h2 id="3-域名系统（DNS）">
          <a href="#3-域名系统（DNS）" class="heading-link"><i class="fas fa-link"></i></a><a href="#3-域名系统（DNS）" class="headerlink" title="3.域名系统（DNS）"></a>3.域名系统（DNS）</h2>
      <p><strong>（1）层次化域名空间</strong></p>
<p>层次树状结构的命名方法：</p>
<ol>
<li>国家顶级域名 nTLD</li>
<li>通用顶级域名 gTLD</li>
<li>接触结构域名</li>
</ol>
<p><strong>（2）域名服务器</strong></p>
<p><strong>域名解析：</strong>将域名映射为 IP 地址的过程</p>
<p><strong>域名服务器：</strong>为了实现域名解析，需要建立分布式数据库，存储网络中域名与 IP 地址的映射关系数据，这些数据库存储在域名服务器上，域名服务器根据用户的请求提供域名解析服务</p>
<p><strong>（3）域名服务器分类</strong></p>
<ul>
<li>根域名服务器</li>
<li>顶级域名服务器</li>
<li>权限域名服务器</li>
<li>本地域名服务器</li>
</ul>
<p><strong>（4）域名解析过程</strong></p>
<ul>
<li><p><strong>递归查询</strong></p>
<p>代替查询主机或者其他域名服务器，进行进一步的域名查询，并将最终解析结果发送给查询主机或服务器</p>
</li>
<li><p><strong>迭代查询</strong></p>
<p>只是将下一步要查询的服务器告知给主机或服务器</p>
</li>
</ul>
<br>


        <h2 id="4-万维网应用">
          <a href="#4-万维网应用" class="heading-link"><i class="fas fa-link"></i></a><a href="#4-万维网应用" class="headerlink" title="4.万维网应用"></a>4.万维网应用</h2>
      <p><strong>（1）应用结构</strong></p>
<p> Web 服务器、浏览器、超文本传输协议（HTTP）</p>
<p><strong>（2）HTTP</strong></p>
<ul>
<li>概念：超文本传输协议，定义浏览器如何向 Web 服务器发送请求以及 Web 服务器如何向浏览器进行响应</li>
<li>版本：HTTP/1.0 和 HTTP/1.1</li>
<li>连接：非持久连接，持久连接</li>
</ul>
<p> <strong>非持久连接：</strong></p>
<p> 两种方式：</p>
<p> 串行方式请求每个对象，且每次都要新建立 TCP 连接</p>
<p> 并行方式请求每个对象，每个请求建立一个 TCP 连接</p>
<p> <strong>持久连接：</strong>建立一个 TCP 连接，传输多个对象</p>
<p> 两种方式：</p>
<p> 非流水方式</p>
<p> 流水方式</p>
<ul>
<li><p>HTTP 报文：</p>
<p>请求报文——客户向服务器发送请求报文</p>
<figure class="highlight javascript"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">请求行	  [方法][ ][URL][ ][版本][CRLF]</span><br><span class="line">		[首部行字段名][:][ ][值][CRLF]</span><br><span class="line">		...</span><br><span class="line">        [首部行字段名][:][ ][值][CRLF]</span><br><span class="line">		[CRLF]</span><br><span class="line">		[实体主体]</span><br></pre></td></tr></table></div></figure>

<p>响应报文——从服务器到客户的回答</p>
<figure class="highlight javascript"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">状态行	  [版本][ ][状态码][ ][短语][CRLF]</span><br><span class="line">		[首部行字段名][:][ ][值][CRLF]</span><br><span class="line">		...</span><br><span class="line">		[首部行字段名][:][ ][值][CRLF]</span><br><span class="line">		[CRLF]</span><br><span class="line">		[实体主体]</span><br></pre></td></tr></table></div></figure>

<p>HTTP 状态码分类</p>
<div class="table-container"><table>
<thead>
<tr>
<th align="left">状态码</th>
<th>作用</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">1XX</td>
<td>信息提示</td>
<td>通告信息，可能还需要进一步交互</td>
</tr>
<tr>
<td align="left">2XX</td>
<td>成功</td>
<td>成功完成客户请求的操作，并进行响应</td>
</tr>
<tr>
<td align="left">3XX</td>
<td>重定向</td>
<td>表示资源已移走，需要向新 URL 发请求</td>
</tr>
<tr>
<td align="left">4XX</td>
<td>客户端错误</td>
<td>由于客户端请求错误，无法成功响应</td>
</tr>
<tr>
<td align="left">5XX</td>
<td>服务器端错误</td>
<td>由于服务器端错误，无法成功响应</td>
</tr>
</tbody></table></div>
</li>
</ul>
<p><strong>（3）Cookie</strong></p>
<p> 小型文本文件，指某些网站为了辨别用户身份、进行会话跟踪而存储在用户本地终端上的数据</p>
<p> 弥补了 HTTP 协议无状态性的不足，有利于进行用户跟踪并提供针对性的服务，但也会带来一些安全问题</p>
<br>


        <h2 id="5-电子邮件">
          <a href="#5-电子邮件" class="heading-link"><i class="fas fa-link"></i></a><a href="#5-电子邮件" class="headerlink" title="5.电子邮件"></a>5.电子邮件</h2>
      <p>电子邮件系统主要包括：</p>
<ul>
<li>邮件服务器</li>
<li>简单邮件传输协议（SMTP）</li>
<li>用户代理</li>
<li>邮件读取协议</li>
</ul>
<br>


        <h2 id="6-FTP">
          <a href="#6-FTP" class="heading-link"><i class="fas fa-link"></i></a><a href="#6-FTP" class="headerlink" title="6.FTP"></a>6.FTP</h2>
      <p>文件传送协议（FTP）：在互联网的两个主机间实现文件互传的应用层协议</p>
<p>C/S 模式，采用<strong>控制连接</strong>（21 端口）传输控制命令，<strong>数据连接</strong>（20 端口）传输文件内容</p>
<br>


        <h2 id="7-P2P-应用">
          <a href="#7-P2P-应用" class="heading-link"><i class="fas fa-link"></i></a><a href="#7-P2P-应用" class="headerlink" title="7.P2P 应用"></a>7.P2P 应用</h2>
      <p>优势：充分聚集利用了端系统（对等方主机）的计算能力以及网络传输宽带，对服务器的依赖很小</p>
<br>


        <h1 id="三-传输层">
          <a href="#三-传输层" class="heading-link"><i class="fas fa-link"></i></a><a href="#三-传输层" class="headerlink" title="三.传输层"></a>三.传输层</h1>
      
        <h2 id="1-传输层的基本服务">
          <a href="#1-传输层的基本服务" class="heading-link"><i class="fas fa-link"></i></a><a href="#1-传输层的基本服务" class="headerlink" title="1.传输层的基本服务"></a>1.传输层的基本服务</h2>
      <p>核心任务是为应用进程之间提供<strong>端到端</strong>的逻辑通信服务</p>
<ul>
<li><p><strong>功能：</strong></p>
<ul>
<li>传输层寻址</li>
<li>应用层报文的分段和重组</li>
<li>报文的差错检测</li>
<li>进程间的端到端可靠数据传输控制</li>
<li>面向应用层实现复用与分解</li>
<li>端到端的流量控制</li>
<li>拥塞控制</li>
</ul>
<p>传输层协议提供逻辑通信服务</p>
<p>传输层协议只需在<strong>端系统</strong>中实现</p>
<p>通信的真正端点并不是主机，而是主机中运行的<strong>应用进程</strong></p>
</li>
<li><p><strong>寻址与端口</strong></p>
<ul>
<li><p>用统一的寻址方式对应用进程进行标识——端口号</p>
</li>
<li><p>在全网范围内利用<strong>IP 地址+端口号</strong>唯一标识一个通信端点（应用进程）</p>
</li>
<li><p>传输层端口号为 16 位整数，包含三类端口：</p>
<ul>
<li>熟知端口号，数值 0~1023</li>
<li>登记端口号，数值 1023~49151，为没有熟知端口号的应用程序使用。使用这个范围的端口号必须在 IANA 登记，防止重复</li>
<li>客户端口号或短暂端口号，数值 49152~65535，留给用户进程选择短暂时使用</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>无连接服务与面向连接服务</strong></p>
<ul>
<li><p>无连接服务——数据传输之前无需与对端进行任何信息交换（握手），直接构造传输层报文段并向接收端发送</p>
<p>——<strong>UDP</strong></p>
</li>
<li><p>面向连接服务</p>
<p>在数据传输之前，需要双方交换一些控制信息，<strong>建立逻辑连接</strong>，然后再<strong>传输数据</strong>，数据传输结束后还需要再<strong>拆除连接</strong></p>
<p>——<strong>TCP</strong></p>
</li>
</ul>
</li>
</ul>
<br>


        <h2 id="2-传输层的复用与分解">
          <a href="#2-传输层的复用与分解" class="heading-link"><i class="fas fa-link"></i></a><a href="#2-传输层的复用与分解" class="headerlink" title="2.传输层的复用与分解"></a>2.传输层的复用与分解</h2>
      <p>是传输层的一项基本功能，支持众多应用进程共用同一个传输层协议，并且能够将接收到的数据准确交付给不同的应用进程。</p>
<ul>
<li><p>无连接的多路复用与多路分解</p>
<p>UDP 套接字：&lt;目的 IP 地址，目的端口号&gt;</p>
</li>
<li><p>面向连接的多路复用与多路分解</p>
<p>TCP 套接字（标识一条 TCP 连接）：&lt;源 IP 地址，源端口号，目的 IP 地址，目的端口号&gt;</p>
</li>
</ul>
<br>


        <h2 id="3-停-等协议与滑动窗口协议">
          <a href="#3-停-等协议与滑动窗口协议" class="heading-link"><i class="fas fa-link"></i></a><a href="#3-停-等协议与滑动窗口协议" class="headerlink" title="3.停-等协议与滑动窗口协议"></a>3.停-等协议与滑动窗口协议</h2>
      <p><strong>实现可靠数据传输的措施：</strong></p>
<ol>
<li><p>差错检测：利用差错编码实现数据包传输过程中的比特差错检测</p>
</li>
<li><p>确认：接收方向发送方反馈接收状态</p>
</li>
<li><p>重传：发送方重新发送接收方没有正确接收的数据</p>
</li>
<li><p>序号：确保数据按序提交</p>
</li>
<li><p>计时器：解决数据丢失问题</p>
</li>
</ol>
<p><strong>（1）停-等协议</strong></p>
<ul>
<li><p>特点：每发送一个报文后就停下来等接收方的确认</p>
</li>
<li><p>基本工作过程：</p>
<ol>
<li>发送并等待确认</li>
<li>接收并确认/否认</li>
<li>继续发送/重发</li>
</ol>
</li>
<li><p>问题：降低了信道利用率</p>
</li>
<li><p>解决方法：<strong>流水线协议</strong>或<strong>管道协议</strong>——允许发送方在没有收到确认前连续发送多个分组</p>
</li>
<li><p>流水线协议的改进：</p>
<p>增加分组序号范围</p>
<p>发送方和(或)接收方必须缓存多个分组</p>
</li>
<li><p>典型的流水线协议：滑动窗口协议</p>
</li>
</ul>
<p><strong>（2）滑动窗口协议</strong></p>
<p>两种最有代表性的滑动窗口协议：</p>
<ul>
<li>回退 N 步（GBN）协议</li>
<li>选择重传（SR）协议</li>
</ul>
<br>


        <h2 id="4-用户数据报协议（UDP）">
          <a href="#4-用户数据报协议（UDP）" class="heading-link"><i class="fas fa-link"></i></a><a href="#4-用户数据报协议（UDP）" class="headerlink" title="4.用户数据报协议（UDP）"></a>4.用户数据报协议（UDP）</h2>
      <p>用户数据报协议 UDP 提供无连接、不可靠、数据报尽力传输服务</p>
<p><strong>（1）数据结构：</strong></p>
<img src="/2022/02/21/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/UDP.jpg" class>

<p><strong>（2）计算校验和：</strong></p>
<ol>
<li>对所有参与运算的内容（包括 UDP 报文段）按 16 位 求和</li>
<li>求和过程中遇到的进位都被回卷（即进位与和的最低位再加）</li>
<li>最后得到的和取反码</li>
</ol>
<br>


        <h2 id="5-传输控制协议（TCP）">
          <a href="#5-传输控制协议（TCP）" class="heading-link"><i class="fas fa-link"></i></a><a href="#5-传输控制协议（TCP）" class="headerlink" title="5.传输控制协议（TCP）"></a>5.传输控制协议（TCP）</h2>
      <p><strong>（1）数据结构：</strong></p>
<img src="/2022/02/21/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/TCP.jpg" class>

<p><strong>（2）连接管理：</strong></p>
<ul>
<li>连接建立——<strong>三次握手</strong><ol>
<li>SYN 连接请求(客户端)</li>
<li>SYNACK 确认(服务端)</li>
<li>ACK 确认(客户端)</li>
</ol>
</li>
<li>断开连接——<strong>四次挥手</strong><ol>
<li>FIN 请求(客户端)</li>
<li>ACK 确认(服务端)</li>
<li>FINACK 确认(服务端)</li>
<li>ACK 确认(客户端)</li>
</ol>
</li>
</ul>
<p><strong>（3）可靠数据传输</strong></p>
<ol>
<li><p>TCP 的可靠数据传输实现机制包括<strong>差错编码、确认、序号、重传、计时器</strong>等</p>
</li>
<li><p>基于<strong>滑动窗口协议</strong>，但是发送窗口大小动态变化</p>
<p>总结：</p>
<ol>
<li>封装 TCP 报文段</li>
<li>发出一个报文段后启动一个计时器</li>
<li>通过校验和发现数据差错</li>
<li>通过序号重新排序，丢弃重复的报文段</li>
<li>流量控制</li>
</ol>
</li>
</ol>
<p><strong>（4）流量控制</strong></p>
<ol>
<li><p>TCP 协议利用窗口机制实现流量控制，但不是简单的滑动窗口协议</p>
</li>
<li><p>TCP 连接建立时，双方都为之分配固定大小的缓冲空间；TCP 的接收端只允许另一端发送其缓冲区所能接纳的数据</p>
<ol>
<li><p>接收端在给发送端发送确认段时，通告接收窗口大小</p>
</li>
<li><p>发送端在接下来发送数据段时，确保未确认段的应用层数据总量不超过接收端通告的接收窗口大小，从而确保接收端不会发生缓存溢出</p>
</li>
</ol>
</li>
</ol>
<p><strong>（5）拥塞控制</strong></p>
<ol>
<li><p>窗口机制</p>
<p>通过调节窗口的大小实现对发送数据速率的调整</p>
</li>
<li><p>窗口调整的基本策略</p>
<p><strong>AIMD（加性增加，乘性减小）</strong></p>
<p>网络未发生拥塞时，逐渐“加性”增大窗口大小，当网络拥塞时“乘性”快速减少窗口大小</p>
</li>
<li><p>TCP 的拥塞控制算法</p>
<p>包括了慢启动、拥塞避免、快速重传和快速恢复 4 部分</p>
</li>
</ol>
<br>


        <h1 id="四-网络层">
          <a href="#四-网络层" class="heading-link"><i class="fas fa-link"></i></a><a href="#四-网络层" class="headerlink" title="四.网络层"></a>四.网络层</h1>
      
        <h2 id="1-网络层服务">
          <a href="#1-网络层服务" class="heading-link"><i class="fas fa-link"></i></a><a href="#1-网络层服务" class="headerlink" title="1.网络层服务"></a>1.网络层服务</h2>
      <p>主要作用是将网络层数据报从<strong>源主机</strong>送达<strong>目的主机</strong></p>
<p>主要功能包括：</p>
<ol>
<li>转发：分组从输入接口转移到输出接口</li>
<li>路由选择：决定分组经过的路由或路径</li>
</ol>
<br>


        <h2 id="2-数据报网络与虚电路网络">
          <a href="#2-数据报网络与虚电路网络" class="heading-link"><i class="fas fa-link"></i></a><a href="#2-数据报网络与虚电路网络" class="headerlink" title="2.数据报网络与虚电路网络"></a>2.数据报网络与虚电路网络</h2>
      <ul>
<li><p>数据报网络：按照目的主机地址进行路由选择的网络</p>
<p>特点：</p>
<ol>
<li>无连接</li>
<li>每个分组作为独立的数据报进行传送，路径也可能不同</li>
<li>分组可能出现乱序和丢失</li>
</ol>
</li>
<li><p>虚电路网络：在网络层提供面向连接的分组交换服务</p>
<p>特点：</p>
<ol>
<li>建立一条网络层逻辑连接</li>
<li>不需要为每条虚电路分配独享资源（区别于电路交换）</li>
<li>根据虚电路号沿虚电路路径按序发送分组</li>
</ol>
</li>
</ul>
<br>


        <h2 id="3-网络互连与网络互连设备">
          <a href="#3-网络互连与网络互连设备" class="heading-link"><i class="fas fa-link"></i></a><a href="#3-网络互连与网络互连设备" class="headerlink" title="3.网络互连与网络互连设备"></a>3.网络互连与网络互连设备</h2>
      <p><strong>（1）异构网络互连</strong></p>
<p>异构网络：两个网络的通信技术和运行的协议不同</p>
<p>异构网络互连的基本策略：</p>
<ol>
<li>协议转换</li>
<li>构建虚拟互联网络</li>
</ol>
<p><strong>（2）路由器</strong></p>
<ul>
<li><p>输入端口</p>
<p>接收-&gt;物理层处理-&gt;数据链路层处理-&gt;网络层处理、分组排队、查表和转发-&gt;交换结构</p>
</li>
<li><p>输出端口</p>
<p>交换结构-&gt;网络层处理、分组排队、缓存管理-&gt;数据链路层处理-&gt;物理层处理-&gt;输出</p>
</li>
<li><p>交换结构</p>
<ol>
<li>基于内存交换</li>
<li>基于总线交换</li>
<li>基于网络交换</li>
</ol>
</li>
</ul>
<br>


        <h2 id="4-网络层拥塞控制">
          <a href="#4-网络层拥塞控制" class="heading-link"><i class="fas fa-link"></i></a><a href="#4-网络层拥塞控制" class="headerlink" title="4.网络层拥塞控制"></a>4.网络层拥塞控制</h2>
      <ul>
<li><p>拥塞：一种持续过载的网络状态，此时用户对网络资源（包括链路带宽、存储空间和处理器处理能力等）的总需求超过了网络固有的容量</p>
</li>
<li><p>原因：</p>
</li>
</ul>
<ol>
<li>缓冲区容量有限</li>
<li>传输线路的带宽有限</li>
<li>网络结点的处理能力有限</li>
<li>网络中某些部分发生了故障</li>
</ol>
<ul>
<li><p>解决方式：</p>
<ul>
<li><p>流量感知路由</p>
<p>根据网络负载动态调整，将网络流量引导到不同的链路上，均衡网络负载，从而延缓或避免拥塞发生</p>
<p>解决网络负载的震荡现象：</p>
<ol>
<li><p>多路径路由</p>
</li>
<li><p>缓慢转移流量至另一链路</p>
</li>
</ol>
</li>
<li><p>准入控制</p>
<p>是一种广泛应用于虚电路网络的拥塞预防技术</p>
</li>
<li><p>流量调节</p>
<ol>
<li>感知拥塞</li>
<li>处理拥塞：将拥塞信息通知到其上游结点</li>
</ol>
<p>处理方法：</p>
<ol>
<li>抑制分组：给拥塞数据报<strong>源主机</strong>返回一个抑制分组</li>
<li>背压：让抑制分组再从拥塞结点到源结点的路径上的<strong>每一跳</strong>，都发挥抑制作用</li>
</ol>
</li>
<li><p>负载脱落</p>
<p>路由器主动丢弃某些数据报</p>
<ol>
<li>丢弃新分组：如 GBN</li>
<li>丢弃新分组：如实时视频流</li>
</ol>
</li>
</ul>
</li>
</ul>
<br>


        <h2 id="5-Internet-网络层">
          <a href="#5-Internet-网络层" class="heading-link"><i class="fas fa-link"></i></a><a href="#5-Internet-网络层" class="headerlink" title="5.Internet 网络层"></a>5.Internet 网络层</h2>
      <ul>
<li><p>IPv4 协议</p>
<ul>
<li><p>IP 数据报格式：首部固定部分 20 字节</p>
<img src="/2022/02/21/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/IPv4.jpg" class></li>
<li><p>IP 数据报分片</p>
</li>
</ul>
<p><strong>标识</strong>：判断这些分片是否属于同一个 IP 数据报</p>
<p><strong>标志</strong>：判读那是否为最后一个分片</p>
<p><strong>片偏移</strong>：判断各分片的先后顺序</p>
<ul>
<li><p>IPv4 地址长度：<strong>32 位二进制</strong></p>
<p>点分十进制标价法：11000000 10101000 00000001 01100101 -&gt; 192.168.1.101</p>
</li>
<li><p>地址分类：A、B、C、D、E 五类</p>
<img src="/2022/02/21/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/IPv4%E7%BC%96%E5%9D%80.jpg" class>

<p><strong>同一个网络中所有主机要有同一个网络号</strong></p>
</li>
<li><p>子网划分</p>
</li>
<li><p>路由聚合：将相同路由的连续子网合并</p>
</li>
</ul>
</li>
</ul>
<br>


        <h2 id="6-路由算法与路由协议">
          <a href="#6-路由算法与路由协议" class="heading-link"><i class="fas fa-link"></i></a><a href="#6-路由算法与路由协议" class="headerlink" title="6.路由算法与路由协议"></a>6.路由算法与路由协议</h2>
      <ul>
<li><p>路由算法</p>
<ul>
<li><p>链路状态路由选择算法</p>
<p>一种<strong>全局式</strong>路由选择算法。每个路由器通过从其他路由器获得的链路状态信息构造出整个网络拓扑图</p>
</li>
<li><p>距离向量路由选择算法</p>
<p>每个结点基于其与邻居结点间的直接链路距离，以及邻居交换过来的距离向量，计算并更新其到达每个目的结点的最短距离，然后将新的距离向量再通告给其所有邻居，知道距离向量不再改变</p>
</li>
<li><p><strong>层次化路由选择</strong></p>
<p>实现大规模网络路由选择最有效的、可行的解决方案</p>
<p>划分自治系统：</p>
<ul>
<li>网关路由器</li>
<li>自治系统间路由协议</li>
</ul>
</li>
</ul>
</li>
<li><p>路由协议</p>
<ul>
<li>内部网关协议：RIP、OSPF</li>
<li>外部网关协议：BGP</li>
</ul>
</li>
</ul>
<br>


        <h1 id="五-数据链路层与局域网">
          <a href="#五-数据链路层与局域网" class="heading-link"><i class="fas fa-link"></i></a><a href="#五-数据链路层与局域网" class="headerlink" title="五.数据链路层与局域网"></a>五.数据链路层与局域网</h1>
      
        <h2 id="1-数据链路层服务">
          <a href="#1-数据链路层服务" class="heading-link"><i class="fas fa-link"></i></a><a href="#1-数据链路层服务" class="headerlink" title="1.数据链路层服务"></a>1.数据链路层服务</h2>
      <p>链路：通信链路连接的<strong>相邻结点</strong>的通信信道</p>
<p>链路层数据单元：帧</p>
<p>主要功能包括：</p>
<ul>
<li>组帧</li>
<li>链路接入：点对点链路、广播链路</li>
<li>可靠交付（可靠传输方法多用于高出错率链路）</li>
<li>差错控制</li>
</ul>
<br>


        <h2 id="2-差错控制">
          <a href="#2-差错控制" class="heading-link"><i class="fas fa-link"></i></a><a href="#2-差错控制" class="headerlink" title="2.差错控制"></a>2.差错控制</h2>
      <ul>
<li><p>基本方式：</p>
<ol>
<li>检错重发</li>
<li>前向纠错：接收端进行差错纠正</li>
<li>反馈校验：接收端将收到的数据原封不动发回发送方</li>
<li>检错丢弃</li>
</ol>
</li>
<li><p>差错编码的基本原理</p>
<p>香农信道编码定理：理论上可以通过编码使得数据传输过程不发生错误，或者将错误概率控制在很小的数值之下</p>
</li>
<li><p>差错编码的检错与纠错能力</p>
<p>汉明距离：两个等长码字之间，对应位不同的位数</p>
<p>编码集的汉明距离：该编码集中任意两个码字之间汉明距离的<strong>最小值</strong></p>
<ul>
<li>检错编码：如果编码集的汉明距离 d=r+1，则该差错编码可以检测 r 位的差错</li>
<li>纠错编码：如果编码集的汉明距离 d=2r+1，则该差错编码可以纠正 r 位的差错</li>
</ul>
</li>
<li><p>典型的差错编码</p>
<ul>
<li>奇偶校验码</li>
<li>汉明码</li>
<li>循环冗余码</li>
</ul>
</li>
</ul>
<br>


        <h2 id="3-多路访问控制协议">
          <a href="#3-多路访问控制协议" class="heading-link"><i class="fas fa-link"></i></a><a href="#3-多路访问控制协议" class="headerlink" title="3.多路访问控制协议"></a>3.多路访问控制协议</h2>
      <ul>
<li><p>信道划分 MAC 协议</p>
<p>多路访问控制 MAC：广播信道上用于协调各个结点的数据发送</p>
<p>信道划分 MAC 协议：</p>
<ol>
<li>频分多路复用</li>
<li>时分多路复用</li>
<li>波分多路复用</li>
<li>码分多路复用</li>
</ol>
</li>
<li><p>随机访问 MAC 协议</p>
<ol>
<li><p>ALOHA 协议</p>
<p>纯 ALOHA：直接发送-&gt;信道监听-&gt;冲突重发</p>
<p>时隙 ALOHA：时隙开始时发送-&gt;信道侦听-&gt;冲突则下一时隙以概率 P 重发</p>
</li>
<li><p>载波监听多路访问协议 CSMA</p>
<p>发送前监听信道是否空闲</p>
<p>（1）非坚持 CSMA：忙则等待随机时间后再侦听</p>
<p>（2）1-坚持 CSMA：忙则持续监听</p>
<p>（3）P-坚持 CSMA：闲则概率 P 在最近时隙发送</p>
</li>
<li><p>带冲突检测的载波监听多路访问协议 CSMA/CD</p>
<p>监听空闲后发送，<strong>发送时检测碰撞</strong>，碰撞后等待重发</p>
</li>
</ol>
</li>
<li><p>受控接入 MAC 协议</p>
<ol>
<li><p>集中式控制</p>
<p>由一个主机负责调度其他通信站接入信道，从而避免冲突</p>
<p>主要方法：轮询技术，又分为轮叫轮询和传递轮询</p>
</li>
<li><p>分散式控制</p>
<p>典型方法：令牌技术，如令牌环网</p>
</li>
</ol>
</li>
</ul>
<br>


        <h2 id="4-局域网">
          <a href="#4-局域网" class="heading-link"><i class="fas fa-link"></i></a><a href="#4-局域网" class="headerlink" title="4.局域网"></a>4.局域网</h2>
      <ul>
<li><p>数据链路层寻址与 ARP</p>
<ul>
<li><p>MAC 地址</p>
<p>每个接口对应一个 MAC 地址，且全球唯一</p>
<p>长度 48 位</p>
</li>
<li><p>地址解析协议</p>
<p>根据本网内目的主机或默认网关的 IP 地址获取其 MAC 地址</p>
</li>
</ul>
</li>
<li><p>以太网</p>
<ul>
<li>IEEE802.3 标准</li>
<li>采用 CSMA/CD 访问控制方法</li>
<li>以太网技术<ul>
<li>10Base-5，10Base-T</li>
<li>快速以太网 100Base-TX，100Base-T4,100Base-FX</li>
<li>千兆以太网</li>
<li>万兆以太网</li>
</ul>
</li>
</ul>
</li>
<li><p>交换机</p>
<ul>
<li><p>转发与过滤</p>
<p>可以依靠接收到的链路层帧的目的 MAC 地址，选择性地转发到相应的端口</p>
<p>以目标 MAC 地址为主键，查找交换表</p>
</li>
<li><p>自学习</p>
<p>交换机通过自学习构建交换表</p>
</li>
<li><p>优点</p>
<ol>
<li>消除冲突，提高性能</li>
<li>支持异质链路</li>
<li>易于进行网络管理</li>
</ol>
</li>
</ul>
</li>
<li><p>虚拟局域网（VLAN）</p>
<ol>
<li>一种基于交换机的逻辑分割广播域的局域网应用形式</li>
<li>不受物理位置的限制，以软件的方式划分和管理局域网中的工作组</li>
<li>能够抑制广播风暴</li>
<li>划分方法：<ul>
<li>基于交换机端口</li>
<li>基于 MAC 地址</li>
<li>基于上层协议类型或地址</li>
</ul>
</li>
</ol>
</li>
</ul>
<br>


        <h2 id="5-点对点链路协议">
          <a href="#5-点对点链路协议" class="heading-link"><i class="fas fa-link"></i></a><a href="#5-点对点链路协议" class="headerlink" title="5.点对点链路协议"></a>5.点对点链路协议</h2>
      <ul>
<li><p>点对点协议——PPP</p>
<p>能够处理差错检测、支持多种上层协议、允许连接时协商 IP 地址、允许身份认证</p>
<p>典型应用：拨号上网</p>
<p>功能：</p>
<ol>
<li>成帧</li>
<li>链路控制协议 LCP</li>
<li>网络控制协议 NCP</li>
</ol>
</li>
<li><p>HDLC 协议</p>
<p>高级数据链路控制——HDLC 协议：</p>
<p>可应用于点对点链路和点对多点链路</p>
<p>帧定界：帧的定界符是 01111110</p>
<p>位填充：</p>
<p> 发送端：只要发现数据字段 5 个连续的 1，就立刻插入一个 0，保证数据字段不会出现连续的 6 个 1</p>
<p> 接收端：发现数据流中 5 个连续的 1，就删除其后的 0，还原成原来的信息</p>
</li>
</ul>
<br>


        <h1 id="六-物理层">
          <a href="#六-物理层" class="heading-link"><i class="fas fa-link"></i></a><a href="#六-物理层" class="headerlink" title="六.物理层"></a>六.物理层</h1>
      
        <h2 id="1-数据通信基础">
          <a href="#1-数据通信基础" class="heading-link"><i class="fas fa-link"></i></a><a href="#1-数据通信基础" class="headerlink" title="1.数据通信基础"></a>1.数据通信基础</h2>
      <ul>
<li><p>基本概念</p>
<ol>
<li>消息：人类能够感知的描述</li>
<li>信息：信息是对事物状态或存在方式的不确定性表述，<strong>信息是可以度量的</strong></li>
<li>通信：本质就是在一点精确或近似地再生另一点的信息</li>
<li>通信系统：能够实现通信功能的各种技术、设备和方法的总体</li>
<li>信号：通信系统中，在传输通道中传播的信息的载体</li>
<li>数据：对客观事物的性质状态以及相互关系等进行记载的<strong>符号</strong>及其组合</li>
<li>信道：信道是以传输介质为基础的信号通道</li>
</ol>
</li>
<li><p>数据通信系统模型</p>
<ol>
<li><p>构成</p>
<p>信源、发送设备、信道、接收设备、新宿和噪声源等部分</p>
</li>
<li><p>模拟通信</p>
<p>模拟信号：信号的因变量是连续的</p>
</li>
<li><p>数字通信</p>
<p>数字信号：因变量是离散的</p>
</li>
<li><p>数据通信方式</p>
<ol>
<li>单向通信、双向交替通信和双向同时通信</li>
<li>并行通信和串行通信</li>
<li>异步通信和同步通信</li>
</ol>
</li>
<li><p>通信系统的功能</p>
<ol>
<li>信道利用</li>
<li>接口及信号产生</li>
<li>同步</li>
<li>差错检测与纠正</li>
<li>寻址与路由</li>
<li>网络管理</li>
<li>安全保证</li>
</ol>
</li>
</ol>
</li>
</ul>
<br>


        <h2 id="2-物理介质">
          <a href="#2-物理介质" class="heading-link"><i class="fas fa-link"></i></a><a href="#2-物理介质" class="headerlink" title="2.物理介质"></a>2.物理介质</h2>
      <ul>
<li>导引型传输介质<ol>
<li>架空明线</li>
<li>双绞线</li>
<li>同轴电缆</li>
<li>光纤</li>
</ol>
</li>
<li>非导引型传输介质<ol>
<li>地波传播</li>
<li>天波传播</li>
<li>视线传播</li>
</ol>
</li>
</ul>
<br>
</div></div></article><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/2022/02/20/%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87%E3%80%81%E4%BD%9C%E7%94%A8%E5%9F%9F%E3%80%81%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%93%BE%E5%92%8C%E9%97%AD%E5%8C%85/">执行上下文、作用域、作用域链和闭包</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">发表于</span><span class="post-meta-item__value">2022-02-20</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__info">更新于</span><span class="post-meta-item__value">2022-03-03</span></span></div></header><div class="post-body"><div class="post-excerpt"><p>执行上下文、作用域、作用域链、闭包这四个概念联系非常紧密，所以放到同一篇博客中记录。现在网上的很多文章和视频都很难把这几个概念讲清楚，我看了之后，结合自己的理解记录这篇博客。如有错误，欢迎指正。</p>
<br>


        <h1 id="一-执行上下文">
          <a href="#一-执行上下文" class="heading-link"><i class="fas fa-link"></i></a><a href="#一-执行上下文" class="headerlink" title="一.执行上下文"></a>一.执行上下文</h1>
      
        <h2 id="1-概念">
          <a href="#1-概念" class="heading-link"><i class="fas fa-link"></i></a><a href="#1-概念" class="headerlink" title="1.概念"></a>1.概念</h2>
      <p>执行上下文（execution context）：当前 JavaScript 代码<strong>被解析</strong>和<strong>执行</strong>时存在的环境。它是为了方便理解提出来的一种抽象概念，并非真实存在。</p>
<br>


        <h2 id="2-类型">
          <a href="#2-类型" class="heading-link"><i class="fas fa-link"></i></a><a href="#2-类型" class="headerlink" title="2.类型"></a>2.类型</h2>
      <p>在 ES6 版本下，有四种情况会创建执行上下文：</p>
<ul>
<li>进入全局代码（全局执行上下文）</li>
<li>进入 function 函数体代码（函数执行上下文）</li>
<li>进入 eval 函数参数指定的代码（eval 执行上下文）</li>
<li>进入 module 代码（module 执行上下文）</li>
</ul>
<p>我们重点关注前两种执行上下文：<code>全局执行上下文</code>和<code>函数执行上下文</code></p>
<br>


        <h2 id="3-执行上下文栈">
          <a href="#3-执行上下文栈" class="heading-link"><i class="fas fa-link"></i></a><a href="#3-执行上下文栈" class="headerlink" title="3.执行上下文栈"></a>3.执行上下文栈</h2>
      <p>全局执行上下文只会存在一个，而函数执行上下文可以存在无数个。<code>每当函数被调用，就会创建一个新的函数执行上下文</code>。即使是同一个函数被多次调用，也会创建多个执行上下文。</p>
<p>那么该如何管理这些上下文呢？这就有了<code>执行上下文栈</code>的概念，也叫<code>执行栈</code>或<code>调用栈</code>（如果了解 js 的事件循环机制，那对于调用栈并不陌生，我个人理解调用栈和执行上下文栈本质是同一个东西，只不过在事件循环机制中，我们更关注于代码的执行，也就是下文将提到的创建执行上下文的执行阶段）。</p>
<p>执行栈具有<code>LIFO</code>（Last In First Out）的特点。当 JS 代码首次运行，都会创建一个<strong>全局执行上下文</strong>压入执行栈，之后每当有函数被调用，都将创建一个新的<strong>函数执行上下文</strong>压入栈中，当最顶层函数执行完毕，一步步出栈。</p>
<figure class="highlight javascript"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  f2();</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f2</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  f3();</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f3</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">3</span>);</span><br><span class="line">&#125;</span><br><span class="line">f1(); <span class="comment">//3 2 1</span></span><br></pre></td></tr></table></div></figure>

<p>那么执行上下文究竟做了哪些事情呢？接下来我们重点讲一下。</p>
<br>


        <h2 id="4-执行上下文的生命周期">
          <a href="#4-执行上下文的生命周期" class="heading-link"><i class="fas fa-link"></i></a><a href="#4-执行上下文的生命周期" class="headerlink" title="4.执行上下文的生命周期"></a>4.执行上下文的生命周期</h2>
      <p>执行上下文的生命周期分为三个阶段：<strong>创建阶段</strong>、<strong>执行阶段</strong>、<strong>销毁阶段</strong>。</p>
<p>由于标准的不断更新，对于执行上下文的内容也有了很大出入，首先将以 ES3 标准介绍执行上下文，比较容易理解，之后再讲解 ES5 标准。</p>
<br>


        <h3 id="1-创建阶段">
          <a href="#1-创建阶段" class="heading-link"><i class="fas fa-link"></i></a><a href="#1-创建阶段" class="headerlink" title="(1) 创建阶段"></a>(1) 创建阶段</h3>
      <p>执行上下文的创建阶段被称为<code>预处理</code>或<code>预编译</code>，指在代码<strong>运行前</strong>js 引擎所作的处理，ES3 标准中执行上下文的创建阶段主要有三个部分：</p>
<ul>
<li>创建变量对象/活动对象</li>
<li>创建作用域链</li>
<li>this 绑定</li>
</ul>

        <h4 id="1）创建变量对象-活动对象">
          <a href="#1）创建变量对象-活动对象" class="heading-link"><i class="fas fa-link"></i></a><a href="#1）创建变量对象-活动对象" class="headerlink" title="1）创建变量对象/活动对象"></a>1）创建变量对象/活动对象</h4>
      <p>每个执行上下文都有一个表示变量的对象——<code>变量对象(variable object，简称VO)</code>，刚刚说了，执行上下文又分为全局执行上下文和函数执行上下文，它们的变量对象是有区别的。</p>
<p>全局执行上下文的变量对象叫做<code>全局对象(global object，简称GO)</code>，在浏览器环境 JS 引擎会整合<code>&lt;script&gt;</code>标签中的内容，产生<code>window对象</code>，这个 window 对象就是全局对象。在<code>&lt;script&gt;</code>标签中声明的变量称为<code>全局变量</code>，<strong>全局变量会作为 window 对象的属性存在</strong>。</p>
<figure class="highlight html"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">  <span class="keyword">var</span> a = <span class="number">100</span>;</span></span><br><span class="line"><span class="javascript">  <span class="built_in">console</span>.log(a); <span class="comment">// 100</span></span></span><br><span class="line"><span class="javascript">  <span class="built_in">console</span>.log(<span class="built_in">window</span>.a); <span class="comment">// 100</span></span></span><br><span class="line"><span class="javascript">  <span class="built_in">console</span>.log(<span class="built_in">window</span>);</span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">  <span class="built_in">console</span>.log(a); <span class="comment">// 100</span></span></span><br><span class="line"><span class="javascript">  <span class="built_in">console</span>.log(<span class="built_in">window</span>.a); <span class="comment">// 100</span></span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></div></figure>

<p>在<code>&lt;script&gt;</code>标签中的声明的函数为<code>全局函数</code>，<strong>全局函数会作为 window 对象的方法存在</strong>。</p>
<figure class="highlight html"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">  <span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(<span class="number">1</span>);</span></span><br><span class="line"><span class="javascript">  &#125;</span></span><br><span class="line"><span class="javascript">  <span class="built_in">console</span>.log(<span class="built_in">window</span>);</span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></div></figure>

<p>当函数<strong>被调用</strong>时，会创建函数执行上下文，函数执行上下文的变量对象叫做<code>活动对象(activation object，简称AO)</code>。在函数内部声明的变量称为<code>局部变量</code>，<strong>局部变量会作为 AO 的属性存在</strong>。在函数内部声明的函数叫<code>局部函数</code>，<strong>局部函数会作为 AO 的方法存在</strong>。</p>
<figure class="highlight javascript"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通过控制台断点查看</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> i = <span class="number">0</span>;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">b</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  b();</span><br><span class="line">&#125;</span><br><span class="line">a();</span><br></pre></td></tr></table></div></figure>

<blockquote>
<p>其实，变量对象、全局对象、活动对象是一个东西，只不过是不同状态和阶段而已。全局执行上下文中的变量对象叫全局对象，函数执行上下文中的变量对象叫活动对象。</p>
<p>另外，下文中的<code>GO对象</code>就是<code>GO</code>，<code>AO对象</code>就是<code>AO</code>，只是我个人习惯在后面加一个对象，不妨碍阅读。</p>
</blockquote>
<p>接下来，我们来看一段经典的代码：</p>
<figure class="highlight javascript"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(a); <span class="comment">// undefined</span></span><br><span class="line"><span class="keyword">var</span> a;</span><br></pre></td></tr></table></div></figure>

<p>为什么输出打印的结果是 undefined，接下去我们就来详细讲讲。</p>
<p>首先，在全局执行上下文的创建阶段中（严格来讲，是创建阶段的变量对象部分），JS 引擎会做这些事情：</p>
<ol>
<li>生成 window 对象，也就是 GO 对象</li>
<li>查找（全局）变量声明，作为 GO 对象的属性名，值为 undefined</li>
<li>查找（全局）函数声明，作为 GO 对象的方法名，值为 function</li>
</ol>
<p>变量声明：通过<code>var</code>关键字声明变量</p>
<figure class="highlight javascript"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a; <span class="comment">// 变量声明</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="number">100</span>; <span class="comment">// 变量声明+变量赋值</span></span><br></pre></td></tr></table></div></figure>

<p>函数声明：通过<code>function</code>关键字声明函数</p>
<figure class="highlight javascript"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params"></span>) </span>&#123;&#125; <span class="comment">// 函数声明</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;; <span class="comment">// 注意：这种情况并不是函数声明，而是函数表达式。相当于变量声明，只不过这个变量在执行代码时被赋予一个函数</span></span><br></pre></td></tr></table></div></figure>

<p><strong>注意：</strong></p>
<ol>
<li>当查找函数声明并初始化时，创建了一个与之对应的函数对象，并被它引用</li>
<li>如果变量和函数同名，函数声明会覆盖掉变量声明，也就是说结果为 function</li>
</ol>
<blockquote>
<p>对于注意点 2，有些人的说法是 var 的优先级高，因为 JS 引擎会优先找 var 声明，另一些人的说法是 function 优先级高，因为如果出现同名，JS 引擎会选择 function。其实这两种说法只是理解角度不同而已，最终结果都是 function。下方的示例 2 就是演示这一点。</p>
</blockquote>
<p>示例 1：</p>
<figure class="highlight javascript"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">100</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">b</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	1.产生window对象</span></span><br><span class="line"><span class="comment">	2.查找变量声明：a，作为GO的属性名，初始化为undefined</span></span><br><span class="line"><span class="comment">	3.查找函数声明：b，作为GO的方法名，初始化为function(实际上是创建了一个函数对象，并让b引用)</span></span><br><span class="line"><span class="comment">	GO：&#123;</span></span><br><span class="line"><span class="comment">		a:undefined,</span></span><br><span class="line"><span class="comment">		b:function</span></span><br><span class="line"><span class="comment">	&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></div></figure>

<p>用图像来表示：</p>
<img src="/2022/02/20/%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87%E3%80%81%E4%BD%9C%E7%94%A8%E5%9F%9F%E3%80%81%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%93%BE%E5%92%8C%E9%97%AD%E5%8C%85/%E5%85%A8%E5%B1%80%E9%A2%84%E7%BC%96%E8%AF%91.png" class>

<blockquote>
<p>黄色虚线表示逻辑关系，红色实线表示真实的内存地址引用，下文同</p>
</blockquote>
<p>实例 2：</p>
<figure class="highlight javascript"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(a); <span class="comment">// function</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>到此为止，全局执行上下文的创建阶段结束。</p>
<blockquote>
<p>严格来讲，是全局执行上下文创建阶段中的变量对象部分结束，但是在这一章节的学习中，我们会发现创建阶段的变量对象这一部分对我们理解来说是最重要的，所以这一章节中，变量对象初始化完毕后，我们就认为创建阶段结束，作用域链和 this 绑定我们暂不讨论。</p>
</blockquote>
<p>接着讲解下函数执行上下文的创建阶段（严格来讲，是创建阶段的变量对象部分），JS 引擎会做这些事情：</p>
<ol>
<li>在函数<strong>被调用</strong>时，为当前函数产生 AO 对象</li>
<li>查找（局部）变量声明和形参，作为 AO 对象的属性名，值为 undefined</li>
<li>使用实参的值改变形参的值</li>
<li>查找（局部）函数声明，作为 AO 对象的方法名，值为 function</li>
</ol>
<p>示例：</p>
<figure class="highlight javascript"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> i = <span class="number">0</span>;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">b</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  b();</span><br><span class="line">&#125;</span><br><span class="line">a(<span class="number">1</span>);</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	创建全局执行上下文，并压入栈</span></span><br><span class="line"><span class="comment">	1.产生window对象</span></span><br><span class="line"><span class="comment">	2.查找变量声明：无</span></span><br><span class="line"><span class="comment">	3.查找函数声明:a，作为GO的方法名，初始化为function</span></span><br><span class="line"><span class="comment">	GO：&#123;</span></span><br><span class="line"><span class="comment">		a:function</span></span><br><span class="line"><span class="comment">	&#125;</span></span><br><span class="line"><span class="comment">	到此为止全局执行上下文的创建阶段结束</span></span><br><span class="line"><span class="comment">	</span></span><br><span class="line"><span class="comment">	开始执行代码(这部分是执行上下文的执行阶段，但由于函数执行上下文只有在被调用时才会创建，所以需要执行，我们将在下文再接着讲执行阶段)</span></span><br><span class="line"><span class="comment">	运行到a(1)</span></span><br><span class="line"><span class="comment">	</span></span><br><span class="line"><span class="comment">	创建函数执行上下文，并压入栈</span></span><br><span class="line"><span class="comment">	1.产生函数AO对象</span></span><br><span class="line"><span class="comment">	2.查找函数内变量声明和形参：x、i，作为AO的属性名，初始化为undefined</span></span><br><span class="line"><span class="comment">	3.将实参1赋值给形参x，x:1</span></span><br><span class="line"><span class="comment">	4.查找函数内函数声明：b，作为AO的方法名，初始化为function</span></span><br><span class="line"><span class="comment">	AO:&#123;</span></span><br><span class="line"><span class="comment">		x:1,</span></span><br><span class="line"><span class="comment">		i:undefined,</span></span><br><span class="line"><span class="comment">		b:function</span></span><br><span class="line"><span class="comment">	&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></div></figure>

<p>同样用图像来表示：</p>
<img src="/2022/02/20/%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87%E3%80%81%E4%BD%9C%E7%94%A8%E5%9F%9F%E3%80%81%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%93%BE%E5%92%8C%E9%97%AD%E5%8C%85/%E5%87%BD%E6%95%B0%E9%A2%84%E7%BC%96%E8%AF%91.png" class>

<p>通过浏览器的调试工具查看：</p>
<img src="/2022/02/20/%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87%E3%80%81%E4%BD%9C%E7%94%A8%E5%9F%9F%E3%80%81%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%93%BE%E5%92%8C%E9%97%AD%E5%8C%85/%E5%87%BD%E6%95%B0%E9%A2%84%E7%BC%96%E8%AF%91-%E8%B0%83%E8%AF%95%E5%B7%A5%E5%85%B7.png" class>

<p>到此为止，函数执行上下文的创建阶段结束。</p>
<p>了解完这部分后，我们会发现之前所谓的<code>变量提升</code>和<code>函数提升</code>就是指查找变量声明和函数声明。</p>
<hr>

        <h4 id="2）创建作用域链">
          <a href="#2）创建作用域链" class="heading-link"><i class="fas fa-link"></i></a><a href="#2）创建作用域链" class="headerlink" title="2）创建作用域链"></a>2）创建作用域链</h4>
      <p>作用域和作用域链我将在下一章节重点讲，这里就先略过。</p>
<hr>

        <h4 id="3）绑定-this">
          <a href="#3）绑定-this" class="heading-link"><i class="fas fa-link"></i></a><a href="#3）绑定-this" class="headerlink" title="3）绑定 this"></a>3）绑定 this</h4>
      <p>如果是全局执行上下文，this 其实就是全局对象，即 window 对象，如果是函数执行上下文，那就要确认<code>当前可执行代码块的调用者</code>， 并将调用者信息<code>this value</code>存入当前执行上下文，否则默认为全局对象调用。有关 this 的问题，可另行查看，本文不过多介绍，并且不再提及。</p>
<hr>
<p>综上，在执行上下文的创建阶段，变量对象是最主要的内容。</p>
<br>


        <h3 id="2-执行阶段">
          <a href="#2-执行阶段" class="heading-link"><i class="fas fa-link"></i></a><a href="#2-执行阶段" class="headerlink" title="(2) 执行阶段"></a>(2) 执行阶段</h3>
      <p>所谓执行阶段，反而比创建阶段更好理解，就是运行 JS 代码。</p>
<p>在执行阶段中，JS 代码会被<strong>逐条执行</strong>，如果有赋值语句，就对应地去赋值……</p>
<p>示例：</p>
<figure class="highlight javascript"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(i); <span class="comment">// undefined</span></span><br><span class="line">  <span class="keyword">var</span> i = <span class="number">0</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(i); <span class="comment">// 0</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">b</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  b();</span><br><span class="line">&#125;</span><br><span class="line">a(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	创建全局执行上下文，并压入栈</span></span><br><span class="line"><span class="comment">	1.产生window对象</span></span><br><span class="line"><span class="comment">	2.查找变量声明：无</span></span><br><span class="line"><span class="comment">	3.查找函数声明：a，初始化为function</span></span><br><span class="line"><span class="comment">	GO:&#123;</span></span><br><span class="line"><span class="comment">		a:function</span></span><br><span class="line"><span class="comment">	&#125;</span></span><br><span class="line"><span class="comment">	全局执行上下文创建阶段结束，开始执行代码</span></span><br><span class="line"><span class="comment">	执行到a(1)</span></span><br><span class="line"><span class="comment">	</span></span><br><span class="line"><span class="comment">	创建a函数执行上下文，并压入栈</span></span><br><span class="line"><span class="comment">	1.产生AO对象</span></span><br><span class="line"><span class="comment">	2.查找形参和变量声明：x、i，并初始化为undefined</span></span><br><span class="line"><span class="comment">	3.将实参1赋值给形参x，x:1</span></span><br><span class="line"><span class="comment">	4.查找函数声明：b，并初始化为function</span></span><br><span class="line"><span class="comment">	AO:&#123;</span></span><br><span class="line"><span class="comment">		x:1,</span></span><br><span class="line"><span class="comment">		i:undefined,</span></span><br><span class="line"><span class="comment">		b:function</span></span><br><span class="line"><span class="comment">	&#125;</span></span><br><span class="line"><span class="comment">	函数执行上下文创建阶段结束，开始执行代码</span></span><br><span class="line"><span class="comment">	console.log(i)</span></span><br><span class="line"><span class="comment">	此时还没有执行赋值语句，所以i还是undefined</span></span><br><span class="line"><span class="comment">	继续执行 var i = 0</span></span><br><span class="line"><span class="comment">	此时AO:&#123; x:1, i:0, b:function &#125;</span></span><br><span class="line"><span class="comment">	再继续执行 console.log(i)</span></span><br><span class="line"><span class="comment">	输出的自然是0</span></span><br><span class="line"><span class="comment">	跳过函数声明，继续执行b()</span></span><br><span class="line"><span class="comment">	</span></span><br><span class="line"><span class="comment">	创建b函数执行上下文，并压入栈</span></span><br><span class="line"><span class="comment">	1.产生新的AO对象</span></span><br><span class="line"><span class="comment">	2.查找形参和变量声明：无</span></span><br><span class="line"><span class="comment">	3.查找函数声明：无</span></span><br><span class="line"><span class="comment">	AO:&#123;&#125;</span></span><br><span class="line"><span class="comment">	函数执行上下文创建阶段结束，开始执行代码</span></span><br><span class="line"><span class="comment">	console.log(1)</span></span><br><span class="line"><span class="comment">	输出打印1</span></span><br><span class="line"><span class="comment">	b函数执行完毕，接着就是执行上下文的销毁阶段</span></span><br><span class="line"><span class="comment">	b函数执行上下文将从执行栈中弹出并销毁，对应的AO对象也被释放</span></span><br><span class="line"><span class="comment">	然后继续执行a函数代码，a函数执行完毕，a函数执行上下文将从执行栈中弹出并销毁，对应的AO对象被释放</span></span><br><span class="line"><span class="comment">	继续执行全局代码</span></span><br><span class="line"><span class="comment">	注意：即使代码全部执行完毕，全局执行上下文也不会从执行栈中弹出，直到关闭该页面</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></div></figure>

<p>以上代码请结合画图理解</p>
<br>


        <h3 id="3-销毁阶段">
          <a href="#3-销毁阶段" class="heading-link"><i class="fas fa-link"></i></a><a href="#3-销毁阶段" class="headerlink" title="(3) 销毁阶段"></a>(3) 销毁阶段</h3>
      <p>当函数代码执行完后，当前执行上下文<strong>（局部环境）</strong>会被弹出执行上下文栈并销毁，对应的变量对象也被释放，控制权被重新交给执行栈上一层的执行上下文。</p>
<blockquote>
<p>这是一般情况，但如果产生了闭包，会有所不同。闭包将在下面的篇章中介绍。</p>
</blockquote>
<br>


        <h2 id="5-总结">
          <a href="#5-总结" class="heading-link"><i class="fas fa-link"></i></a><a href="#5-总结" class="headerlink" title="5.总结"></a>5.总结</h2>
      <p>至此，执行上下文的所有内容都介绍完毕</p>
<img src="/2022/02/20/%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87%E3%80%81%E4%BD%9C%E7%94%A8%E5%9F%9F%E3%80%81%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%93%BE%E5%92%8C%E9%97%AD%E5%8C%85/%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87-%E6%80%9D%E7%BB%B4%E5%AF%BC%E5%9B%BE.png" class>

<p>练习：</p>
<figure class="highlight javascript"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 第一题</span></span><br><span class="line"><span class="keyword">var</span> foo = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;foo1&quot;</span>);</span><br><span class="line">&#125;;</span><br><span class="line">foo();</span><br><span class="line"><span class="keyword">var</span> foo = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;foo2&quot;</span>);</span><br><span class="line">&#125;;</span><br><span class="line">foo();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第二题</span></span><br><span class="line">foo();</span><br><span class="line"><span class="keyword">var</span> foo = <span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;foo1&quot;</span>);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;foo2&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">foo();</span><br></pre></td></tr></table></div></figure>

<p>接下去我们讲解一下作用域与作用域链。</p>
<br>


        <h1 id="二-作用域与作用域链">
          <a href="#二-作用域与作用域链" class="heading-link"><i class="fas fa-link"></i></a><a href="#二-作用域与作用域链" class="headerlink" title="二.作用域与作用域链"></a>二.作用域与作用域链</h1>
      
        <h2 id="1-作用域">
          <a href="#1-作用域" class="heading-link"><i class="fas fa-link"></i></a><a href="#1-作用域" class="headerlink" title="1.作用域"></a>1.作用域</h2>
      <p>域，顾名思义就是区域、范围的意思。那么作用域，就是指<code>当前代码对变量的访问区域</code>，或者说<code>可访问变量的集合</code>。</p>
<p>作用域分为三类：</p>
<ul>
<li>全局作用域</li>
<li>局部作用域（函数作用域）</li>
<li>块级作用域</li>
</ul>
<p>早期 ES 标准中并没有块级作用域的概念，我将在下文 ES5 标准中介绍块级作用域，这里我们只考虑<code>全局作用域</code>和<code>局部作用域</code>。从代码编写的角度可以这样理解：</p>
<img src="/2022/02/20/%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87%E3%80%81%E4%BD%9C%E7%94%A8%E5%9F%9F%E3%80%81%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%93%BE%E5%92%8C%E9%97%AD%E5%8C%85/%E4%BD%9C%E7%94%A8%E5%9F%9F.jpg" class>

<p>上面红色框表示的就是局部作用域，黄色框表示全局作用域。结合我们上面执行上下文中所学的内容，<code>JS引擎对变量的访问实际上就是从GO或者AO对象上查找属性</code>，那么也就是说：</p>
<ul>
<li>全局作用域本质上就是 GO 对象</li>
<li>局部作用域本质上就是 AO 对象</li>
</ul>
<br>


        <h2 id="2-作用域链">
          <a href="#2-作用域链" class="heading-link"><i class="fas fa-link"></i></a><a href="#2-作用域链" class="headerlink" title="2.作用域链"></a>2.作用域链</h2>
      <p>那么什么是作用域链呢？以下面的代码为例：</p>
<figure class="highlight javascript"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  i++;</span><br><span class="line">  <span class="built_in">console</span>.log(i);</span><br><span class="line">&#125;</span><br><span class="line">a();</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	我们还是按照执行上下文来分析这段代码</span></span><br><span class="line"><span class="comment">	首先创建全局执行上下文，并压入执行栈</span></span><br><span class="line"><span class="comment">	1.产生window对象</span></span><br><span class="line"><span class="comment">	2.查找变量声明：i，并初始化为undefined</span></span><br><span class="line"><span class="comment">	3.查找函数声明：a，并初始化为function</span></span><br><span class="line"><span class="comment">	GO:&#123;</span></span><br><span class="line"><span class="comment">		i:undefined,</span></span><br><span class="line"><span class="comment">		a:function</span></span><br><span class="line"><span class="comment">	&#125;</span></span><br><span class="line"><span class="comment">	全局执行上下文创建完毕，开始执行代码</span></span><br><span class="line"><span class="comment">	var i = 0</span></span><br><span class="line"><span class="comment">	将O赋值给GO对象中的i，此时的GO:&#123; i:0, a:function &#125;</span></span><br><span class="line"><span class="comment">	继续执行 a()</span></span><br><span class="line"><span class="comment">	</span></span><br><span class="line"><span class="comment">	创建a函数执行上下文，并压入执行栈</span></span><br><span class="line"><span class="comment">	1.产生AO对象</span></span><br><span class="line"><span class="comment">	2.查找形参和变量声明：无</span></span><br><span class="line"><span class="comment">	3.查找函数声明：无</span></span><br><span class="line"><span class="comment">	AO:&#123;&#125;</span></span><br><span class="line"><span class="comment">	函数执行上下文创建完毕，开始执行代码</span></span><br><span class="line"><span class="comment">	i++</span></span><br><span class="line"><span class="comment">	这个时候，JS引擎会先从函数作用域(也就是AO对象)中上查找i，发现函数作用域中并没有，于是就向上级作用域查找，这里代码的上级作用域就是全局作用域(GO对象)，发现i为0，那么执行i++。此时GO:&#123; i:1, a:function &#125;</span></span><br><span class="line"><span class="comment">	继续执行 console.log(i)</span></span><br><span class="line"><span class="comment">	查找过程同上，输出i为1。函数执行完毕</span></span><br><span class="line"><span class="comment">	...(销毁阶段省略)</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></div></figure>

<p>这样一个查找过程形成的链式结构，就叫<code>作用域链</code>。</p>
<p>那么问题来了，函数 a 在执行中怎么确定上级作用域是谁呢？</p>
<p>其实，在函数声明的时候，创建的函数对象中包含了一个<code>隐藏属性[[scope]]</code>，这个属性记录了当前的执行环境。上面的代码用图像表示：</p>
<ol>
<li><p>首先创建全局执行上下文并压入栈；产生 GO 对象；查找变量声明：i，初始化 undefined；查找函数声明：a，初始化 function，即创建一个函数对象，并被 a 引用。这个时候函数对象中的[[scope]]属性就记录了当前的执行环境，它是一个数组，而当前正处于全局执行上下文，那么这个数组的第 1 位就是 GO 对象：a.[[scope]] = [GO]</p>
<img src="/2022/02/20/%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87%E3%80%81%E4%BD%9C%E7%94%A8%E5%9F%9F%E3%80%81%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%93%BE%E5%92%8C%E9%97%AD%E5%8C%85/%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%93%BE-1.png" class>

<blockquote>
<p>图上这么画其实不准确，数组也是一个对象，所以[[scope]]属性应该要引用这个对象的地址，而这个对象要引用 GO 对象，但为了避免线条过多造成的视觉影响，所以采用图上的画法。</p>
<p>另外提醒一点，[[scope]]属性只有 JS 引擎能够访问，下文所有与[[scope]]相关的代码都是伪代码，比如：a.[[scope]]其实是不能运行的。</p>
</blockquote>
</li>
<li><p>全局执行上下文的创建结束，开始执行代码 var a = 0。</p>
<img src="/2022/02/20/%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87%E3%80%81%E4%BD%9C%E7%94%A8%E5%9F%9F%E3%80%81%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%93%BE%E5%92%8C%E9%97%AD%E5%8C%85/%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%93%BE-2.png" class></li>
<li><p>继续执行 a()，此时函数被调用，创建函数执行上下文，并压入执行栈；产生 a 函数的 AO 对象；没有形参、变量声明和函数声明，AO 对象为空对象。</p>
<img src="/2022/02/20/%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87%E3%80%81%E4%BD%9C%E7%94%A8%E5%9F%9F%E3%80%81%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%93%BE%E5%92%8C%E9%97%AD%E5%8C%85/%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%93%BE-3.png" class></li>
<li><p>还记得执行上下文创建阶段中有一个创建作用域链吗？当<strong>函数执行上下文创建</strong>时，除了创建变量对象，JS 引擎还会根据函数的[[scope]]属性去<strong>创建作用域链</strong>，将当前产生的<code>AO对象</code>添加到作用域链的<strong>最前端</strong>，也就是说当前执行上下文的作用域链为<code>[aAO,GO]</code>，即 JS 引擎访问变量的顺序就是<code>aAO-&gt;GO</code>。</p>
<p><strong>注意：</strong></p>
<ol>
<li>作用域链也是个数组，但它和[[scope]]是不同的，后者是函数对象中的属性，表示函数创建时的执行环境；前者是执行上下文的一部分，表示当前执行上下文中 JS 引擎访问变量的查找过程。</li>
<li>作用域链 = AO + [[scope]]，AO 会添加在作用域链的最前面：作用域链 = [AO].concat([[scope]])</li>
<li>全局执行上下文的作用域链就是[GO]</li>
</ol>
<img src="/2022/02/20/%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87%E3%80%81%E4%BD%9C%E7%94%A8%E5%9F%9F%E3%80%81%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%93%BE%E5%92%8C%E9%97%AD%E5%8C%85/%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%93%BE-4.png" class></li>
<li><p>此时函数执行上下文创建完毕，开始执行代码 i++，顺着作用域链查找并执行赋值语句。然后继续执行 console.log(i)，输出打印 1。</p>
<img src="/2022/02/20/%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87%E3%80%81%E4%BD%9C%E7%94%A8%E5%9F%9F%E3%80%81%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%93%BE%E5%92%8C%E9%97%AD%E5%8C%85/%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%93%BE-5.png" class></li>
<li><p>函数执行完毕，a 函数执行上下文弹出并销毁，aAO 被释放。</p>
<img src="/2022/02/20/%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87%E3%80%81%E4%BD%9C%E7%94%A8%E5%9F%9F%E3%80%81%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%93%BE%E5%92%8C%E9%97%AD%E5%8C%85/%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%93%BE-6.png" class></li>
<li><p>继续执行全局代码，直至页面关闭，全局执行上下文弹出并销毁。</p>
</li>
</ol>
<p>我们可以通过下面这个例子加深理解：</p>
<figure class="highlight javascript"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">b</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">c</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(i);</span><br><span class="line">    &#125;</span><br><span class="line">    c();</span><br><span class="line">  &#125;</span><br><span class="line">  b();</span><br><span class="line">&#125;</span><br><span class="line">a();</span><br></pre></td></tr></table></div></figure>

<p>当 c 函数执行上下文创建时的图应该是这个样子：</p>
<img src="/2022/02/20/%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87%E3%80%81%E4%BD%9C%E7%94%A8%E5%9F%9F%E3%80%81%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%93%BE%E5%92%8C%E9%97%AD%E5%8C%85/%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%93%BE-7.png" class>

<blockquote>
<p>b 函数是在 a 函数中声明的，b 函数创建时[[scope]]属性的赋值，其实和 a 函数执行上下文创建作用域链的步骤是一样的，都是复制 a 函数的[[scope]]属性中的对象，将 a 函数执行上下文产生的 AO 对象添加到数组的第一位，也就是说 b 函数的[[scope]]属性和 a 函数执行上下文的作用域链内容是一样的，但是表示的含义不同。</p>
<p>[[scope]]所谓的保存当前执行环境，其实就是保存了变量对象到其中。</p>
</blockquote>
<p>再一次强调：<strong>函数创建时，就会保存当前的执行环境。</strong>所以有一句话叫：<code>函数的作用域在函数创建的时候决定而不是在调用的时候决定</code>。</p>
<blockquote>
<p>我个人认为，这句话的准确说法应该是：函数执行上下文的 作用域链，在函数创建的时候决定而不是调用的时候决定。（AO+[[scope]]）</p>
<p>因为现在一直在讲作用域链，突然提及<code>函数的作用域</code>，感觉有点奇怪。我们刚刚说了函数的作用域本质上是 AO 对象，那这句话里的<code>函数的作用域</code>要是按照 AO 对象去理解的话显然说不通，它指的应该是函数的[[scope]]属性。</p>
<p>无论你怎么理解，总归都是一句话：当函数创建时，它体内就保存了当时的执行环境。</p>
</blockquote>
<p>我们再用一个例子强化这个理解：</p>
<figure class="highlight javascript"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(a);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> a = <span class="number">3</span>;</span><br><span class="line">  foo();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> a = <span class="number">2</span>;</span><br><span class="line">bar();</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	结果：console.log打印输出2，而不是3</span></span><br><span class="line"><span class="comment">	过程：</span></span><br><span class="line"><span class="comment">	创建全局执行上下文，并压入栈</span></span><br><span class="line"><span class="comment">	1.产生window对象</span></span><br><span class="line"><span class="comment">	2.查找变量声明：a，初始化为undefined</span></span><br><span class="line"><span class="comment">	3.查找函数声明:foo、bar，初始化为function</span></span><br><span class="line"><span class="comment">	GO:&#123;</span></span><br><span class="line"><span class="comment">		a:undefined,</span></span><br><span class="line"><span class="comment">		foo:function</span></span><br><span class="line"><span class="comment">		bar:function</span></span><br><span class="line"><span class="comment">	&#125;</span></span><br><span class="line"><span class="comment">	同时</span></span><br><span class="line"><span class="comment">	foo.[[scope]] = [GO]</span></span><br><span class="line"><span class="comment">	bar.[[scope]] = [GO]</span></span><br><span class="line"><span class="comment">	创建作用域链:因为是全局执行上下文，所以就是[GO]</span></span><br><span class="line"><span class="comment">	</span></span><br><span class="line"><span class="comment">	全局执行上下文创建完毕，开始执行代码</span></span><br><span class="line"><span class="comment">	var a = 2</span></span><br><span class="line"><span class="comment">	此时GO:&#123; a:2, foo:function, bar:function &#125;</span></span><br><span class="line"><span class="comment">	继续执行bar()</span></span><br><span class="line"><span class="comment">	</span></span><br><span class="line"><span class="comment">	创建bar函数执行上下文，并压入栈</span></span><br><span class="line"><span class="comment">	1.产生AO对象(简称bAO)</span></span><br><span class="line"><span class="comment">	2.查找形参、变量声明：a，初始化为undefined</span></span><br><span class="line"><span class="comment">	3.没有形参，所以不用将实参赋值给形参</span></span><br><span class="line"><span class="comment">	4.查找函数声明：无</span></span><br><span class="line"><span class="comment">	bAO：&#123;</span></span><br><span class="line"><span class="comment">		a:undefined</span></span><br><span class="line"><span class="comment">	&#125;</span></span><br><span class="line"><span class="comment">	创建作用域链:[bAO,GO]</span></span><br><span class="line"><span class="comment">	</span></span><br><span class="line"><span class="comment">	bar函数执行上下文创建完毕，开始执行代码</span></span><br><span class="line"><span class="comment">	var a = 3</span></span><br><span class="line"><span class="comment">	此时bAO:&#123; a:3 &#125;</span></span><br><span class="line"><span class="comment">	继续执行foo()</span></span><br><span class="line"><span class="comment">	这里要注意，foo并不是在bar函数中声明的，bAO中没有foo属性，那么JS引擎就会顺着作用域链去GO中查找，找到foo并执行</span></span><br><span class="line"><span class="comment">	</span></span><br><span class="line"><span class="comment">	创建foo函数执行上下文，并压入栈</span></span><br><span class="line"><span class="comment">	1.产生AO对象(简称fAO)</span></span><br><span class="line"><span class="comment">	2.查找形参、变量声明：无</span></span><br><span class="line"><span class="comment">	3.查找函数声明：无</span></span><br><span class="line"><span class="comment">	fAO:&#123;&#125;</span></span><br><span class="line"><span class="comment">	创建作用域链:[fAO,GO]</span></span><br><span class="line"><span class="comment">	</span></span><br><span class="line"><span class="comment">	foo函数执行上下文创建完毕，开始执行代码</span></span><br><span class="line"><span class="comment">	console.log(a)</span></span><br><span class="line"><span class="comment">	由于fAO中并没有a属性，所以沿着作用域链查找GO，发现GO中的a为2，所以输出打印2而不是3</span></span><br><span class="line"><span class="comment">	...(销毁阶段省略)</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></div></figure>

<p>如果用图像表示：</p>
<ol>
<li><p>创建全局执行上下文并压入栈；产生 GO 对象；查找变量声明：a，并初始化为 undefined；查找函数声明：foo、bar，并初始化为 function。foo、bar 函数的[[scope]]值为[GO]，另外全局执行上下文的作用域链就是[GO]。</p>
<img src="/2022/02/20/%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87%E3%80%81%E4%BD%9C%E7%94%A8%E5%9F%9F%E3%80%81%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%93%BE%E5%92%8C%E9%97%AD%E5%8C%85/%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%93%BE-8.png" class></li>
<li><p>全局执行上下文创建完毕，开始执行代码 var a = 2。</p>
<img src="/2022/02/20/%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87%E3%80%81%E4%BD%9C%E7%94%A8%E5%9F%9F%E3%80%81%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%93%BE%E5%92%8C%E9%97%AD%E5%8C%85/%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%93%BE-9.png" class></li>
<li><p>继续执行 bar()。</p>
</li>
<li><p>函数被调用，创建 bar 函数执行上下文；产生 AO 对象（图中的 bAO）；有一个变量声明 a，初始化为 undefined，没有形参，也没有函数声明。</p>
<img src="/2022/02/20/%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87%E3%80%81%E4%BD%9C%E7%94%A8%E5%9F%9F%E3%80%81%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%93%BE%E5%92%8C%E9%97%AD%E5%8C%85/%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%93%BE-10.png" class></li>
<li><p>接着创建 bar 函数执行上下文的作用域链，bar 函数的[[scope]]为[GO]，所以 bar 函数执行上下文的作用域链为[bAO, GO]。</p>
<img src="/2022/02/20/%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87%E3%80%81%E4%BD%9C%E7%94%A8%E5%9F%9F%E3%80%81%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%93%BE%E5%92%8C%E9%97%AD%E5%8C%85/%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%93%BE-11.png" class></li>
<li><p>bar 函数执行上下文创建完毕，开始执行代码 var a = 3。</p>
<img src="/2022/02/20/%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87%E3%80%81%E4%BD%9C%E7%94%A8%E5%9F%9F%E3%80%81%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%93%BE%E5%92%8C%E9%97%AD%E5%8C%85/%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%93%BE-12.png" class></li>
<li><p>继续执行 foo()。因为 bAO 中并没有 foo 属性，JS 引擎将顺着作用域链查找，在 GO 中查找到 foo 并调用。</p>
</li>
<li><p>创建 foo 函数执行上下文；产生 AO 对象（图中的 fAO）；没有形参、变量声明、函数声明。</p>
<img src="/2022/02/20/%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87%E3%80%81%E4%BD%9C%E7%94%A8%E5%9F%9F%E3%80%81%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%93%BE%E5%92%8C%E9%97%AD%E5%8C%85/%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%93%BE-13.png" class></li>
<li><p>接着创建 foo 函数执行上下文的作用域链，foo 函数的[[scope]]为[GO]，所以 foo 函数执行上下文的作用域链为[fAO, GO]。</p>
<img src="/2022/02/20/%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87%E3%80%81%E4%BD%9C%E7%94%A8%E5%9F%9F%E3%80%81%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%93%BE%E5%92%8C%E9%97%AD%E5%8C%85/%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%93%BE-14.png" class></li>
<li><p>foo 函数执行上下文创建完毕，开始执行代码 console.log(a)。由于 fAO 中并没有 a 属性，所以沿着作用域链查找，找到 GO 中有 a 属性，输出打印 2。</p>
</li>
<li><p>…（销毁阶段省略）</p>
</li>
</ol>
<p>从上面的图可以看出来，JS 引擎并非按照执行上下文的调用顺序形成作用域链（如果是按照调用顺序决定作用域链，那 foo 函数执行上下文的作用域链应该是 fAO-&gt;bAO-&gt;GO，显然并不是），而是根据函数创建时的执行环境形成作用域链。最直观的，我们可以直接通过函数的书写位置来判断作用域链。因此 JS 的作用域被称为<code>词法作用域</code>。</p>
<img src="/2022/02/20/%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87%E3%80%81%E4%BD%9C%E7%94%A8%E5%9F%9F%E3%80%81%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%93%BE%E5%92%8C%E9%97%AD%E5%8C%85/%E8%AF%8D%E6%B3%95%E4%BD%9C%E7%94%A8%E5%9F%9F.jpg" class>

<br>


        <h2 id="3-总结">
          <a href="#3-总结" class="heading-link"><i class="fas fa-link"></i></a><a href="#3-总结" class="headerlink" title="3.总结"></a>3.总结</h2>
      <p>作用域和作用域链的部分讲完了。这部分比较难理解，概念比较多，需要花时间消化。</p>
<p>另外，不同人对于相同的词可能有不同的理解，这就导致很多博客和教学视频对于执行上下文、作用域和作用域链等概念解释得并不相同。上文仅代表我个人理解，对你或许会有帮助。</p>
<p>练习：</p>
<figure class="highlight javascript"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 第一题</span></span><br><span class="line"><span class="keyword">var</span> foo = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(foo);</span><br><span class="line">  <span class="keyword">var</span> foo = <span class="number">10</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(foo);</span><br><span class="line">&#125;</span><br><span class="line">bar();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第二题</span></span><br><span class="line"><span class="keyword">var</span> foo = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(foo);</span><br><span class="line">  foo = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line">bar();</span><br><span class="line"><span class="built_in">console</span>.log(foo);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第三题</span></span><br><span class="line"><span class="keyword">var</span> foo = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params">foo</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(foo);</span><br><span class="line">  foo = <span class="number">234</span>;</span><br><span class="line">&#125;</span><br><span class="line">bar(<span class="number">123</span>);</span><br><span class="line"><span class="built_in">console</span>.log(foo);</span><br></pre></td></tr></table></div></figure>

<br>


        <h1 id="三-闭包">
          <a href="#三-闭包" class="heading-link"><i class="fas fa-link"></i></a><a href="#三-闭包" class="headerlink" title="三.闭包"></a>三.闭包</h1>
      
        <h2 id="1-概念-1">
          <a href="#1-概念-1" class="heading-link"><i class="fas fa-link"></i></a><a href="#1-概念-1" class="headerlink" title="1.概念"></a>1.概念</h2>
      <p>这部分应该是 JS 当中最难理解的一部分，但有了之前学到的基础，这部分理解起来就会容易一些。</p>
<p>还是通过一个例子引出：</p>
<figure class="highlight javascript"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> i = <span class="number">0</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(i);</span><br><span class="line">&#125;</span><br><span class="line">test();</span><br></pre></td></tr></table></div></figure>

<p>如果用图像来表示：</p>
<ol>
<li><p>…（全局执行上下文的创建阶段和执行阶段省略）</p>
</li>
<li><p>…（test 函数执行上下文的创建阶段和执行阶段省略）</p>
<img src="/2022/02/20/%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87%E3%80%81%E4%BD%9C%E7%94%A8%E5%9F%9F%E3%80%81%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%93%BE%E5%92%8C%E9%97%AD%E5%8C%85/%E9%97%AD%E5%8C%85-1.png" class></li>
<li><p>当函数执行完时，test 函数执行上下文从栈中弹出并销毁，对应的 AO 对象会被释放（图中蓝色框部分），那么我们将不再能够访问到变量 i</p>
<img src="/2022/02/20/%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87%E3%80%81%E4%BD%9C%E7%94%A8%E5%9F%9F%E3%80%81%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%93%BE%E5%92%8C%E9%97%AD%E5%8C%85/%E9%97%AD%E5%8C%85-2.png" class></li>
</ol>
<p>那么我们想一想，有没有办法将这个 AO 对象保存下来呢？</p>
<p>答案肯定是有的。如果我们在<strong>函数内部</strong>再去声明一个函数，那么这个函数对象的<code>[[scope]]</code>是不是就<strong>保留了当前的执行环境</strong>，也就是说它的体内<strong>存在对当前 AO 对象的引用</strong>。</p>
<figure class="highlight javascript"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> i = <span class="number">0</span>;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">inner</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(i);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">test();</span><br></pre></td></tr></table></div></figure>

<img src="/2022/02/20/%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87%E3%80%81%E4%BD%9C%E7%94%A8%E5%9F%9F%E3%80%81%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%93%BE%E5%92%8C%E9%97%AD%E5%8C%85/%E9%97%AD%E5%8C%85-3.png" class>

<p>但是这样还不够，当 test 函数执行上下文弹出并销毁时，图中的蓝色框部分一样会被释放掉，因为没有存在外部引用，这一部分<strong>不可被访问到</strong>。</p>
<img src="/2022/02/20/%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87%E3%80%81%E4%BD%9C%E7%94%A8%E5%9F%9F%E3%80%81%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%93%BE%E5%92%8C%E9%97%AD%E5%8C%85/%E9%97%AD%E5%8C%85-4.png" class>

<blockquote>
<p>关于垃圾回收机制，可以参考这篇博客：</p>
<p><span class="exturl"><a class="exturl__link" target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000018605776">https://segmentfault.com/a/1190000018605776</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
</blockquote>
<p>解决办法就是在全局环境下声明一个变量，并将 test 函数内的 inner 函数<strong>返回</strong>给它，那么就可以通过全局变量去访问内部函数，进而可以访问到 AO 对象。这种情况下，AO 对象不会被释放。以下面的代码为例：</p>
<figure class="highlight javascript"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> i = <span class="number">0</span>;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">inner</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(i);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> inner;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> a = test();</span><br><span class="line">a(); <span class="comment">// 输出打印0</span></span><br></pre></td></tr></table></div></figure>

<ol>
<li><p>创建全局执行上下文，并压入栈；产生 GO 对象；查找变量声明：a，初始化为 undefined；查找函数声明：test，初始化为 funticon，test.[[scope]] = [GO]；创建作用域链：[GO]</p>
<img src="/2022/02/20/%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87%E3%80%81%E4%BD%9C%E7%94%A8%E5%9F%9F%E3%80%81%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%93%BE%E5%92%8C%E9%97%AD%E5%8C%85/%E9%97%AD%E5%8C%85-5.png" class></li>
<li><p>全局执行上下文创建完毕，开始执行代码 var a = test()</p>
</li>
<li><p>test 函数被调用，创建 test 函数执行上下文，并压入栈；产生 AO 对象：tAO；查找形参：无；查找变量声明：i，初始化为 undefined；查找函数声明：inner，初始化为 function，inner.[[scope]] = [tAO，GO]；创建作用域链：[tAO，GO]</p>
<img src="/2022/02/20/%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87%E3%80%81%E4%BD%9C%E7%94%A8%E5%9F%9F%E3%80%81%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%93%BE%E5%92%8C%E9%97%AD%E5%8C%85/%E9%97%AD%E5%8C%85-6.png" class></li>
<li><p>test 函数执行上下文创建完毕，开始执行代码 var i = 0，<strong>return inner</strong></p>
<img src="/2022/02/20/%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87%E3%80%81%E4%BD%9C%E7%94%A8%E5%9F%9F%E3%80%81%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%93%BE%E5%92%8C%E9%97%AD%E5%8C%85/%E9%97%AD%E5%8C%85-7.png" class></li>
<li><p>test 函数执行完毕，函数上下文从执行栈中弹出并销毁，注意全局执行上下文中 var a = test()还未执行完，需要将 test 函数的返回值赋值给变量 a，a 保存对 inner 函数对象的引用</p>
<img src="/2022/02/20/%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87%E3%80%81%E4%BD%9C%E7%94%A8%E5%9F%9F%E3%80%81%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%93%BE%E5%92%8C%E9%97%AD%E5%8C%85/%E9%97%AD%E5%8C%85-8.png" class>

<p>这时候由于 tAO 仍能被访问，所以它不会被释放</p>
</li>
<li><p>继续执行全局代码 a()，也就是调用 inner 函数</p>
</li>
<li><p>创建 inner 函数执行上下文，并压入栈；产生 AO 对象：iAO；查找形参：无；查找变量声明：无；查找函数声明：无；<strong>创建作用域链：</strong>因为 inner 函数[[scope]]为[tAO，GO]，所以作用域链为[iAO，tAO，GO]</p>
<img src="/2022/02/20/%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87%E3%80%81%E4%BD%9C%E7%94%A8%E5%9F%9F%E3%80%81%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%93%BE%E5%92%8C%E9%97%AD%E5%8C%85/%E9%97%AD%E5%8C%85-9.png" class></li>
<li><p>inner 函数执行上下文创建完毕，开始执行代码 console.log(i)。JS 引擎会顺着作用域链查找变量，在 tAO 中找到，输出打印 0</p>
</li>
<li><p>inner 函数执行完毕，从执行栈中弹出并销毁，对应的 iAO 被释放</p>
<img src="/2022/02/20/%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87%E3%80%81%E4%BD%9C%E7%94%A8%E5%9F%9F%E3%80%81%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%93%BE%E5%92%8C%E9%97%AD%E5%8C%85/%E9%97%AD%E5%8C%85-10.png" class></li>
</ol>
<p>这就是<code>闭包</code>。百度百科上的解释是：<code>闭包就是能够读取其他函数内部变量的函数</code>。按照这样的解释，我们上面代码中的 inner 函数就是闭包。由于在 javascript 中，只有函数内部的子函数才能读取局部变量，所以说，闭包可以简单理解成“定义在一个函数内部的函数”。所以在本质上，<code>闭包是将函数内部和函数外部连接起来的桥梁</code>。</p>
<br>


        <h2 id="2-作用">
          <a href="#2-作用" class="heading-link"><i class="fas fa-link"></i></a><a href="#2-作用" class="headerlink" title="2.作用"></a>2.作用</h2>
      <p>闭包最大的作用有两个：</p>
<ol>
<li><p>可以让<strong>外部环境</strong>读取到函数内部的变量</p>
<p>刚刚的例子中，我们在全局执行上下文中，可以读取到 test 函数内的变量 i。</p>
</li>
<li><p>可以让这些变量的值始终保存在内存中，延长它们的生命周期</p>
<p>刚刚的例子中，变量 i 始终没有被释放。</p>
</li>
</ol>
<br>


        <h2 id="3-问题">
          <a href="#3-问题" class="heading-link"><i class="fas fa-link"></i></a><a href="#3-问题" class="headerlink" title="3.问题"></a>3.问题</h2>
      <p>凡事都有两面性，闭包带来好处的同时，必然会带来一些问题。其实我们刚刚讲到的闭包作用之一：延迟局部变量的生命周期。这就容易导致<strong>内存泄漏</strong>，将不必要的局部变量保存在内存当中。</p>
<p>解决方案：在不使用局部变量后将其释放。如果是刚刚的例子，可以在代码最后加上<code>a = null</code>释放掉。</p>
<br>


        <h2 id="4-总结">
          <a href="#4-总结" class="heading-link"><i class="fas fa-link"></i></a><a href="#4-总结" class="headerlink" title="4.总结"></a>4.总结</h2>
      <p>在这一章节中，我们介绍了闭包的概念、作用和带来的问题。我们总结一下闭包形成的条件：</p>
<ol>
<li><p>函数嵌套</p>
<p>上面的例子中，test 函数嵌套了 inner 函数，test 函数称为<code>外部函数</code>，inner 函数称为<code>内部函数</code>。为什么需要返回一个函数？因为函数是个对象，如果返回的仅仅是原始数据类型，变量 a 只会简单复制返回的值，而不是对一个对象的引用。</p>
</li>
<li><p>内部函数使用了外部函数的变量</p>
<p>闭包的目的就是为了让外部环境读取到函数内部的变量，如果内部函数不使用外部函数的变量，那返回内部函数也没有意义。</p>
</li>
<li><p>内部函数需要被外部环境引用</p>
<p>如果不被引用，内部函数将在外部函数运行完被释放。</p>
</li>
</ol>
<p>练习：</p>
<figure class="highlight javascript"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 第一题</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> a = <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(a);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> bar = foo();</span><br><span class="line">bar();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第二题</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> a = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(a++);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> bar = foo();</span><br><span class="line">bar();</span><br><span class="line">bar();</span><br><span class="line">bar();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第三题</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">b</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(i++);</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">var</span> c = b();</span><br><span class="line">  c();</span><br><span class="line">&#125;</span><br><span class="line">a();</span><br></pre></td></tr></table></div></figure>

<br>


        <h1 id="四-ES5-标准下的执行上下文">
          <a href="#四-ES5-标准下的执行上下文" class="heading-link"><i class="fas fa-link"></i></a><a href="#四-ES5-标准下的执行上下文" class="headerlink" title="四.ES5 标准下的执行上下文"></a>四.ES5 标准下的执行上下文</h1>
      <p>从 ES5 标准开始，执行上下文与 ES3 有了很大的变化，最大的改变就是去除了变量对象的概念，以<strong>词法环境组件</strong>和<strong>变量环境组件</strong>替代。</p>
<p>在 ES5 中执行上下文创建阶段主要做三件事：</p>
<ul>
<li>创建词法环境组件</li>
<li>创建变量环境组件</li>
<li>绑定 this</li>
</ul>
<p>接下来我们聊一聊这些新名词。</p>
<br>


        <h2 id="1-词法环境-变量环境">
          <a href="#1-词法环境-变量环境" class="heading-link"><i class="fas fa-link"></i></a><a href="#1-词法环境-变量环境" class="headerlink" title="1.词法环境/变量环境"></a>1.词法环境/变量环境</h2>
      
        <h3 id="1-词法环境">
          <a href="#1-词法环境" class="heading-link"><i class="fas fa-link"></i></a><a href="#1-词法环境" class="headerlink" title="(1) 词法环境"></a>(1) 词法环境</h3>
      <p>词法环境（Lexical Environment），是一种持有<strong>标志符—变量的映射</strong>的结构（标志符就是指变量/函数名，变量是对实际对象或原始数据的引用）。看不懂没关系，我们先继续。</p>
<p>词法环境的内部有两个组件：</p>
<ul>
<li>环境记录器（Environment Record）：是存储变量和函数声明的实际位置</li>
<li>外部环境的引用（outer）：意味着它可以访问其父级词法环境</li>
</ul>
<p>如果用伪代码看起来是这样的：</p>
<figure class="highlight javascript"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">LexicalEnvironment: &#123;		<span class="comment">// 词法环境</span></span><br><span class="line">    <span class="attr">EnvironmentRecord</span>: &#123;&#125;,	<span class="comment">// 环境记录器</span></span><br><span class="line">    <span class="attr">outer</span>: &lt;<span class="literal">null</span>&gt;			<span class="comment">// 外部环境的引用</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>这么一看，词法环境中的环境记录器像不像我们 ES3 中的变量对象，因为它们的作用是一样的。如果用图像表示，大概就像这样：</p>
<img src="/2022/02/20/%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87%E3%80%81%E4%BD%9C%E7%94%A8%E5%9F%9F%E3%80%81%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%93%BE%E5%92%8C%E9%97%AD%E5%8C%85/ES5-%E8%AF%8D%E6%B3%95%E7%8E%AF%E5%A2%83.png" class>

<p>另外，我们会发现在 ES5 规范的执行上下文的创建阶段，没有了 ES3 时候的创建作用域链，这其实是将作用域链的概念转移到了 outer 中。</p>
<br>


        <h3 id="2-变量环境">
          <a href="#2-变量环境" class="heading-link"><i class="fas fa-link"></i></a><a href="#2-变量环境" class="headerlink" title="(2) 变量环境"></a>(2) 变量环境</h3>
      <p>变量环境（Variable Environment），它也是一个<strong>词法环境</strong>，所以它有着词法环境的所有特性，包括环境记录器和对外部环境的引用。</p>
<figure class="highlight javascript"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">VariableEnvironment: &#123;		<span class="comment">// 变量环境</span></span><br><span class="line">    <span class="attr">EnvironmentRecord</span>: &#123;&#125;,	<span class="comment">// 环境记录器</span></span><br><span class="line">    <span class="attr">outer</span>: &lt;<span class="literal">null</span>&gt;			<span class="comment">// 外部环境的引用</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>既然它就是一个词法环境，为什么要单独提出一个变量环境的概念呢？之所以在 ES5 的规范里要单独分出一个变量环境的概念是为 ES6 服务的：在 ES6 中词法环境用来存储<strong>let、const 变量声明</strong>，而变量环境用来存储<strong>var 变量声明</strong>和<strong>函数声明</strong>。如果用图像表示，大概这样：</p>
<blockquote>
<p>在 ES5 中，还没有 let、const 声明，以及待会要讲到的块级作用域，在 ES6 中它们才出现。但是这些概念已经提出来了，ES5 中执行上下文的很多内容其实是在为 ES6 服务。</p>
</blockquote>
<img src="/2022/02/20/%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87%E3%80%81%E4%BD%9C%E7%94%A8%E5%9F%9F%E3%80%81%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%93%BE%E5%92%8C%E9%97%AD%E5%8C%85/ES5-%E5%8F%98%E9%87%8F%E7%8E%AF%E5%A2%83.png" class>

<br>


        <h3 id="3-环境记录器">
          <a href="#3-环境记录器" class="heading-link"><i class="fas fa-link"></i></a><a href="#3-环境记录器" class="headerlink" title="(3) 环境记录器"></a>(3) 环境记录器</h3>
      <p>环境记录器（Environment Record），它是存储变量和函数声明的实际位置。</p>
<p>在全局环境和函数环境中，环境记录器又有所区别，它有两种类型：</p>
<ul>
<li>对象环境记录器（在全局环境中）</li>
<li>声明式环境记录器（在函数环境中）</li>
</ul>
<p>声明式环境记录器相比对象环境记录器，还包含一个传递给函数的<code>arguments</code>对象和传递给函数的<code>参数的length</code>。</p>
<br>


        <h3 id="4-外部环境的引用">
          <a href="#4-外部环境的引用" class="heading-link"><i class="fas fa-link"></i></a><a href="#4-外部环境的引用" class="headerlink" title="(4) 外部环境的引用"></a>(4) 外部环境的引用</h3>
      <p>外部环境的引用（outer），它的作用是访问父级词法环境。</p>
<ul>
<li>在全局执行上下文中，该值为 null</li>
<li>在函数执行上下文中，该值为全局对象，或者为父级词法环境（作用域）</li>
</ul>
<br>


        <h2 id="2-执行上下文的生命周期">
          <a href="#2-执行上下文的生命周期" class="heading-link"><i class="fas fa-link"></i></a><a href="#2-执行上下文的生命周期" class="headerlink" title="2.执行上下文的生命周期"></a>2.执行上下文的生命周期</h2>
      <p>ES5 标准中执行上下文的执行阶段和销毁阶段与 ES3 基本无异，故重点还是关注创建阶段。</p>
<ul>
<li>全局执行上下文的创建阶段，JS 引擎会做这些事情：</li>
</ul>
<ol>
<li><p>创建词法环境，对外部环境的引用为<code>null</code></p>
<ol>
<li>查找<strong>顶级</strong>let、const 变量声明，存入词法环境的环境记录器，但<strong>不初始化</strong></li>
</ol>
</li>
<li><p>创建变量环境，对外部环境的引用为<code>null</code></p>
<ol>
<li>查找<strong>非函数内</strong>的 var 声明，存入变量环境的环境记录器，初始化为 undefined</li>
<li>查找<strong>顶级</strong>函数声明，存入变量环境的环境记录器，初始化为 function</li>
<li>查找<strong>代码块</strong>中的<strong>与上述几条非重名</strong>的函数声明，存入变量环境的环境记录器，初始化为 undefined</li>
</ol>
</li>
<li><p>绑定 this（这点在本文中不介绍）</p>
</li>
</ol>
<ul>
<li>函数执行上下文的创建阶段，JS 引擎会做这些事情：</li>
</ul>
<ol>
<li><p>创建词法环境，对外部环境的引用为<code>父级词法环境</code></p>
<ol>
<li>查找<strong>函数内非块中</strong>的 let、const 变量声明，存入词法环境的环境记录器，但<strong>不初始化</strong></li>
</ol>
</li>
<li><p>创建变量环境，对外部环境的引用为<code>父级词法环境</code></p>
<ol>
<li>查找<strong>函数内</strong>的 var 声明，存入变量环境的环境记录器，初始化为 undefined</li>
<li>查找形参，存入变量环境的环境记录器，并将实参赋值给形参</li>
<li>查找<strong>函数内非块中</strong>的函数声明，存入变量环境的环境记录器，初始化为 function</li>
<li>查找<strong>代码块</strong>中的<strong>与上述几条非重名</strong>的函数声明，存入变量环境的环境记录器，初始化为 undefined</li>
</ol>
</li>
<li><p>绑定 this（这点在本文中不介绍）</p>
</li>
</ol>
<p><strong>注意：</strong></p>
<ol>
<li><p>函数执行上下文和全局执行上下文的最主要区别就是对形参的处理，其他都是一致的。</p>
</li>
<li><p>let、const 声明的变量，是不初始化的。所以下面的代码会报错。之所以说 let、const 声明的变量没有变量提升，就是这个原因。</p>
<figure class="highlight javascript"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(a);</span><br><span class="line"><span class="keyword">let</span> a;</span><br></pre></td></tr></table></div></figure>

<p>但是，如果两行代码如果换一下位置，是不会报错的。这是因为在执行上下文的执行阶段，当 JS 引擎运行到<code>let a</code>这行代码，发现 a 未初始化，就会初始化为 undefined。</p>
<figure class="highlight javascript"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a;</span><br><span class="line"><span class="built_in">console</span>.log(a); <span class="comment">// undefined</span></span><br></pre></td></tr></table></div></figure></li>
<li><p>不允许同一作用域下出现和 let、const 声明的变量同名的变量或函数，否则会报错。</p>
</li>
<li><p>在执行上下文的创建阶段过程中，我非常强调<code>顶级、非函数内、代码块、函数内非块中</code>等词语，这是因为 let、const 声明的变量存在<strong>块级作用域</strong>的概念，而 var 声明的变量并没有，而对代码块中的函数声明和非代码块中的函数声明，JS 引擎又有不同的处理方式。这些内容我将在下一小节中讲解。</p>
</li>
</ol>
<br>


        <h2 id="3-块级作用域">
          <a href="#3-块级作用域" class="heading-link"><i class="fas fa-link"></i></a><a href="#3-块级作用域" class="headerlink" title="3.块级作用域"></a>3.块级作用域</h2>
      
        <h3 id="1-概念-2">
          <a href="#1-概念-2" class="heading-link"><i class="fas fa-link"></i></a><a href="#1-概念-2" class="headerlink" title="(1) 概念"></a>(1) 概念</h3>
      <p>从 ES6 开始，加入了块级作用域。从代码编写的角度来看，块级作用域可以这么理解：</p>
<img src="/2022/02/20/%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87%E3%80%81%E4%BD%9C%E7%94%A8%E5%9F%9F%E3%80%81%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%93%BE%E5%92%8C%E9%97%AD%E5%8C%85/ES5-%E5%9D%97%E7%BA%A7%E4%BD%9C%E7%94%A8%E5%9F%9F.jpg" class>

<p>蓝色框表示的就是块级作用域。用<code>&#123;&#125;</code>包裹起来的代码称之为<code>代码块</code>，每个代码块都有一个块级作用域。</p>
<br>


        <h3 id="2-let、const-变量">
          <a href="#2-let、const-变量" class="heading-link"><i class="fas fa-link"></i></a><a href="#2-let、const-变量" class="headerlink" title="(2) let、const 变量"></a>(2) let、const 变量</h3>
      <p>我们知道 var 声明的变量是没有块级作用域的概念的，而 let、const 声明的变量存在块级作用域。为了更好理解 let 和 var 的不同，我们可以看下面这个例子：</p>
<figure class="highlight javascript"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="string">&quot;global a&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> b = <span class="string">&quot;global b&quot;</span>;</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">let</span> b = <span class="string">&quot;block b&quot;</span>;</span><br><span class="line">  <span class="keyword">var</span> c = <span class="string">&quot;block c&quot;</span>;</span><br><span class="line">  <span class="keyword">let</span> d = <span class="string">&quot;block d&quot;</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(a);</span><br><span class="line">  <span class="built_in">console</span>.log(b);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(b);</span><br><span class="line"><span class="built_in">console</span>.log(c);</span><br><span class="line"><span class="built_in">console</span>.log(d);</span><br></pre></td></tr></table></div></figure>

<p>为了方便理解和观看，我将不再细分环境记录器和外部环境的引用，直接将词法环境当做整体来使用。</p>
<img src="/2022/02/20/%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87%E3%80%81%E4%BD%9C%E7%94%A8%E5%9F%9F%E3%80%81%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%93%BE%E5%92%8C%E9%97%AD%E5%8C%85/ES5-%E5%9D%97%E7%BA%A7%E4%BD%9C%E7%94%A8%E5%9F%9F-1.png" class>

<p>同样用画图来表示上面的代码：</p>
<ol>
<li><p>创建全局执行上下文，并压入栈。</p>
</li>
<li><p>创建词法环境，查找<strong>顶级</strong>const、let 变量声明。</p>
<p>所谓顶级的 const、let 变量声明，指的是<code>不在代码块中且不在函数中</code>的 const、let 变量声明。</p>
<p>找到变量 b，加入词法环境，但<strong>不初始化</strong>。</p>
<img src="/2022/02/20/%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87%E3%80%81%E4%BD%9C%E7%94%A8%E5%9F%9F%E3%80%81%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%93%BE%E5%92%8C%E9%97%AD%E5%8C%85/ES5-%E5%9D%97%E7%BA%A7%E4%BD%9C%E7%94%A8%E5%9F%9F-2.png" class></li>
<li><p>创建变量环境，查找<strong>非函数</strong>内的 var 变量声明。</p>
<p>因为 var 变量没有块级作用域的概念，所以无论是否在代码块中声明，都需要找出来。</p>
<p>找到变量 a、c，加入变量环境，初始化为 undefined。</p>
<img src="/2022/02/20/%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87%E3%80%81%E4%BD%9C%E7%94%A8%E5%9F%9F%E3%80%81%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%93%BE%E5%92%8C%E9%97%AD%E5%8C%85/ES5-%E5%9D%97%E7%BA%A7%E4%BD%9C%E7%94%A8%E5%9F%9F-3.png" class></li>
<li><p>没有函数声明。全局执行上下文创建完毕，开始执行代码。</p>
</li>
<li><p>执行<code>var a = &quot;global a&quot;</code>和<code>let b = &quot;global b&quot;</code>。</p>
<img src="/2022/02/20/%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87%E3%80%81%E4%BD%9C%E7%94%A8%E5%9F%9F%E3%80%81%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%93%BE%E5%92%8C%E9%97%AD%E5%8C%85/ES5-%E5%9D%97%E7%BA%A7%E4%BD%9C%E7%94%A8%E5%9F%9F-4.png" class></li>
<li><p>继续执行代码，这时遇到了代码块。</p>
<p><strong>注意：</strong></p>
<ul>
<li><p>执行代码块是<strong>不创建</strong>执行上下文的！</p>
</li>
<li><p>JS 引擎会将代码块中声明的 let、const 变量和函数存储在一个单独的区域。这块特殊区域就可以理解成<strong>块级作用域</strong>。</p>
</li>
<li><p>当代码块中的代码执行完，如果不存在外部引用，这块区域将<strong>被释放</strong>。</p>
</li>
<li><p>块级作用域也是一个词法环境。</p>
</li>
</ul>
<img src="/2022/02/20/%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87%E3%80%81%E4%BD%9C%E7%94%A8%E5%9F%9F%E3%80%81%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%93%BE%E5%92%8C%E9%97%AD%E5%8C%85/ES5-%E5%9D%97%E7%BA%A7%E4%BD%9C%E7%94%A8%E5%9F%9F-5.png" class></li>
<li><p>查找代码块中的 let、const 变量声明。</p>
<p>找到变量 b、d，加入到块级作用域，但不初始化。</p>
<img src="/2022/02/20/%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87%E3%80%81%E4%BD%9C%E7%94%A8%E5%9F%9F%E3%80%81%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%93%BE%E5%92%8C%E9%97%AD%E5%8C%85/ES5-%E5%9D%97%E7%BA%A7%E4%BD%9C%E7%94%A8%E5%9F%9F-6.png" class></li>
<li><p>没有函数声明。继续执行代码。</p>
</li>
<li><p>执行完<code>let b = &quot;block b&quot;</code>，执行<code>var c = &quot;block c&quot;</code>。</p>
<p><strong>注意：</strong></p>
<ul>
<li>在一个执行上下文中，JS 引擎的访问顺序是从词法环境到变量环境。</li>
<li>当执行到代码块中的语句时，则从块级作用域到词法环境再到变量环境。</li>
<li>如果存在代码块嵌套，则从最内部代码块生成的块级作用域到上一层代码块生成的块级作用域，一直到变量环境。</li>
<li>当代码块执行完毕，当前执行上下文将不再访问该块级作用域。</li>
</ul>
<p>在变量环境中找到变量 c 并赋值。</p>
<img src="/2022/02/20/%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87%E3%80%81%E4%BD%9C%E7%94%A8%E5%9F%9F%E3%80%81%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%93%BE%E5%92%8C%E9%97%AD%E5%8C%85/ES5-%E5%9D%97%E7%BA%A7%E4%BD%9C%E7%94%A8%E5%9F%9F-7.png" class></li>
<li><p>继续执行<code>let d = &quot;block d&quot;</code>。</p>
<img src="/2022/02/20/%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87%E3%80%81%E4%BD%9C%E7%94%A8%E5%9F%9F%E3%80%81%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%93%BE%E5%92%8C%E9%97%AD%E5%8C%85/ES5-%E5%9D%97%E7%BA%A7%E4%BD%9C%E7%94%A8%E5%9F%9F-8.png" class></li>
<li><p>然后开始输出打印，按照上面所说的访问顺序查找变量 a、b，输出打印<code>global a</code>和<code>block b</code>。</p>
</li>
<li><p>代码块执行完毕，由于不存在外部引用，块级作用域被释放。</p>
<img src="/2022/02/20/%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87%E3%80%81%E4%BD%9C%E7%94%A8%E5%9F%9F%E3%80%81%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%93%BE%E5%92%8C%E9%97%AD%E5%8C%85/ES5-%E5%9D%97%E7%BA%A7%E4%BD%9C%E7%94%A8%E5%9F%9F-9.png" class></li>
<li><p>继续执行<code>console.log(b)</code>，输出打印<code>global b</code>。执行<code>console.log(c)</code>，输出打印<code>block c</code>。执行<code>console.log(d)</code>，由于找不到 d，所以这一步会报错。最终结果：</p>
<img src="/2022/02/20/%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87%E3%80%81%E4%BD%9C%E7%94%A8%E5%9F%9F%E3%80%81%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%93%BE%E5%92%8C%E9%97%AD%E5%8C%85/ES5-%E5%9D%97%E7%BA%A7%E4%BD%9C%E7%94%A8%E5%9F%9F-10.png" class></li>
</ol>
<br>


        <h3 id="3-块级作用域中的函数声明">
          <a href="#3-块级作用域中的函数声明" class="heading-link"><i class="fas fa-link"></i></a><a href="#3-块级作用域中的函数声明" class="headerlink" title="(3) 块级作用域中的函数声明"></a>(3) 块级作用域中的函数声明</h3>
      <p>JS 引擎在创建执行上下文时，对于代码块中的函数声明和非代码块中的函数声明有不同的处理方式：</p>
<ul>
<li><p>非代码块中的函数声明：</p>
<p>将函数名添加到变量环境，并初始化为 function。</p>
</li>
<li><p>代码块中的函数声明：</p>
<p>如果当前执行上下文中的词法环境和变量环境中存在同名变量或函数，则<strong>不进行任何操作</strong>。否则，将函数名添加到变量环境，并初始化为<strong>undefined</strong>。</p>
</li>
</ul>
<p>我们用几个例子演示一下：</p>
<figure class="highlight javascript"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 示例1</span></span><br><span class="line"><span class="built_in">console</span>.log(test); <span class="comment">// 输出的是undefined</span></span><br><span class="line"><span class="keyword">var</span> test = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 示例2</span></span><br><span class="line"><span class="built_in">console</span>.log(test); <span class="comment">// 报错，test未初始化</span></span><br><span class="line"><span class="keyword">let</span> test = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 示例3</span></span><br><span class="line"><span class="built_in">console</span>.log(test); <span class="comment">// 输出的是代码块外面的函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 示例4</span></span><br><span class="line"><span class="built_in">console</span>.log(test); <span class="comment">// 输出的是undefined</span></span><br><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>接着在执行上下文的执行阶段，当执行到代码块时，查找代码块中的函数声明，添加到块级作用域，并初始化为 function。当代码块执行完，查找<strong>变量环境</strong>中是否存在同名变量，如果存在，让它<strong>引用该函数对象</strong>。</p>
<p>用画图的方式解释一下：</p>
<figure class="highlight javascript"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> i = <span class="number">0</span>;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(i);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">test();</span><br></pre></td></tr></table></div></figure>

<ol>
<li><p>创建全局执行上下文并压入栈。</p>
</li>
<li><p>创建词法环境，查找顶级 let、const 声明的变量：无。</p>
</li>
<li><p>创建变量环境，查找非函数体内 var 声明的变量：无。查找函数声明：找到块中的 test 函数，由于处于代码块当中，所以将函数名添加到变量环境中，并初始化为 undefined。</p>
<img src="/2022/02/20/%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87%E3%80%81%E4%BD%9C%E7%94%A8%E5%9F%9F%E3%80%81%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%93%BE%E5%92%8C%E9%97%AD%E5%8C%85/ES5-%E5%9D%97%E7%BA%A7%E4%BD%9C%E7%94%A8%E5%9F%9F-11.png" class></li>
<li><p>全局执行上下文创建完毕，开始执行代码。</p>
</li>
<li><p>执行到代码块，生成块作用域。查找代码块中的 let、const 声明：i，但不初始化；查找函数声明，找到 test 函数，初始化为 function。</p>
<img src="/2022/02/20/%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87%E3%80%81%E4%BD%9C%E7%94%A8%E5%9F%9F%E3%80%81%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%93%BE%E5%92%8C%E9%97%AD%E5%8C%85/ES5-%E5%9D%97%E7%BA%A7%E4%BD%9C%E7%94%A8%E5%9F%9F-12.png" class></li>
<li><p>继续执行代码<code>let i = 0</code>。</p>
<img src="/2022/02/20/%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87%E3%80%81%E4%BD%9C%E7%94%A8%E5%9F%9F%E3%80%81%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%93%BE%E5%92%8C%E9%97%AD%E5%8C%85/ES5-%E5%9D%97%E7%BA%A7%E4%BD%9C%E7%94%A8%E5%9F%9F-13.png" class></li>
<li><p>代码块执行完毕，查找变量环境中是否存在 test 变量，存在则让其引用 test 函数对象。</p>
<p>注意：由于函数创建时会保存当时的执行环境，所以 test 函数体内存在对 if 块作用域的引用，而变量环境中的 test 又引用了 test 函数对象，所以即使这个代码块执行完，if 块作用域也不会被释放。这就和我们上面讲闭包时一样。</p>
<img src="/2022/02/20/%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87%E3%80%81%E4%BD%9C%E7%94%A8%E5%9F%9F%E3%80%81%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%93%BE%E5%92%8C%E9%97%AD%E5%8C%85/ES5-%E5%9D%97%E7%BA%A7%E4%BD%9C%E7%94%A8%E5%9F%9F-14.png" class></li>
<li><p>继续执行代码，调用 test 函数。</p>
<p>注意：代码块执行完后，全局上下文就不能访问块级作用域了，所以这个 test 函数是变量环境中的 test 函数，而不是 if 块作用域中的 test 函数。</p>
</li>
<li><p>创建 test 函数执行上下文，并压入栈。</p>
</li>
<li><p>…（test 函数执行上下文创建过程省略）</p>
<img src="/2022/02/20/%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87%E3%80%81%E4%BD%9C%E7%94%A8%E5%9F%9F%E3%80%81%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%93%BE%E5%92%8C%E9%97%AD%E5%8C%85/ES5-%E5%9D%97%E7%BA%A7%E4%BD%9C%E7%94%A8%E5%9F%9F-15.png" class></li>
<li><p>开始执行代码<code>console.log(i)</code>，在 if 块作用域中找到变量 i，输出打印<code>0</code>。</p>
</li>
<li><p>…（test 函数执行上下文销毁阶段省略）</p>
</li>
</ol>
<p>有兴趣的可以同样用画图的方式，理解一下以下代码：</p>
<figure class="highlight javascript"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 示例1</span></span><br><span class="line"><span class="built_in">console</span>.log(test); <span class="comment">// 输出的是undefined</span></span><br><span class="line"><span class="keyword">var</span> test = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(test); <span class="comment">// 输出的是function</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 示例2</span></span><br><span class="line"><span class="keyword">let</span> test = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(test); <span class="comment">// 输出的是0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 示例3</span></span><br><span class="line"><span class="built_in">console</span>.log(test); <span class="comment">// 输出的是代码块外面的函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(test); <span class="comment">// 输出的是代码块内部的函数</span></span><br></pre></td></tr></table></div></figure>

<br>


        <h2 id="4-总结-1">
          <a href="#4-总结-1" class="heading-link"><i class="fas fa-link"></i></a><a href="#4-总结-1" class="headerlink" title="4.总结"></a>4.总结</h2>
      <p>我们会发现，ES5 标准的执行上下文与 ES3 标准并无太多区别，只是用词法环境/变量环境去替代了变量对象，多了一个针对 let、const 声明的变量的处理，以及块级作用域的处理。在 ES5 标准中，可以将作用域理解成词法环境。</p>
<p>随着 ES 标准的不断更新，执行上下文的内容也在发生变化，比如：在最新的 ES6 标准中，词法环境用于存储<strong>函数声明</strong>和 const、let 声明的变量，而变量环境只存储 var 声明的变量；而 ES9 中的执行上下文又与上文有所区别。感兴趣的可以自行了解。以上内容仅供理解，如有错误，欢迎指正。</p>
<br>


        <h1 id="五-Q-amp-A">
          <a href="#五-Q-amp-A" class="heading-link"><i class="fas fa-link"></i></a><a href="#五-Q-amp-A" class="headerlink" title="五.Q&amp;A"></a>五.Q&amp;A</h1>
      <ol>
<li><p>作用域和执行上下文有什么区别？</p>
<p>答：我个人认为这两个是包含关系，执行上下文中包含了作用域，同时还有其他像 this 绑定等内容。</p>
</li>
<li><p>什么是作用域？</p>
<p>答：根据不同的标准，对作用域的理解是不同的，ES3 的标准中，作用域可以理解为变量对象；而在 ES5 标准中，作用域可以理解为词法环境。</p>
</li>
<li><p>函数的作用域链是什么时候建立的？</p>
<p>答：我认为，函数没有作用域链的概念，作用域链是执行上下文中的内容。而函数只有一个[[scope]]属性，它在函数创建的时候就保存了当时的执行环境。当函数被调用时，函数执行上下文会根据[[scope]]创建作用域链。这个问题中的作用域链，应该指的是函数[[scope]]属性，它是在函数创建的时候建立的。</p>
</li>
</ol>
<br>

<blockquote>
<p>参考视频：</p>
<p>ES3 标准：<span class="exturl"><a class="exturl__link" target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1C54y1r7VS">https://www.bilibili.com/video/BV1C54y1r7VS</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
<p>ES5 标准：<span class="exturl"><a class="exturl__link" target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1wD4y1D7Pp">https://www.bilibili.com/video/BV1wD4y1D7Pp</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
<p>参考文章：</p>
<p><span class="exturl"><a class="exturl__link" target="_blank" rel="noopener" href="https://www.cnblogs.com/echolun/p/11438363.html">https://www.cnblogs.com/echolun/p/11438363.html</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
<p><span class="exturl"><a class="exturl__link" target="_blank" rel="noopener" href="https://juejin.cn/post/7043408377661095967">https://juejin.cn/post/7043408377661095967</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
<p><span class="exturl"><a class="exturl__link" target="_blank" rel="noopener" href="https://blog.csdn.net/feral_coder/article/details/106447013">https://blog.csdn.net/feral_coder/article/details/106447013</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
<p><span class="exturl"><a class="exturl__link" target="_blank" rel="noopener" href="https://www.zhihu.com/question/36751764">https://www.zhihu.com/question/36751764</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
<p><span class="exturl"><a class="exturl__link" target="_blank" rel="noopener" href="http://www.ruanyifeng.com/blog/2009/08/learning_javascript_closures.html">http://www.ruanyifeng.com/blog/2009/08/learning_javascript_closures.html</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
<p><span class="exturl"><a class="exturl__link" target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000018605776">https://segmentfault.com/a/1190000018605776</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
</blockquote>
</div></div></article></section><nav class="paginator"><div class="paginator-inner"><span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/"><i class="fas fa-angle-right"></i></a></div></nav></div></div><div class="sidebar-wrap" id="sidebar-wrap"><aside class="sidebar" id="sidebar"><section class="sidebar-toc hide"></section><!-- ov = overview--><section class="sidebar-ov"><div class="sidebar-ov-author"><div class="sidebar-ov-author__avatar"><img class="sidebar-ov-author__avatar_img" src="/image/site/head.png" alt="avatar"></div><p class="sidebar-ov-author__text">hello world</p></div><div class="sidebar-ov-social"><a class="sidebar-ov-social-item" href="https://github.com/LonelyTaker" target="_blank" rel="noopener" data-popover="Github" data-popover-pos="up"><span class="sidebar-ov-social-item__icon"><i class="fab fa-github"></i></span></a><a class="sidebar-ov-social-item" href="Ym1104340863" target="_blank" rel="noopener" data-popover="微信" data-popover-pos="up"><span class="sidebar-ov-social-item__icon"><i class="fab fa-weixin"></i></span></a><a class="sidebar-ov-social-item" href="1104340863" target="_blank" rel="noopener" data-popover="QQ" data-popover-pos="up"><span class="sidebar-ov-social-item__icon"><i class="fab fa-qq"></i></span></a></div><div class="sidebar-ov-state"><a class="sidebar-ov-state-item sidebar-ov-state-item--posts" href="/archives/"><div class="sidebar-ov-state-item__count">14</div><div class="sidebar-ov-state-item__name">归档</div></a><a class="sidebar-ov-state-item sidebar-ov-state-item--categories" href="/categories/"><div class="sidebar-ov-state-item__count">4</div><div class="sidebar-ov-state-item__name">分类</div></a><a class="sidebar-ov-state-item sidebar-ov-state-item--tags" href="/tags/"><div class="sidebar-ov-state-item__count">4</div><div class="sidebar-ov-state-item__name">标签</div></a></div><div class="sidebar-ov-cc"><a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.en" target="_blank" rel="noopener" data-popover="知识共享许可协议" data-popover-pos="up"><img src="/images/cc-by-nc-sa.svg"></a></div></section></aside></div><div class="clearfix"></div></div></main><footer class="footer" id="footer"><div class="footer-inner"><div><span>Copyright © 2022</span><span class="footer__icon"><i class="fas fa-heart"></i></span><span>LonelyTaker</span></div><div><span>由 <a href="http://hexo.io/" title="Hexo" target="_blank" rel="noopener">Hexo</a> 强力驱动</span><span> v6.0.0</span></div></div></footer><div class="loading-bar" id="loading-bar"><div class="loading-bar__progress"></div></div><div class="back2top" id="back2top"><span class="back2top__icon"><i class="fas fa-rocket"></i></span></div></div><script src="https://cdn.jsdelivr.net/npm/jquery@v3.4.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@1.5.2/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@1.5.2/velocity.ui.min.js"></script><script src="/js/utils.js?v=2.6.2"></script><script src="/js/stun-boot.js?v=2.6.2"></script><script src="/js/scroll.js?v=2.6.2"></script><script src="/js/header.js?v=2.6.2"></script><script src="/js/sidebar.js?v=2.6.2"></script></body></html>
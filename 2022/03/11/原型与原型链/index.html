<!DOCTYPE html><html lang="zh-CN" theme-mode="dark"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><title>原型与原型链 | LonelyTaker's Blog</title><link rel="icon" type="image/x-icon" href="/favicon.ico"><link rel="preload" as="font" crossorigin="anonymous" href="/font/Bender.ttf"><link rel="preload" as="font" crossorigin="anonymous" href="/font/BenderLight.ttf"><link rel="preload" as="font" crossorigin="anonymous" href="/font/JetBrainsMono-Regular.woff2"><link rel="stylesheet" href="/css/arknights.css"><style>@font-face {
  font-family: Bender;
  src: local('Bender'), url("/font/Bender.ttf"), url("/font/Bender.otf");
}
@font-face {
  font-family: BenderLight;
  src: local('BenderLight'), url("/font/BenderLight.ttf");
}
@font-face {
  font-family: 'JetBrains Mono';
  src: local('JetBrains Mono'), url('/font/JetBrainsMono-Regular.woff2') format('woff2');
}
</style><script>var config = {"root":"/","search":{"preload":false,"activeHolder":"Enter here","blurHolder":"Search","noResult":"Data \"$0\" not found"},"code":{"codeInfo":"$0 - $1 lines","copy":"copy"}}</script><link type="text/css" rel="stylesheet" href="/lib/encrypt/hbe.style.css"><script src="//unpkg.com/mermaid@10.5.0/dist/mermaid.min.js"></script><link type="text/css" rel="stylesheet" href="//unpkg.com/lightgallery@2.7.1/css/lightgallery.css"><link type="text/css" rel="stylesheet" href="//unpkg.com/lightgallery@2.7.1/css/lg-zoom.css"><link type="text/css" rel="stylesheet" href="//unpkg.com/lightgallery@2.7.1/css/lg-thumbnail.css"><link type="text/css" rel="stylesheet" href="/lib/fontawesome/css/all.min.css"><script>if (window.localStorage.getItem('theme-mode') === 'light')
 document.documentElement.setAttribute('theme-mode', 'light')
if (window.localStorage.getItem('theme-mode') === 'dark')
 document.documentElement.setAttribute('theme-mode', 'dark')</script><style>@font-face {
 font-family: BenderLight;
 src: local('Bender'), url("/font/BenderLight.woff2") format('woff2');
}
@font-face {
 font-family: 'JetBrains Mono';
 src: local('JetBrains Mono'), url('/font/JetBrainsMono-Regular.woff2') format('woff2');
}</style><style>:root {
 --dark-background: url('https://ak.hypergryph.com/assets/index/images/ak/pc/bk.jpg');
 --light-background: url('/img/bk.jpg');
 --theme-encrypt-confirm: 'confirm'
}</style><script defer src="/js/arknights.js"></script><script defer src="/js/search.js"></script><script defer type="module">import mermaid from '//unpkg.com/mermaid@10.5.0/dist/mermaid.esm.mjs';
window.mermaid = mermaid;
code.paintMermaid();
</script><script async src="//unpkg.com/lightgallery@2.7.1/lightgallery.min.js"></script><script async src="//unpkg.com/lightgallery@2.7.1/plugins/zoom/lg-zoom.min.js"></script><script async src="//unpkg.com/lightgallery@2.7.1/plugins/thumbnail/lg-thumbnail.min.js"></script><script async src="/lib/encrypt/hbe.js"></script><script async src="/js/pjax.js"></script><script class="pjax-js">reset= () => {document.querySelector('.lg-container')?.remove()
lightGallery(document.getElementById('post-bg'), {
  plugins: [lgZoom,lgThumbnail],
  selector: '.item-img'})}</script><script>window.addEventListener("load",() => {pjax = new Pjax({
 cacheBust: false,
 selectors: ['title','article','#aside-block','.pjax-js','data-pjax','.busuanzi'],
 switches: {'article': Pjax.switches.sideBySide},
 switchesOptions: {
   'article': {
     classNames: {
       remove: "pjax-out",
       add: "pjax-in"
     }
   }
 }
});
document.addEventListener("pjax:complete", reset);reset()})</script><script class="pjax-js">reset= () => {document.querySelector('.lg-container')?.remove()
lightGallery(document.getElementById('post-bg'), {
  plugins: [lgZoom,lgThumbnail],
  selector: '.item-img'})}</script><script>window.addEventListener("load",() => {pjax = new Pjax({
 cacheBust: false,
 selectors: ['title','article','#aside-block','.pjax-js'],
 switches: {'article': Pjax.switches.sideBySide},
 switchesOptions: {
   'article': {
     classNames: {
       remove: "pjax-out",
       add: "pjax-in"
     }
   }
 }
});
document.addEventListener("pjax:complete", reset);reset()})</script><meta name="generator" content="Hexo 7.3.0"></head><body><div class="loading" style="opacity: 0;"><div class="loadingBar left"></div><div class="loadingBar right"></div></div><main><header class="closed"><div class="navBtn"><i class="navBtnIcon"><span class="navBtnIconBar"></span><span class="navBtnIconBar"></span><span class="navBtnIconBar"></span></i></div><nav><div class="navItem" id="search-header"><span class="navItemTitle"><input autocomplete="off" autocorrect="off" autocapitalize="none" placeholder="Search" spellcheck="false" maxlength="50" type="text" id="search-input"></span></div><div class="navItem" id="search-holder"></div><div class="search-popup" tabindex="0"><div id="search-result"></div></div><ol class="navContent"><li class="navItem"><a class="navBlock" href="/"><span class="navItemTitle">Home</span></a></li><li class="navItem" matchdata="categories,tags"><a class="navBlock" href="/archives/"><span class="navItemTitle">Archives</span></a></li></ol></nav></header><article><div id="post-bg"><div id="post-title"><h1>原型与原型链</h1></div><hr><div id="post-content"><h1 id="1-前置知识"><a href="#1-前置知识" class="headerlink" title="1.前置知识"></a>1.前置知识</h1><p>在聊原型和原型链之前，我们需要知道几个概念：构造函数和普通函数、函数对象和实例对象。</p>
<br />

<h2 id="1-构造函数和普通函数"><a href="#1-构造函数和普通函数" class="headerlink" title="(1) 构造函数和普通函数"></a>(1) 构造函数和普通函数</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Test</span>(<span class="hljs-params">hi</span>)&#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">hi</span> = hi<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">hi</span>);<br>&#125;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">test</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;这是普通函数&quot;</span>);<br>&#125;<br><span class="hljs-keyword">var</span> t = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Test</span>(<span class="hljs-string">&quot;这是构造函数&quot;</span>);<br><span class="hljs-title function_">test</span>();<br></code></pre></td></tr></table></figure>

<p>在函数声明的时候，无法判断一个函数是否为构造函数。只有使用<code>new</code>操作符创建对象时，调用的函数才叫做构造函数。</p>
<p>两者区别：</p>
<ol>
<li><p>作用不同</p>
<p>普通函数的作用自然是执行函数体内的代码以实现某种功能。构造函数的作用是用来创建对象。</p>
</li>
<li><p>调用方式不同</p>
<p>普通函数直接调用：<code>函数名()</code></p>
<p>构造函数是为了创建对象，所以需要使用<code>new</code>关键字来调用：<code>new 函数名()</code></p>
</li>
<li><p>书写习惯不同</p>
<p>为了区别普通函数和构造函数，构造函数的函数名一般大写开头。</p>
</li>
<li><p>this指向不同</p>
<p>普通函数中的this指向window对象，构造函数中的this则是指向它创建的对象。</p>
</li>
<li><p>写法不同</p>
<p>构造函数中一般不写<code>return</code>。</p>
</li>
</ol>
<p>所以上述代码中<code>test</code>为普通函数，<code>Test</code>为构造函数。</p>
<br />

<h2 id="2-函数对象和实例对象"><a href="#2-函数对象和实例对象" class="headerlink" title="(2) 函数对象和实例对象"></a>(2) 函数对象和实例对象</h2><p>以下面的代码为例：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Student</span>(<span class="hljs-params">name</span>)&#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name;<br>&#125;<br><span class="hljs-keyword">var</span> st1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>(<span class="hljs-string">&#x27;小明&#x27;</span>);<br></code></pre></td></tr></table></figure>

<p>在JavaScript中，函数也是对象，所以从这个角度讲，上述代码中<code>Student</code>构造函数也称为函数对象，而通过<code>new</code>操作符创建的对象，称为实例对象，上述代码中<code>st1</code>就是通过<code>Student</code>构造函数创建的实例对象。</p>
<blockquote>
<p>不仅仅是构造函数，任何函数从对象的角度讲或者当做对象去使用时，都可以称为函数对象。</p>
<p>这里所说的函数对象不是JS内置的Function对象。</p>
</blockquote>
<br />

<h1 id="2-原型"><a href="#2-原型" class="headerlink" title="2.原型"></a>2.原型</h1><p>什么是原型？我们还是通过上面的代码来讲解：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Student</span>(<span class="hljs-params">name</span>)&#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name;<br>&#125;<br><span class="hljs-keyword">var</span> st1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>(<span class="hljs-string">&#x27;小明&#x27;</span>);<br></code></pre></td></tr></table></figure>

<p>假设现在我们需要给<code>st1</code>添加一个<code>speak</code>方法，可以这么做：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Student</span>(<span class="hljs-params">name</span>)&#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name;<br>&#125;<br><span class="hljs-keyword">var</span> st1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>(<span class="hljs-string">&#x27;小明&#x27;</span>);<br>st1.<span class="hljs-property">speak</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;my name is&quot;</span>, <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>);<br>&#125;<br>st1.<span class="hljs-title function_">speak</span>();    <span class="hljs-comment">// my name is 小明</span><br></code></pre></td></tr></table></figure>

<p>但假如我要给每一个<code>Student</code>创建出来的实例对象都添加上这个<code>speak</code>方法，可以这么做：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Student</span>(<span class="hljs-params">name</span>)&#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">speak</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;my name is&quot;</span>, <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>);<br>    &#125;<br>&#125;<br><span class="hljs-keyword">var</span> st1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>(<span class="hljs-string">&#x27;小明&#x27;</span>);<br><span class="hljs-keyword">var</span> st2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>(<span class="hljs-string">&#x27;小红&#x27;</span>);<br>st1.<span class="hljs-title function_">speak</span>();    <span class="hljs-comment">// my name is 小明</span><br>st2.<span class="hljs-title function_">speak</span>();    <span class="hljs-comment">// my name is 小红</span><br></code></pre></td></tr></table></figure>

<p>这种方式每创建一个实例对象，就会创建一个新的<code>speak</code>方法，也就是说每个实例对象的<code>speak</code>方法都是唯一的。</p>
<p class='item-img' data-src='/2022/03/11/%E5%8E%9F%E5%9E%8B%E4%B8%8E%E5%8E%9F%E5%9E%8B%E9%93%BE/%E5%8E%9F%E5%9E%8B-1.png'><img src="/2022/03/11/%E5%8E%9F%E5%9E%8B%E4%B8%8E%E5%8E%9F%E5%9E%8B%E9%93%BE/%E5%8E%9F%E5%9E%8B-1.png" alt="原型-1"></p>
<p>但这种方式有个问题：如果我们创建出来的实例对象越来越多，在内存中占用的空间是不是也越来越多。</p>
<p>我们仔细想想，这个<code>speak</code>方法需要每个实例对象都唯一吗？能不能共用一个？答案是可以共用，因为每个实例对象的<code>speak</code>方法做的事情都是一样的。</p>
<p>那么我们要怎么修改呢？可以这么做：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Student</span>(<span class="hljs-params">name</span>)&#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">speak</span> = _speak;<br>&#125;<br><span class="hljs-comment">// 将方法提取到全局作用域下</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">_speak</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;my name is&quot;</span>, <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>);<br>&#125;<br><span class="hljs-keyword">var</span> st1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>(<span class="hljs-string">&#x27;小明&#x27;</span>);<br><span class="hljs-keyword">var</span> st2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>(<span class="hljs-string">&#x27;小红&#x27;</span>);<br>st1.<span class="hljs-title function_">speak</span>();    <span class="hljs-comment">// my name is 小明</span><br>st2.<span class="hljs-title function_">speak</span>();    <span class="hljs-comment">// my name is 小红</span><br></code></pre></td></tr></table></figure>

<p>这时候的内存空间：</p>
<p class='item-img' data-src='/2022/03/11/%E5%8E%9F%E5%9E%8B%E4%B8%8E%E5%8E%9F%E5%9E%8B%E9%93%BE/%E5%8E%9F%E5%9E%8B-2.png'><img src="/2022/03/11/%E5%8E%9F%E5%9E%8B%E4%B8%8E%E5%8E%9F%E5%9E%8B%E9%93%BE/%E5%8E%9F%E5%9E%8B-2.png" alt="原型-2"></p>
<p>这种方式看上去很不错，但是仍然会带来一些问题：</p>
<ol>
<li><code>_speak</code>是在全局作用域下声明的，可能会污染全局作用域（变量冲突）。</li>
<li>随着全局作用域下的函数声明越来越多，全局作用域会变得越来越臃肿。</li>
</ol>
<br />

<p>因此，JS就提出了原型的概念。每一个函数对象身上都有一个<code>prototype</code>属性，该属性指向一个对象。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Student</span>(<span class="hljs-params">name</span>)&#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name;<br>&#125;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Student</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>);    <span class="hljs-comment">// Object</span><br></code></pre></td></tr></table></figure>

<p>这个对象叫做<strong>原型对象</strong>，每个函数对象都有自己的原型对象。</p>
<blockquote>
<p>不管是构造函数还是普通函数，都有<code>prototype</code>属性，只不过在普通函数上这一个属性没有什么作用。所以在讲原型时，我们比较强调构造函数，下文中的函数对象也都指构造函数。</p>
</blockquote>
<p>另外，创建实例对象时，实例对象身上会有一个属性<code>__proto__</code>，它指向创建该实例对象的函数对象的原型对象。同一个函数对象创建的每一个实例对象，它们的<code>__proto__</code>属性都指向同一个原型对象。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Student</span>(<span class="hljs-params">name</span>)&#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name;<br>&#125;<br><span class="hljs-keyword">var</span> st1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>(<span class="hljs-string">&quot;小明&quot;</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Student</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> === st1.<span class="hljs-property">__proto__</span>);  <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure>

<p class='item-img' data-src='/2022/03/11/%E5%8E%9F%E5%9E%8B%E4%B8%8E%E5%8E%9F%E5%9E%8B%E9%93%BE/%E5%8E%9F%E5%9E%8B-3.png'><img src="/2022/03/11/%E5%8E%9F%E5%9E%8B%E4%B8%8E%E5%8E%9F%E5%9E%8B%E9%93%BE/%E5%8E%9F%E5%9E%8B-3.png" alt="原型-3"></p>
<p>这就意味着，如果我们在函数对象的原型对象中添加属性和方法，该函数对象创建的实例对象也可以访问到。JS就是这么做的，JS中对于对象属性和方法的访问顺序是从对象本身到对象的原型，如果对象本身中就有要找的属性或方法，直接使用对象本身中的属性或方法，否则从对象的原型中找。比如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Student</span>(<span class="hljs-params">name</span>)&#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name;<br>&#125;<br><span class="hljs-title class_">Student</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">school</span> = <span class="hljs-string">&quot;xx大学&quot;</span>;<br><span class="hljs-keyword">var</span> st1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>(<span class="hljs-string">&quot;小明&quot;</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(st1.<span class="hljs-property">school</span>);    <span class="hljs-comment">// xx大学</span><br>st1.<span class="hljs-property">school</span> = <span class="hljs-string">&quot;yy大学&quot;</span>;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(st1.<span class="hljs-property">school</span>);    <span class="hljs-comment">// yy大学</span><br></code></pre></td></tr></table></figure>

<p class='item-img' data-src='/2022/03/11/%E5%8E%9F%E5%9E%8B%E4%B8%8E%E5%8E%9F%E5%9E%8B%E9%93%BE/%E5%8E%9F%E5%9E%8B-4.png'><img src="/2022/03/11/%E5%8E%9F%E5%9E%8B%E4%B8%8E%E5%8E%9F%E5%9E%8B%E9%93%BE/%E5%8E%9F%E5%9E%8B-4.png" alt="原型-4"></p>
<p class='item-img' data-src='/2022/03/11/%E5%8E%9F%E5%9E%8B%E4%B8%8E%E5%8E%9F%E5%9E%8B%E9%93%BE/%E5%8E%9F%E5%9E%8B-5.png'><img src="/2022/03/11/%E5%8E%9F%E5%9E%8B%E4%B8%8E%E5%8E%9F%E5%9E%8B%E9%93%BE/%E5%8E%9F%E5%9E%8B-5.png" alt="原型-5"></p>
<p>那么为了实现我们上面所说的对于<code>speak</code>方法的操作，可以这么做：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Student</span>(<span class="hljs-params">name</span>)&#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name;<br>&#125;<br><span class="hljs-title class_">Student</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">speak</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;my name is&quot;</span>, <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>);<br>&#125;<br><span class="hljs-keyword">var</span> st1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>(<span class="hljs-string">&#x27;小明&#x27;</span>);<br><span class="hljs-keyword">var</span> st2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>(<span class="hljs-string">&#x27;小红&#x27;</span>);<br>st1.<span class="hljs-title function_">speak</span>();    <span class="hljs-comment">// my name is 小明</span><br>st2.<span class="hljs-title function_">speak</span>();    <span class="hljs-comment">// my name is 小红</span><br></code></pre></td></tr></table></figure>

<p class='item-img' data-src='/2022/03/11/%E5%8E%9F%E5%9E%8B%E4%B8%8E%E5%8E%9F%E5%9E%8B%E9%93%BE/%E5%8E%9F%E5%9E%8B-6.png'><img src="/2022/03/11/%E5%8E%9F%E5%9E%8B%E4%B8%8E%E5%8E%9F%E5%9E%8B%E9%93%BE/%E5%8E%9F%E5%9E%8B-6.png" alt="原型-6"></p>
<p>再补充一点，原型对象在函数声明时一同创建，然后挂载到函数对象的<code>prototype</code>属性上，另外原型对象上有一个<code>constructor</code>属性，指向创建它的函数对象，这样两者的关系就紧密结合起来了。</p>
<p>完整关系图：</p>
<p class='item-img' data-src='/2022/03/11/%E5%8E%9F%E5%9E%8B%E4%B8%8E%E5%8E%9F%E5%9E%8B%E9%93%BE/%E5%8E%9F%E5%9E%8B-7.png'><img src="/2022/03/11/%E5%8E%9F%E5%9E%8B%E4%B8%8E%E5%8E%9F%E5%9E%8B%E9%93%BE/%E5%8E%9F%E5%9E%8B-7.png" alt="原型-7"></p>
<p>总结：</p>
<ol>
<li>函数对象上有一个<code>prototype</code>属性，该属性称为显示原型。它指向一个对象，该对象称为原型对象。</li>
<li>函数对象创建的每个实例对象都有一个 <code>__proto__</code>属性 ，该属性称为隐式原型。它指向创建该实例对象的函数对象的原型对象。</li>
<li>原型对象上有一个<code>constructor</code>属性，它指向创建该原型对象的函数对象。</li>
</ol>
<p>所以原型就是一个对象，它的作用是所有实例对象共享属性和方法。</p>
<blockquote>
<p>一般是共享方法，因为属性一般都是实例对象独有的，不同实例对象他们的属性不同，比如上面的<code>st1</code>和<code>st2</code>，他们的<code>name</code>属性各不相同，不应该把<code>name</code>放入<code>Student</code>原型对象中。</p>
</blockquote>
<blockquote>
<p>有些人可能会问：为什么一定要通过函数对象的<code>prototype</code>往原型对象上添加方法和属性，能不能通过实例对象的<code>__proto__</code>去添加呢？答案是不行的，实例对象的<code>__proto__</code>属性的意义在于为对象的查找机制提供一个方向或者说一条线路，但它是一个非标准属性，因此实际开发中不可以使用这个属性，这也是为什么称它为隐式原型的原因。</p>
</blockquote>
<br />

<h1 id="3-原型链"><a href="#3-原型链" class="headerlink" title="3.原型链"></a>3.原型链</h1><p>理解了原型之后，原型链理解起来就比较容易。我们还是从上面的例子入手：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Student</span>(<span class="hljs-params">name</span>)&#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name;<br>&#125;<br><span class="hljs-title class_">Student</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">speak</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;my name is&quot;</span>, <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>);<br>&#125;<br><span class="hljs-keyword">var</span> st1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>(<span class="hljs-string">&#x27;小明&#x27;</span>);<br>st1.<span class="hljs-title function_">speak</span>();    <span class="hljs-comment">// my name is 小明</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(st1.<span class="hljs-title function_">toString</span>());    <span class="hljs-comment">// [object Object]</span><br></code></pre></td></tr></table></figure>

<p>我们会发现上述第九行代码，会输出<code>[object Object]</code>，也就是说<code>st1</code>能够执行<code>toString()</code>方法。但是<code>st1</code>这个实例对象本身和它<code>__proto__</code>所指向的原型对象上都没有这个方法。那这个方法是哪来的呢？</p>
<p>我们知道，<code>Object</code>对象是所有对象的“祖先”，既然原型对象也是一个对象，那它也不例外，所以其实<strong>原型对象是Object对象的实例对象</strong>。既然是实例对象，那它身上就会有一个<code>__proto__</code>属性，指向<code>Object</code>对象的原型对象。</p>
<p class='item-img' data-src='/2022/03/11/%E5%8E%9F%E5%9E%8B%E4%B8%8E%E5%8E%9F%E5%9E%8B%E9%93%BE/%E5%8E%9F%E5%9E%8B%E9%93%BE-1.png'><img src="/2022/03/11/%E5%8E%9F%E5%9E%8B%E4%B8%8E%E5%8E%9F%E5%9E%8B%E9%93%BE/%E5%8E%9F%E5%9E%8B%E9%93%BE-1.png" alt="原型链-1"></p>
<p>我们简化一下这张图：</p>
<p class='item-img' data-src='/2022/03/11/%E5%8E%9F%E5%9E%8B%E4%B8%8E%E5%8E%9F%E5%9E%8B%E9%93%BE/%E5%8E%9F%E5%9E%8B%E9%93%BE-2.png'><img src="/2022/03/11/%E5%8E%9F%E5%9E%8B%E4%B8%8E%E5%8E%9F%E5%9E%8B%E9%93%BE/%E5%8E%9F%E5%9E%8B%E9%93%BE-2.png" alt="原型链-2"></p>
<p>接着我们来看下<code>Object</code>对象的原型对象上有没有<code>toString()</code>方法：</p>
<p class='item-img' data-src='/2022/03/11/%E5%8E%9F%E5%9E%8B%E4%B8%8E%E5%8E%9F%E5%9E%8B%E9%93%BE/%E5%8E%9F%E5%9E%8B%E9%93%BE-3.png'><img src="/2022/03/11/%E5%8E%9F%E5%9E%8B%E4%B8%8E%E5%8E%9F%E5%9E%8B%E9%93%BE/%E5%8E%9F%E5%9E%8B%E9%93%BE-3.png" alt="原型链-3"></p>
<p>果然有，这说明了什么？说明JS对于对象属性和方法的查找规则是这样的：</p>
<p>先从对象本身去找，如果找不到，就去该对象的原型对象上去找，如果还是没有找到，就去原型对象的原型对象上去找……但原型对象不可能永无止境，<code>Object</code>对象的原型对象<code>__proto__</code>属性值为<code>null</code>，也就是说查找到<code>Object</code>对象的原型对象就结束了，如果还是没有找到，则返回<code>undefined</code>。</p>
<p class='item-img' data-src='/2022/03/11/%E5%8E%9F%E5%9E%8B%E4%B8%8E%E5%8E%9F%E5%9E%8B%E9%93%BE/%E5%8E%9F%E5%9E%8B%E9%93%BE-4.png'><img src="/2022/03/11/%E5%8E%9F%E5%9E%8B%E4%B8%8E%E5%8E%9F%E5%9E%8B%E9%93%BE/%E5%8E%9F%E5%9E%8B%E9%93%BE-4.png" alt="原型链-4"></p>
<p>像图上这条被<code>__proto__</code>链接起来的链式关系，就叫<strong>原型链</strong>。它直接反应了JS对于对象属性和方法的查找顺序。</p>
<br />

<h1 id="4-补充"><a href="#4-补充" class="headerlink" title="4.补充"></a>4.补充</h1><p>理解完了原型和原型链，我们再想一想，所有的函数都可以通过<code>new Function()</code>的方式创建，那么也就是说所有的函数都是<code>Function</code>对象的实例对象。既然是实例对象，那它身上就会有一个<code>__proto__</code>属性，并且这一属性指向<code>Function</code>对象的原型对象。</p>
<p class='item-img' data-src='/2022/03/11/%E5%8E%9F%E5%9E%8B%E4%B8%8E%E5%8E%9F%E5%9E%8B%E9%93%BE/Function%E5%AF%B9%E8%B1%A1-1.png'><img src="/2022/03/11/%E5%8E%9F%E5%9E%8B%E4%B8%8E%E5%8E%9F%E5%9E%8B%E9%93%BE/Function%E5%AF%B9%E8%B1%A1-1.png" alt="Function对象-1"></p>
<p>那么<code>Function</code>对象是谁的实例对象呢？</p>
<p>我们刚说所有函数都是<code>Function</code>对象的实例对象，而<code>Function</code>对象也是构造函数，那么不就成了<code>Function</code>对象创建了<code>Function</code>对象？其实不必太过纠结这一点，因为<code>Function</code>对象是JS的内置对象，在脚本还没开始执行，就已经创建好了。所以<code>Function.__proto__ === Function.prototype</code>，记住这一个特殊情况就好了。</p>
<p class='item-img' data-src='/2022/03/11/%E5%8E%9F%E5%9E%8B%E4%B8%8E%E5%8E%9F%E5%9E%8B%E9%93%BE/Function%E5%AF%B9%E8%B1%A1-2.png'><img src="/2022/03/11/%E5%8E%9F%E5%9E%8B%E4%B8%8E%E5%8E%9F%E5%9E%8B%E9%93%BE/Function%E5%AF%B9%E8%B1%A1-2.png" alt="Function对象-2"></p>
<blockquote>
<p><code>Object</code>对象和<code>Function</code>对象都是函数对象，也就是构造函数。只不过它们两个都是JS的内置对象，所以没有特别标注函数对象。</p>
</blockquote>
<p>这里有一张非常流行的关于原型的图，就是我们刚刚讲到的所有内容：</p>
<p class='item-img' data-src='/2022/03/11/%E5%8E%9F%E5%9E%8B%E4%B8%8E%E5%8E%9F%E5%9E%8B%E9%93%BE/%E5%8E%9F%E5%9E%8B%E5%92%8C%E5%8E%9F%E5%9E%8B%E9%93%BE.png'><img src="/2022/03/11/%E5%8E%9F%E5%9E%8B%E4%B8%8E%E5%8E%9F%E5%9E%8B%E9%93%BE/%E5%8E%9F%E5%9E%8B%E5%92%8C%E5%8E%9F%E5%9E%8B%E9%93%BE.png" alt="原型和原型链"></p>
<h1 id="5-继承"><a href="#5-继承" class="headerlink" title="5.继承"></a>5.继承</h1><p>继承是面向对象编程的一个概念。继承可以使子类具有父类的属性和方法，同时可以在子类中重新定义或追加属性和方法。继承是类与类之间的关系。</p>
<p>但是JavaScript并没有类的概念，只有对象。那怎么会有继承呢？因为JavaScript是非常灵活的，我们可以通过构造函数和原型来模拟类的继承。</p>
<blockquote>
<p>如果熟悉面向对象编程的语言，我们会发现JS中的构造函数和类有点相似。在ES6中，JS也提出了类的概念，但ES6中的类其实是一个语法糖，它的本质还是构造函数，感兴趣的可以自行了解。</p>
</blockquote>
<br />

<h2 id="1-通过构造函数继承属性"><a href="#1-通过构造函数继承属性" class="headerlink" title="(1) 通过构造函数继承属性"></a>(1) 通过构造函数继承属性</h2><p>假如我们现在有一个<code>Father</code>构造函数，并且希望有另一个构造函数继承<code>Father</code>构造函数，我们可以这么做：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 父构造函数</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Father</span>(<span class="hljs-params">name,age</span>)&#123;<br>    <span class="hljs-comment">// this 指向父构造函数的实例对象</span><br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">age</span> = age;<br>&#125;<br><span class="hljs-comment">// 子构造函数</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Son</span>(<span class="hljs-params">name,age</span>)&#123;<br>    <span class="hljs-comment">// this 指向子构造函数的实例对象</span><br>    <span class="hljs-comment">// 要想继承父构造函数的属性，必须调用父构造函数，并且将父构造函数中的this改为当前构造函数中的this</span><br>    <span class="hljs-title class_">Father</span>.<span class="hljs-title function_">call</span>(<span class="hljs-variable language_">this</span>, name, age);<br>&#125;<br><span class="hljs-keyword">var</span> son = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Son</span>(<span class="hljs-string">&#x27;小明&#x27;</span>, <span class="hljs-number">18</span>);<br></code></pre></td></tr></table></figure>

<p>但是这样还不够，因为这样<code>Son</code>构造函数只继承了<code>Father</code>构造函数的属性，没有继承<code>Father</code>构造函数的方法：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 父构造函数</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Father</span>(<span class="hljs-params">name,age</span>)&#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">age</span> = age;<br>&#125;<br><span class="hljs-title class_">Father</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">money</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">1000</span>);<br>&#125;<br><span class="hljs-comment">// 子构造函数</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Son</span>(<span class="hljs-params">name,age</span>)&#123;<br>    <span class="hljs-title class_">Father</span>.<span class="hljs-title function_">call</span>(<span class="hljs-variable language_">this</span>, name, age);<br>&#125;<br><span class="hljs-keyword">var</span> son = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Son</span>(<span class="hljs-string">&#x27;小明&#x27;</span>, <span class="hljs-number">18</span>);<br>son.<span class="hljs-title function_">money</span>();    <span class="hljs-comment">// 报错，son无法调用money方法，或者说根本找不到money方法</span><br></code></pre></td></tr></table></figure>

<p class='item-img' data-src='/2022/03/11/%E5%8E%9F%E5%9E%8B%E4%B8%8E%E5%8E%9F%E5%9E%8B%E9%93%BE/%E7%BB%A7%E6%89%BF-1.png'><img src="/2022/03/11/%E5%8E%9F%E5%9E%8B%E4%B8%8E%E5%8E%9F%E5%9E%8B%E9%93%BE/%E7%BB%A7%E6%89%BF-1.png" alt="继承-1"></p>
<p>接下去，我们就需要让<code>Son</code>构造函数继承<code>Father</code>构造函数的方法。</p>
<br />

<h2 id="2-通过原型对象继承方法"><a href="#2-通过原型对象继承方法" class="headerlink" title="(2) 通过原型对象继承方法"></a>(2) 通过原型对象继承方法</h2><p>由上面的图像结合原型链的知识，我们可以发现，如果让<code>Son</code>原型对象链接到<code>Father</code>原型对象，那我们<code>Son</code>构造函数创建的实例对象，是不是就可以使用<code>Father</code>原型对象上的方法了？</p>
<p class='item-img' data-src='/2022/03/11/%E5%8E%9F%E5%9E%8B%E4%B8%8E%E5%8E%9F%E5%9E%8B%E9%93%BE/%E7%BB%A7%E6%89%BF-2.png'><img src="/2022/03/11/%E5%8E%9F%E5%9E%8B%E4%B8%8E%E5%8E%9F%E5%9E%8B%E9%93%BE/%E7%BB%A7%E6%89%BF-2.png" alt="继承-2"></p>
<p>原型对象的链接是依靠<code>__proto__</code>属性去操作的，所以最简单的方式：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title class_">Son</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">__proto__</span> = <span class="hljs-title class_">Father</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>;<br></code></pre></td></tr></table></figure>

<p>但是我们说过<code>__proto__</code>属性不能直接使用。那有没有什么办法同样能实现上述代码的效果？我们可以这么做：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 父构造函数</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Father</span>(<span class="hljs-params">name,age</span>)&#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">age</span> = age;<br>&#125;<br><span class="hljs-title class_">Father</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">money</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">1000</span>);<br>&#125;<br><span class="hljs-comment">// 子构造函数</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Son</span>(<span class="hljs-params">name,age</span>)&#123;<br>    <span class="hljs-title class_">Father</span>.<span class="hljs-title function_">call</span>(<span class="hljs-variable language_">this</span>, name, age);<br>&#125;<br><span class="hljs-comment">// 将Son构造函数的prototype指向Father构造函数创建的实例对象</span><br><span class="hljs-comment">// 由于Father构造函数创建的实例对象中有__proto__属性，并且指向Father构造函数的原型对象</span><br><span class="hljs-comment">// 这样就达到了我们预先的目的</span><br><span class="hljs-title class_">Son</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Father</span>();<br><span class="hljs-keyword">var</span> son = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Son</span>(<span class="hljs-string">&#x27;小明&#x27;</span>, <span class="hljs-number">18</span>);<br>son.<span class="hljs-title function_">money</span>();    <span class="hljs-comment">// 1000</span><br></code></pre></td></tr></table></figure>

<p class='item-img' data-src='/2022/03/11/%E5%8E%9F%E5%9E%8B%E4%B8%8E%E5%8E%9F%E5%9E%8B%E9%93%BE/%E7%BB%A7%E6%89%BF-3.png'><img src="/2022/03/11/%E5%8E%9F%E5%9E%8B%E4%B8%8E%E5%8E%9F%E5%9E%8B%E9%93%BE/%E7%BB%A7%E6%89%BF-3.png" alt="继承-3"></p>
<p>这样<code>Father</code>构造函数创建的实例对象就变成了<code>Son</code>构造函数的原型对象，<code>Son</code>构造函数<code>new</code>出来的实例对象，也指向这一个<code>Father</code>构造函数创建的实例对象。从而达到我们预先的目的。</p>
<p class='item-img' data-src='/2022/03/11/%E5%8E%9F%E5%9E%8B%E4%B8%8E%E5%8E%9F%E5%9E%8B%E9%93%BE/%E7%BB%A7%E6%89%BF-4.png'><img src="/2022/03/11/%E5%8E%9F%E5%9E%8B%E4%B8%8E%E5%8E%9F%E5%9E%8B%E9%93%BE/%E7%BB%A7%E6%89%BF-4.png" alt="继承-4"></p>
<p>除此之外还差一步，我们原先说过原型对象中有一个<code>constructor</code>属性指向构造函数，我们修改了构造函数的原型对象，那就需要将新的原型对象中的<code>constructor</code>属性指向构造函数。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 父构造函数</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Father</span>(<span class="hljs-params">name,age</span>)&#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">age</span> = age;<br>&#125;<br><span class="hljs-title class_">Father</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">money</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">1000</span>);<br>&#125;<br><span class="hljs-comment">// 子构造函数</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Son</span>(<span class="hljs-params">name,age</span>)&#123;<br>    <span class="hljs-title class_">Father</span>.<span class="hljs-title function_">call</span>(<span class="hljs-variable language_">this</span>, name, age);<br>&#125;<br><span class="hljs-title class_">Son</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Father</span>();<br><span class="hljs-comment">// 修改constructor</span><br><span class="hljs-title class_">Son</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">constructor</span> = <span class="hljs-title class_">Son</span>;<br><span class="hljs-keyword">var</span> son = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Son</span>(<span class="hljs-string">&#x27;小明&#x27;</span>, <span class="hljs-number">18</span>);<br>son.<span class="hljs-title function_">money</span>();    <span class="hljs-comment">// 1000</span><br></code></pre></td></tr></table></figure>

<p class='item-img' data-src='/2022/03/11/%E5%8E%9F%E5%9E%8B%E4%B8%8E%E5%8E%9F%E5%9E%8B%E9%93%BE/%E7%BB%A7%E6%89%BF-5.png'><img src="/2022/03/11/%E5%8E%9F%E5%9E%8B%E4%B8%8E%E5%8E%9F%E5%9E%8B%E9%93%BE/%E7%BB%A7%E6%89%BF-5.png" alt="继承-5"></p>
<p>上述这种继承方式叫做<strong>组合继承</strong>。</p>
<hr>
<br />

<blockquote>
<p>参考：</p>
<p><a target="_blank" rel="noopener" href="https://juejin.cn/post/6996583771952644110">https://juejin.cn/post/6996583771952644110</a></p>
<p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1Kt411w7MP">https://www.bilibili.com/video/BV1Kt411w7MP</a></p>
</blockquote>
<div id="paginator"></div></div><div id="post-footer"><div id="pages"><div class="footer-link" style="width: 50%;text-align:right;border-right:1px #fe2 solid"><a href="/2022/03/11/%E4%B8%80%E4%BA%9B%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0/">← Next 一些常见函数</a></div><div class="footer-link" style="width: 50%;right:1px;border-left:1px #fe2 solid"><a href="/2022/03/11/%E6%B7%B1%E6%8B%B7%E8%B4%9D/">深拷贝 Prev →</a></div></div></div></div><div class="bottom-btn"><div><a class="i-top" id="to-top" onClick="scrolls.scrolltop();" title="To Top" style="opacity: 0; display: none;">∧ </a><a class="i-index" id="to-index" href="#toc-div" title="To Catalog">≡</a><a class="i-color" id="color-mode" onClick="colorMode.change()" title="Change Theme"></a></div></div></article><aside><div id="about"><a href="/" id="logo"><img src="https://ak.hypergryph.com/assets/index/images/ak/pc/faction/1.png" alt="Logo"></a><h1 id="Dr"><a href="/">LonelyTaker</a></h1><div id="description"><p></p></div><div id="social-links"><a class="social" target="_blank" rel="noopener" href="https://github.com/LonelyTaker"><i class="fab fa-github" alt="GitHub"></i></a></div></div><div id="aside-block"><div id="toc-div"><h1>Catalog</h1><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#1-%E5%89%8D%E7%BD%AE%E7%9F%A5%E8%AF%86"><span class="toc-text">1.前置知识</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E5%92%8C%E6%99%AE%E9%80%9A%E5%87%BD%E6%95%B0"><span class="toc-text">(1) 构造函数和普通函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E5%87%BD%E6%95%B0%E5%AF%B9%E8%B1%A1%E5%92%8C%E5%AE%9E%E4%BE%8B%E5%AF%B9%E8%B1%A1"><span class="toc-text">(2) 函数对象和实例对象</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#2-%E5%8E%9F%E5%9E%8B"><span class="toc-text">2.原型</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#3-%E5%8E%9F%E5%9E%8B%E9%93%BE"><span class="toc-text">3.原型链</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#4-%E8%A1%A5%E5%85%85"><span class="toc-text">4.补充</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#5-%E7%BB%A7%E6%89%BF"><span class="toc-text">5.继承</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E9%80%9A%E8%BF%87%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E7%BB%A7%E6%89%BF%E5%B1%9E%E6%80%A7"><span class="toc-text">(1) 通过构造函数继承属性</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E9%80%9A%E8%BF%87%E5%8E%9F%E5%9E%8B%E5%AF%B9%E8%B1%A1%E7%BB%A7%E6%89%BF%E6%96%B9%E6%B3%95"><span class="toc-text">(2) 通过原型对象继承方法</span></a></li></ol></li></ol></div></div><footer><nobr>Published with <a target="_blank" rel="noopener" href="http://hexo.io">Hexo</a></nobr><wbr><nobr> Theme <a target="_blank" rel="noopener" href="https://github.com/Yue-plus/hexo-theme-arknights">Arknights</a></nobr><wbr><nobr> by <a target="_blank" rel="noopener" href="https://github.com/Yue-plus">Yue_plus</a></nobr></footer></aside></main><canvas id="canvas-dust"></canvas></body></html>
<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1"><meta name="format-detection" content="telephone=no"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="black"><link rel="icon" href="/image/site/favicon/favicon-16x16.png?v=2.6.2" type="image/png" sizes="16x16"><link rel="icon" href="/image/site/favicon/favicon-32x32.png?v=2.6.2" type="image/png" sizes="32x32"><link rel="apple-touch-icon" href="/image/site/favicon/favicon-180x180.png?v=2.6.2" sizes="180x180"><meta name="description" content="1.前置知识       在聊原型和原型链之前，我们需要知道几个概念：构造函数和普通函数、函数对象和实例对象。                       (1) 构造函数和普通函数       123456789function Test(hi)&amp;#123;    this.hi &#x3D; hi    console.log(this.hi);&amp;#125;f">
<meta property="og:type" content="article">
<meta property="og:title" content="原型与原型链">
<meta property="og:url" content="https://lonelytaker.cn/2022/03/07/%E5%8E%9F%E5%9E%8B%E4%B8%8E%E5%8E%9F%E5%9E%8B%E9%93%BE/index.html">
<meta property="og:site_name" content="LonelyTaker&#39;s Blog">
<meta property="og:description" content="1.前置知识       在聊原型和原型链之前，我们需要知道几个概念：构造函数和普通函数、函数对象和实例对象。                       (1) 构造函数和普通函数       123456789function Test(hi)&amp;#123;    this.hi &#x3D; hi    console.log(this.hi);&amp;#125;f">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://lonelytaker.cn/2022/03/07/%E5%8E%9F%E5%9E%8B%E4%B8%8E%E5%8E%9F%E5%9E%8B%E9%93%BE/%E5%8E%9F%E5%9E%8B-1.png">
<meta property="og:image" content="https://lonelytaker.cn/2022/03/07/%E5%8E%9F%E5%9E%8B%E4%B8%8E%E5%8E%9F%E5%9E%8B%E9%93%BE/%E5%8E%9F%E5%9E%8B-2.png">
<meta property="og:image" content="https://lonelytaker.cn/2022/03/07/%E5%8E%9F%E5%9E%8B%E4%B8%8E%E5%8E%9F%E5%9E%8B%E9%93%BE/%E5%8E%9F%E5%9E%8B-3.png">
<meta property="og:image" content="https://lonelytaker.cn/2022/03/07/%E5%8E%9F%E5%9E%8B%E4%B8%8E%E5%8E%9F%E5%9E%8B%E9%93%BE/%E5%8E%9F%E5%9E%8B-4.png">
<meta property="og:image" content="https://lonelytaker.cn/2022/03/07/%E5%8E%9F%E5%9E%8B%E4%B8%8E%E5%8E%9F%E5%9E%8B%E9%93%BE/%E5%8E%9F%E5%9E%8B-5.png">
<meta property="og:image" content="https://lonelytaker.cn/2022/03/07/%E5%8E%9F%E5%9E%8B%E4%B8%8E%E5%8E%9F%E5%9E%8B%E9%93%BE/%E5%8E%9F%E5%9E%8B-6.png">
<meta property="og:image" content="https://lonelytaker.cn/2022/03/07/%E5%8E%9F%E5%9E%8B%E4%B8%8E%E5%8E%9F%E5%9E%8B%E9%93%BE/%E5%8E%9F%E5%9E%8B-7.png">
<meta property="og:image" content="https://lonelytaker.cn/2022/03/07/%E5%8E%9F%E5%9E%8B%E4%B8%8E%E5%8E%9F%E5%9E%8B%E9%93%BE/%E5%8E%9F%E5%9E%8B%E9%93%BE-1.png">
<meta property="og:image" content="https://lonelytaker.cn/2022/03/07/%E5%8E%9F%E5%9E%8B%E4%B8%8E%E5%8E%9F%E5%9E%8B%E9%93%BE/%E5%8E%9F%E5%9E%8B%E9%93%BE-2.png">
<meta property="og:image" content="https://lonelytaker.cn/2022/03/07/%E5%8E%9F%E5%9E%8B%E4%B8%8E%E5%8E%9F%E5%9E%8B%E9%93%BE/%E5%8E%9F%E5%9E%8B%E9%93%BE-3.png">
<meta property="og:image" content="https://lonelytaker.cn/2022/03/07/%E5%8E%9F%E5%9E%8B%E4%B8%8E%E5%8E%9F%E5%9E%8B%E9%93%BE/%E5%8E%9F%E5%9E%8B%E9%93%BE-4.png">
<meta property="og:image" content="https://lonelytaker.cn/2022/03/07/%E5%8E%9F%E5%9E%8B%E4%B8%8E%E5%8E%9F%E5%9E%8B%E9%93%BE/Function%E5%AF%B9%E8%B1%A1-1.png">
<meta property="og:image" content="https://lonelytaker.cn/2022/03/07/%E5%8E%9F%E5%9E%8B%E4%B8%8E%E5%8E%9F%E5%9E%8B%E9%93%BE/Function%E5%AF%B9%E8%B1%A1-2.png">
<meta property="og:image" content="https://lonelytaker.cn/2022/03/07/%E5%8E%9F%E5%9E%8B%E4%B8%8E%E5%8E%9F%E5%9E%8B%E9%93%BE/%E5%8E%9F%E5%9E%8B%E5%92%8C%E5%8E%9F%E5%9E%8B%E9%93%BE.png">
<meta property="og:image" content="https://lonelytaker.cn/2022/03/07/%E5%8E%9F%E5%9E%8B%E4%B8%8E%E5%8E%9F%E5%9E%8B%E9%93%BE/%E7%BB%A7%E6%89%BF-1.png">
<meta property="og:image" content="https://lonelytaker.cn/2022/03/07/%E5%8E%9F%E5%9E%8B%E4%B8%8E%E5%8E%9F%E5%9E%8B%E9%93%BE/%E7%BB%A7%E6%89%BF-2.png">
<meta property="og:image" content="https://lonelytaker.cn/2022/03/07/%E5%8E%9F%E5%9E%8B%E4%B8%8E%E5%8E%9F%E5%9E%8B%E9%93%BE/%E7%BB%A7%E6%89%BF-3.png">
<meta property="og:image" content="https://lonelytaker.cn/2022/03/07/%E5%8E%9F%E5%9E%8B%E4%B8%8E%E5%8E%9F%E5%9E%8B%E9%93%BE/%E7%BB%A7%E6%89%BF-4.png">
<meta property="og:image" content="https://lonelytaker.cn/2022/03/07/%E5%8E%9F%E5%9E%8B%E4%B8%8E%E5%8E%9F%E5%9E%8B%E9%93%BE/%E7%BB%A7%E6%89%BF-5.png">
<meta property="article:published_time" content="2022-03-07T12:00:24.000Z">
<meta property="article:modified_time" content="2022-03-08T11:13:11.887Z">
<meta property="article:author" content="LonelyTaker">
<meta property="article:tag" content="JavaScript">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://lonelytaker.cn/2022/03/07/%E5%8E%9F%E5%9E%8B%E4%B8%8E%E5%8E%9F%E5%9E%8B%E9%93%BE/%E5%8E%9F%E5%9E%8B-1.png"><title>原型与原型链 | LonelyTaker's Blog</title><link ref="canonical" href="https://lonelytaker.cn/2022/03/07/%E5%8E%9F%E5%9E%8B%E4%B8%8E%E5%8E%9F%E5%9E%8B%E9%93%BE/"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.12.1/css/all.min.css" type="text/css"><link rel="stylesheet" href="/css/index.css?v=2.6.2"><script>var Stun = window.Stun || {};
var CONFIG = {
  root: '/',
  algolia: undefined,
  assistSearch: undefined,
  fontIcon: {"prompt":{"success":"fas fa-check-circle","info":"fas fa-arrow-circle-right","warning":"fas fa-exclamation-circle","error":"fas fa-times-circle"},"copyBtn":"fas fa-copy"},
  sidebar: {"offsetTop":"20px","tocMaxDepth":6},
  header: {"enable":true,"showOnPost":false,"scrollDownIcon":true},
  postWidget: {"endText":true},
  nightMode: {"enable":true},
  back2top: {"enable":true},
  codeblock: {"style":"default","highlight":"light","wordWrap":false},
  reward: false,
  fancybox: false,
  zoomImage: {"gapAside":"20px"},
  galleryWaterfall: undefined,
  lazyload: false,
  pjax: undefined,
  externalLink: {"icon":{"enable":true,"name":"fas fa-external-link-alt"}},
  shortcuts: undefined,
  prompt: {"copyButton":"复制","copySuccess":"复制成功","copyError":"复制失败"},
  sourcePath: {"js":"js","css":"css","images":"images"},
};

window.CONFIG = CONFIG;</script><meta name="generator" content="Hexo 6.0.0"></head><body><div class="container" id="container"><header class="header" id="header"><div class="header-inner header-inner--height header-inner--bgcolor"><nav class="header-nav header-nav--sticky"><div class="header-nav-inner"><div class="header-nav-menubtn"><i class="fas fa-bars"></i></div><div class="header-nav-menu"><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/"><span class="header-nav-menu-item__icon"><i class="fas fa-home"></i></span><span class="header-nav-menu-item__text">首页</span></a></div><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/archives/"><span class="header-nav-menu-item__icon"><i class="fas fa-folder-open"></i></span><span class="header-nav-menu-item__text">归档</span></a></div><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/categories/"><span class="header-nav-menu-item__icon"><i class="fas fa-layer-group"></i></span><span class="header-nav-menu-item__text">分类</span></a></div><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/tags/"><span class="header-nav-menu-item__icon"><i class="fas fa-tags"></i></span><span class="header-nav-menu-item__text">标签</span></a></div></div><div class="header-nav-mode"><div class="mode"><div class="mode-track"><span class="mode-track-moon"></span><span class="mode-track-sun"></span></div><div class="mode-thumb"></div></div></div></div></nav></div></header><main class="main" id="main"><div class="main-inner"><div class="content-wrap" id="content-wrap"><div class="content" id="content"><!-- Just used to judge whether it is an article page--><div id="is-post"></div><div class="post"><header class="post-header"><h1 class="post-title">原型与原型链</h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">发表于</span><span class="post-meta-item__value">2022-03-07</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__info">更新于</span><span class="post-meta-item__value">2022-03-08</span></span></div></header><div class="post-body"><br>


        <h1 id="1-前置知识">
          <a href="#1-前置知识" class="heading-link"><i class="fas fa-link"></i></a><a href="#1-前置知识" class="headerlink" title="1.前置知识"></a>1.前置知识</h1>
      <p>在聊原型和原型链之前，我们需要知道几个概念：构造函数和普通函数、函数对象和实例对象。</p>
<br>


        <h2 id="1-构造函数和普通函数">
          <a href="#1-构造函数和普通函数" class="heading-link"><i class="fas fa-link"></i></a><a href="#1-构造函数和普通函数" class="headerlink" title="(1) 构造函数和普通函数"></a>(1) 构造函数和普通函数</h2>
      <figure class="highlight javascript"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Test</span>(<span class="params">hi</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.hi = hi</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.hi);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;这是普通函数&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> t = <span class="keyword">new</span> Test(<span class="string">&quot;这是构造函数&quot;</span>);</span><br><span class="line">test();</span><br></pre></td></tr></table></div></figure>

<p>在函数声明的时候，无法判断一个函数是否为构造函数。只有使用<code>new</code>操作符创建对象时，调用的函数才叫做构造函数。</p>
<p>两者区别：</p>
<ol>
<li><p>作用不同</p>
<p> 普通函数的作用自然是执行函数体内的代码以实现某种功能。构造函数的作用是用来创建对象。</p>
</li>
<li><p>调用方式不同</p>
<p> 普通函数直接调用：<code>函数名()</code></p>
<p> 构造函数是为了创建对象，所以需要使用<code>new</code>关键字来调用：<code>new 函数名()</code></p>
</li>
<li><p>书写习惯不同</p>
<p> 为了区别普通函数和构造函数，构造函数的函数名一般大写开头。</p>
</li>
<li><p>this指向不同</p>
<p> 普通函数中的this指向window对象，构造函数中的this则是指向它创建的对象。</p>
</li>
<li><p>写法不同</p>
<p> 构造函数中一般不写<code>return</code>。</p>
</li>
</ol>
<p>所以上述代码中<code>test</code>为普通函数，<code>Test</code>为构造函数。</p>
<br>


        <h2 id="2-函数对象和实例对象">
          <a href="#2-函数对象和实例对象" class="heading-link"><i class="fas fa-link"></i></a><a href="#2-函数对象和实例对象" class="headerlink" title="(2) 函数对象和实例对象"></a>(2) 函数对象和实例对象</h2>
      <p>以下面的代码为例：</p>
<figure class="highlight javascript"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Student</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> st1 = <span class="keyword">new</span> Student(<span class="string">&#x27;小明&#x27;</span>);</span><br></pre></td></tr></table></div></figure>

<p>在JavaScript中，函数也是对象，所以从这个角度讲，上述代码中<code>Student</code>构造函数也称为函数对象，而通过<code>new</code>操作符创建的对象，称为实例对象，上述代码中<code>st1</code>就是通过<code>Student</code>构造函数创建的实例对象。</p>
<blockquote>
<p>不仅仅是构造函数，任何函数从对象的角度讲或者当做对象去使用时，都可以称为函数对象。</p>
<p>这里所说的函数对象不是JS内置的Function对象。</p>
</blockquote>
<br>


        <h1 id="2-原型">
          <a href="#2-原型" class="heading-link"><i class="fas fa-link"></i></a><a href="#2-原型" class="headerlink" title="2.原型"></a>2.原型</h1>
      <p>什么是原型？我们还是通过上面的代码来讲解：</p>
<figure class="highlight javascript"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Student</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> st1 = <span class="keyword">new</span> Student(<span class="string">&#x27;小明&#x27;</span>);</span><br></pre></td></tr></table></div></figure>

<p>假设现在我们需要给<code>st1</code>添加一个<code>speak</code>方法，可以这么做：</p>
<figure class="highlight javascript"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Student</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> st1 = <span class="keyword">new</span> Student(<span class="string">&#x27;小明&#x27;</span>);</span><br><span class="line">st1.speak = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;my name is&quot;</span>, <span class="built_in">this</span>.name);</span><br><span class="line">&#125;</span><br><span class="line">st1.speak();    <span class="comment">// my name is 小明</span></span><br></pre></td></tr></table></div></figure>

<p>但假如我要给每一个<code>Student</code>创建出来的实例对象都添加上这个<code>speak</code>方法，可以这么做：</p>
<figure class="highlight javascript"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Student</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.name = name;</span><br><span class="line">    <span class="built_in">this</span>.speak = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;my name is&quot;</span>, <span class="built_in">this</span>.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> st1 = <span class="keyword">new</span> Student(<span class="string">&#x27;小明&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> st2 = <span class="keyword">new</span> Student(<span class="string">&#x27;小红&#x27;</span>);</span><br><span class="line">st1.speak();    <span class="comment">// my name is 小明</span></span><br><span class="line">st2.speak();    <span class="comment">// my name is 小红</span></span><br></pre></td></tr></table></div></figure>

<p>这种方式每创建一个实例对象，就会创建一个新的<code>speak</code>方法，也就是说每个实例对象的<code>speak</code>方法都是唯一的。</p>
<img src="/2022/03/07/%E5%8E%9F%E5%9E%8B%E4%B8%8E%E5%8E%9F%E5%9E%8B%E9%93%BE/%E5%8E%9F%E5%9E%8B-1.png" class>

<p>但这种方式有个问题：如果我们创建出来的实例对象越来越多，在内存中占用的空间是不是也越来越多。</p>
<p>我们仔细想想，这个<code>speak</code>方法需要每个实例对象都唯一吗？能不能共用一个？答案是可以共用，因为每个实例对象的<code>speak</code>方法做的事情都是一样的。</p>
<p>那么我们要怎么修改呢？可以这么做：</p>
<figure class="highlight javascript"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Student</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.name = name;</span><br><span class="line">    <span class="built_in">this</span>.speak = _speak;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 将方法提取到全局作用域下</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">_speak</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;my name is&quot;</span>, <span class="built_in">this</span>.name);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> st1 = <span class="keyword">new</span> Student(<span class="string">&#x27;小明&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> st2 = <span class="keyword">new</span> Student(<span class="string">&#x27;小红&#x27;</span>);</span><br><span class="line">st1.speak();    <span class="comment">// my name is 小明</span></span><br><span class="line">st2.speak();    <span class="comment">// my name is 小红</span></span><br></pre></td></tr></table></div></figure>

<p>这时候的内存空间：</p>
<img src="/2022/03/07/%E5%8E%9F%E5%9E%8B%E4%B8%8E%E5%8E%9F%E5%9E%8B%E9%93%BE/%E5%8E%9F%E5%9E%8B-2.png" class>

<p>这种方式看上去很不错，但是仍然会带来一些问题：</p>
<ol>
<li><code>_speak</code>是在全局作用域下声明的，可能会污染全局作用域（变量冲突）。</li>
<li>随着全局作用域下的函数声明越来越多，全局作用域会变得越来越臃肿。</li>
</ol>
<br>

<p>因此，JS就提出了原型的概念。每一个函数对象身上都有一个<code>prototype</code>属性，该属性指向一个对象。</p>
<figure class="highlight javascript"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Student</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(Student.prototype);    <span class="comment">// Object</span></span><br></pre></td></tr></table></div></figure>

<p>这个对象叫做<strong>原型对象</strong>，每个函数对象都有自己的原型对象。</p>
<blockquote>
<p>不管是构造函数还是普通函数，都有<code>prototype</code>属性，只不过在普通函数上这一个属性没有什么作用。所以在讲原型时，我们比较强调构造函数，下文中的函数对象也都指构造函数。</p>
</blockquote>
<p>另外，创建实例对象时，实例对象身上会有一个属性<code>__proto__</code>，它指向创建该实例对象的函数对象的原型对象。同一个函数对象创建的每一个实例对象，它们的<code>__proto__</code>属性都指向同一个原型对象。</p>
<figure class="highlight javascript"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Student</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> st1 = <span class="keyword">new</span> Student(<span class="string">&quot;小明&quot;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(Student.prototype === st1.__proto__);  <span class="comment">// true</span></span><br></pre></td></tr></table></div></figure>

<img src="/2022/03/07/%E5%8E%9F%E5%9E%8B%E4%B8%8E%E5%8E%9F%E5%9E%8B%E9%93%BE/%E5%8E%9F%E5%9E%8B-3.png" class>

<p>这就意味着，如果我们在函数对象的原型对象中添加属性和方法，该函数对象创建的实例对象也可以访问到。JS就是这么做的，JS中对于对象属性和方法的访问顺序是从对象本身到对象的原型，如果对象本身中就有要找的属性或方法，直接使用对象本身中的属性或方法，否则从对象的原型中找。比如：</p>
<figure class="highlight javascript"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Student</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line">Student.prototype.school = <span class="string">&quot;xx大学&quot;</span>;</span><br><span class="line"><span class="keyword">var</span> st1 = <span class="keyword">new</span> Student(<span class="string">&quot;小明&quot;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(st1.school);    <span class="comment">// xx大学</span></span><br><span class="line">st1.school = <span class="string">&quot;yy大学&quot;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(st1.school);    <span class="comment">// yy大学</span></span><br></pre></td></tr></table></div></figure>

<img src="/2022/03/07/%E5%8E%9F%E5%9E%8B%E4%B8%8E%E5%8E%9F%E5%9E%8B%E9%93%BE/%E5%8E%9F%E5%9E%8B-4.png" class>

<img src="/2022/03/07/%E5%8E%9F%E5%9E%8B%E4%B8%8E%E5%8E%9F%E5%9E%8B%E9%93%BE/%E5%8E%9F%E5%9E%8B-5.png" class>

<p>那么为了实现我们上面所说的对于<code>speak</code>方法的操作，可以这么做：</p>
<figure class="highlight javascript"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Student</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line">Student.prototype.speak = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;my name is&quot;</span>, <span class="built_in">this</span>.name);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> st1 = <span class="keyword">new</span> Student(<span class="string">&#x27;小明&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> st2 = <span class="keyword">new</span> Student(<span class="string">&#x27;小红&#x27;</span>);</span><br><span class="line">st1.speak();    <span class="comment">// my name is 小明</span></span><br><span class="line">st2.speak();    <span class="comment">// my name is 小红</span></span><br></pre></td></tr></table></div></figure>

<img src="/2022/03/07/%E5%8E%9F%E5%9E%8B%E4%B8%8E%E5%8E%9F%E5%9E%8B%E9%93%BE/%E5%8E%9F%E5%9E%8B-6.png" class>

<p>再补充一点，原型对象在函数声明时一同创建，然后挂载到函数对象的<code>prototype</code>属性上，另外原型对象上有一个<code>constructor</code>属性，指向创建它的函数对象，这样两者的关系就紧密结合起来了。</p>
<p>完整关系图：</p>
<img src="/2022/03/07/%E5%8E%9F%E5%9E%8B%E4%B8%8E%E5%8E%9F%E5%9E%8B%E9%93%BE/%E5%8E%9F%E5%9E%8B-7.png" class>

<p>总结：</p>
<ol>
<li>函数对象上有一个<code>prototype</code>属性，该属性称为显示原型。它指向一个对象，该对象称为原型对象。</li>
<li>函数对象创建的每个实例对象都有一个 <code>__proto__</code>属性 ，该属性称为隐式原型。它指向创建该实例对象的函数对象的原型对象。</li>
<li>原型对象上有一个<code>constructor</code>属性，它指向创建该原型对象的函数对象。</li>
</ol>
<p>所以原型就是一个对象，它的作用是所有实例对象共享属性和方法。</p>
<blockquote>
<p>一般是共享方法，因为属性一般都是实例对象独有的，不同实例对象他们的属性不同，比如上面的<code>st1</code>和<code>st2</code>，他们的<code>name</code>属性各不相同，不应该把<code>name</code>放入<code>Student</code>原型对象中。</p>
</blockquote>
<blockquote>
<p>有些人可能会问：为什么一定要通过函数对象的<code>prototype</code>往原型对象上添加方法和属性，能不能通过实例对象的<code>__proto__</code>去添加呢？答案是不行的，实例对象的<code>__proto__</code>属性的意义在于为对象的查找机制提供一个方向或者说一条线路，但它是一个非标准属性，因此实际开发中不可以使用这个属性，这也是为什么称它为隐式原型的原因。</p>
</blockquote>
<br>


        <h1 id="3-原型链">
          <a href="#3-原型链" class="heading-link"><i class="fas fa-link"></i></a><a href="#3-原型链" class="headerlink" title="3.原型链"></a>3.原型链</h1>
      <p>理解了原型之后，原型链理解起来就比较容易。我们还是从上面的例子入手：</p>
<figure class="highlight javascript"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Student</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line">Student.prototype.speak = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;my name is&quot;</span>, <span class="built_in">this</span>.name);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> st1 = <span class="keyword">new</span> Student(<span class="string">&#x27;小明&#x27;</span>);</span><br><span class="line">st1.speak();    <span class="comment">// my name is 小明</span></span><br><span class="line"><span class="built_in">console</span>.log(st1.toString());    <span class="comment">// [object Object]</span></span><br></pre></td></tr></table></div></figure>

<p>我们会发现上述第九行代码，会输出<code>[object Object]</code>，也就是说<code>st1</code>能够执行<code>toString()</code>方法。但是<code>st1</code>这个实例对象本身和它<code>__proto__</code>所指向的原型对象上都没有这个方法。那这个方法是哪来的呢？</p>
<p>我们知道，<code>Object</code>对象是所有对象的“祖先”，既然原型对象也是一个对象，那它也不例外，所以其实<strong>原型对象是Object对象的实例对象</strong>。既然是实例对象，那它身上就会有一个<code>__proto__</code>属性，指向<code>Object</code>对象的原型对象。</p>
<img src="/2022/03/07/%E5%8E%9F%E5%9E%8B%E4%B8%8E%E5%8E%9F%E5%9E%8B%E9%93%BE/%E5%8E%9F%E5%9E%8B%E9%93%BE-1.png" class>

<p>我们简化一下这张图：</p>
<img src="/2022/03/07/%E5%8E%9F%E5%9E%8B%E4%B8%8E%E5%8E%9F%E5%9E%8B%E9%93%BE/%E5%8E%9F%E5%9E%8B%E9%93%BE-2.png" class>

<p>接着我们来看下<code>Object</code>对象的原型对象上有没有<code>toString()</code>方法：</p>
<img src="/2022/03/07/%E5%8E%9F%E5%9E%8B%E4%B8%8E%E5%8E%9F%E5%9E%8B%E9%93%BE/%E5%8E%9F%E5%9E%8B%E9%93%BE-3.png" class>

<p>果然有，这说明了什么？说明JS对于对象属性和方法的查找规则是这样的：</p>
<p>先从对象本身去找，如果找不到，就去该对象的原型对象上去找，如果还是没有找到，就去原型对象的原型对象上去找……但原型对象不可能永无止境，<code>Object</code>对象的原型对象<code>__proto__</code>属性值为<code>null</code>，也就是说查找到<code>Object</code>对象的原型对象就结束了，如果还是没有找到，则返回<code>undefined</code>。</p>
<img src="/2022/03/07/%E5%8E%9F%E5%9E%8B%E4%B8%8E%E5%8E%9F%E5%9E%8B%E9%93%BE/%E5%8E%9F%E5%9E%8B%E9%93%BE-4.png" class>

<p>像图上这条被<code>__proto__</code>链接起来的链式关系，就叫<strong>原型链</strong>。它直接反应了JS对于对象属性和方法的查找顺序。</p>
<br>


        <h1 id="4-补充">
          <a href="#4-补充" class="heading-link"><i class="fas fa-link"></i></a><a href="#4-补充" class="headerlink" title="4.补充"></a>4.补充</h1>
      <p>理解完了原型和原型链，我们再想一想，所有的函数都可以通过<code>new Function()</code>的方式创建，那么也就是说所有的函数都是<code>Function</code>对象的实例对象。既然是实例对象，那它身上就会有一个<code>__proto__</code>属性，并且这一属性指向<code>Function</code>对象的原型对象。</p>
<img src="/2022/03/07/%E5%8E%9F%E5%9E%8B%E4%B8%8E%E5%8E%9F%E5%9E%8B%E9%93%BE/Function%E5%AF%B9%E8%B1%A1-1.png" class>

<p>那么<code>Function</code>对象是谁的实例对象呢？</p>
<p>我们刚说所有函数都是<code>Function</code>对象的实例对象，而<code>Function</code>对象也是构造函数，那么不就成了<code>Function</code>对象创建了<code>Function</code>对象？其实不必太过纠结这一点，因为<code>Function</code>对象是JS的内置对象，在脚本还没开始执行，就已经创建好了。所以<code>Function.__proto__ === Function.prototype</code>，记住这一个特殊情况就好了。</p>
<img src="/2022/03/07/%E5%8E%9F%E5%9E%8B%E4%B8%8E%E5%8E%9F%E5%9E%8B%E9%93%BE/Function%E5%AF%B9%E8%B1%A1-2.png" class>

<blockquote>
<p><code>Object</code>对象和<code>Function</code>对象都是函数对象，也就是构造函数。只不过它们两个都是JS的内置对象，所以没有特别标注函数对象。</p>
</blockquote>
<p>这里有一张非常流行的关于原型的图，就是我们刚刚讲到的所有内容：</p>
<img src="/2022/03/07/%E5%8E%9F%E5%9E%8B%E4%B8%8E%E5%8E%9F%E5%9E%8B%E9%93%BE/%E5%8E%9F%E5%9E%8B%E5%92%8C%E5%8E%9F%E5%9E%8B%E9%93%BE.png" class>

<br>


        <h1 id="5-继承">
          <a href="#5-继承" class="heading-link"><i class="fas fa-link"></i></a><a href="#5-继承" class="headerlink" title="5.继承"></a>5.继承</h1>
      <p>继承是面向对象编程的一个概念。继承可以使子类具有父类的属性和方法，同时可以在子类中重新定义或追加属性和方法。继承是类与类之间的关系。</p>
<p>但是JavaScript并没有类的概念，只有对象。那怎么会有继承呢？因为JavaScript是非常灵活的，我们可以通过构造函数和原型来模拟类的继承。</p>
<blockquote>
<p>如果熟悉面向对象编程的语言，我们会发现JS中的构造函数和类有点相似。在ES6中，JS也提出了类的概念，但ES6中的类其实是一个语法糖，它的本质还是构造函数，感兴趣的可以自行了解。</p>
</blockquote>
<br>


        <h2 id="1-通过构造函数继承属性">
          <a href="#1-通过构造函数继承属性" class="heading-link"><i class="fas fa-link"></i></a><a href="#1-通过构造函数继承属性" class="headerlink" title="(1) 通过构造函数继承属性"></a>(1) 通过构造函数继承属性</h2>
      <p>假如我们现在有一个<code>Father</code>构造函数，并且希望有另一个构造函数继承<code>Father</code>构造函数，我们可以这么做：</p>
<figure class="highlight javascript"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 父构造函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Father</span>(<span class="params">name,age</span>)</span>&#123;</span><br><span class="line">    <span class="comment">// this 指向父构造函数的实例对象</span></span><br><span class="line">    <span class="built_in">this</span>.name = name;</span><br><span class="line">    <span class="built_in">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 子构造函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Son</span>(<span class="params">name,age</span>)</span>&#123;</span><br><span class="line">    <span class="comment">// this 指向子构造函数的实例对象</span></span><br><span class="line">    <span class="comment">// 要想继承父构造函数的属性，必须调用父构造函数，并且将父构造函数中的this改为当前构造函数中的this</span></span><br><span class="line">    Father.call(<span class="built_in">this</span>, name, age);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> son = <span class="keyword">new</span> Son(<span class="string">&#x27;小明&#x27;</span>, <span class="number">18</span>);</span><br></pre></td></tr></table></div></figure>

<p>但是这样还不够，因为这样<code>Son</code>构造函数只继承了<code>Father</code>构造函数的属性，没有继承<code>Father</code>构造函数的方法：</p>
<figure class="highlight javascript"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 父构造函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Father</span>(<span class="params">name,age</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.name = name;</span><br><span class="line">    <span class="built_in">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line">Father.prototype.money = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">1000</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 子构造函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Son</span>(<span class="params">name,age</span>)</span>&#123;</span><br><span class="line">    Father.call(<span class="built_in">this</span>, name, age);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> son = <span class="keyword">new</span> Son(<span class="string">&#x27;小明&#x27;</span>, <span class="number">18</span>);</span><br><span class="line">son.money();    <span class="comment">// 报错，son无法调用money方法，或者说根本找不到money方法</span></span><br></pre></td></tr></table></div></figure>

<img src="/2022/03/07/%E5%8E%9F%E5%9E%8B%E4%B8%8E%E5%8E%9F%E5%9E%8B%E9%93%BE/%E7%BB%A7%E6%89%BF-1.png" class>

<p>接下去，我们就需要让<code>Son</code>构造函数继承<code>Father</code>构造函数的方法。</p>
<br>


        <h2 id="2-通过原型对象继承方法">
          <a href="#2-通过原型对象继承方法" class="heading-link"><i class="fas fa-link"></i></a><a href="#2-通过原型对象继承方法" class="headerlink" title="(2) 通过原型对象继承方法"></a>(2) 通过原型对象继承方法</h2>
      <p>由上面的图像结合原型链的知识，我们可以发现，如果让<code>Son</code>原型对象链接到<code>Father</code>原型对象，那我们<code>Son</code>构造函数创建的实例对象，是不是就可以使用<code>Father</code>原型对象上的方法了？</p>
<img src="/2022/03/07/%E5%8E%9F%E5%9E%8B%E4%B8%8E%E5%8E%9F%E5%9E%8B%E9%93%BE/%E7%BB%A7%E6%89%BF-2.png" class>

<p>原型对象的链接是依靠<code>__proto__</code>属性去操作的，所以最简单的方式：</p>
<figure class="highlight javascript"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Son.prototype.__proto__ = Father.prototype;</span><br></pre></td></tr></table></div></figure>

<p>但是我们说过<code>__proto__</code>属性不能直接使用。那有没有什么办法同样能实现上述代码的效果？我们可以这么做：</p>
<figure class="highlight javascript"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 父构造函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Father</span>(<span class="params">name,age</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.name = name;</span><br><span class="line">    <span class="built_in">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line">Father.prototype.money = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">1000</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 子构造函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Son</span>(<span class="params">name,age</span>)</span>&#123;</span><br><span class="line">    Father.call(<span class="built_in">this</span>, name, age);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 将Son构造函数的prototype指向Father构造函数创建的实例对象</span></span><br><span class="line"><span class="comment">// 由于Father构造函数创建的实例对象中有__proto__属性，并且指向Father构造函数的原型对象</span></span><br><span class="line"><span class="comment">// 这样就达到了我们预先的目的</span></span><br><span class="line">Son.prototype = <span class="keyword">new</span> Father();</span><br><span class="line"><span class="keyword">var</span> son = <span class="keyword">new</span> Son(<span class="string">&#x27;小明&#x27;</span>, <span class="number">18</span>);</span><br><span class="line">son.money();    <span class="comment">// 1000</span></span><br></pre></td></tr></table></div></figure>

<img src="/2022/03/07/%E5%8E%9F%E5%9E%8B%E4%B8%8E%E5%8E%9F%E5%9E%8B%E9%93%BE/%E7%BB%A7%E6%89%BF-3.png" class>

<p>这样<code>Father</code>构造函数创建的实例对象就变成了<code>Son</code>构造函数的原型对象，<code>Son</code>构造函数<code>new</code>出来的实例对象，也指向这一个<code>Father</code>构造函数创建的实例对象。从而达到我们预先的目的。</p>
<img src="/2022/03/07/%E5%8E%9F%E5%9E%8B%E4%B8%8E%E5%8E%9F%E5%9E%8B%E9%93%BE/%E7%BB%A7%E6%89%BF-4.png" class>

<p>除此之外还差一步，我们原先说过原型对象中有一个<code>constructor</code>属性指向构造函数，我们修改了构造函数的原型对象，那就需要将新的原型对象中的<code>constructor</code>属性指向构造函数。</p>
<figure class="highlight javascript"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 父构造函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Father</span>(<span class="params">name,age</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.name = name;</span><br><span class="line">    <span class="built_in">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line">Father.prototype.money = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">1000</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 子构造函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Son</span>(<span class="params">name,age</span>)</span>&#123;</span><br><span class="line">    Father.call(<span class="built_in">this</span>, name, age);</span><br><span class="line">&#125;</span><br><span class="line">Son.prototype = <span class="keyword">new</span> Father();</span><br><span class="line"><span class="comment">// 修改constructor</span></span><br><span class="line">Son.prototype.constructor = Son;</span><br><span class="line"><span class="keyword">var</span> son = <span class="keyword">new</span> Son(<span class="string">&#x27;小明&#x27;</span>, <span class="number">18</span>);</span><br><span class="line">son.money();    <span class="comment">// 1000</span></span><br></pre></td></tr></table></div></figure>

<img src="/2022/03/07/%E5%8E%9F%E5%9E%8B%E4%B8%8E%E5%8E%9F%E5%9E%8B%E9%93%BE/%E7%BB%A7%E6%89%BF-5.png" class>

<br>

<p>上述这种继承方式叫做<strong>组合继承</strong>。</p>
<hr>
<br>

<blockquote>
<p>参考：</p>
<p><span class="exturl"><a class="exturl__link" target="_blank" rel="noopener" href="https://juejin.cn/post/6996583771952644110">https://juejin.cn/post/6996583771952644110</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
<p><span class="exturl"><a class="exturl__link" target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1Kt411w7MP">https://www.bilibili.com/video/BV1Kt411w7MP</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
</blockquote>
</div><footer class="post-footer"><div class="post-ending ending"><div class="ending__text">------ 本文结束，感谢您的阅读 ------</div></div><div class="post-copyright copyright"><div class="copyright-author"><span class="copyright-author__name">本文作者: </span><span class="copyright-author__value"><a href="https://lonelytaker.cn">LonelyTaker</a></span></div><div class="copyright-link"><span class="copyright-link__name">本文链接: </span><span class="copyright-link__value"><a href="https://lonelytaker.cn/2022/03/07/%E5%8E%9F%E5%9E%8B%E4%B8%8E%E5%8E%9F%E5%9E%8B%E9%93%BE/">https://lonelytaker.cn/2022/03/07/%E5%8E%9F%E5%9E%8B%E4%B8%8E%E5%8E%9F%E5%9E%8B%E9%93%BE/</a></span></div><div class="copyright-notice"><span class="copyright-notice__name">版权声明: </span><span class="copyright-notice__value">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.en" rel="external nofollow" target="_blank">BY-NC-SA</a> 许可协议。转载请注明出处！</span></div></div><div class="post-tags"><span class="post-tags-item"><span class="post-tags-item__icon"><i class="fas fa-tag"></i></span><a class="post-tags-item__link" href="https://lonelytaker.cn/tags/JavaScript/">JavaScript</a></span></div><nav class="post-paginator paginator"><div class="paginator-prev"><a class="paginator-prev__link" href="/2022/03/09/new%E6%93%8D%E4%BD%9C%E7%AC%A6/"><span class="paginator-prev__icon"><i class="fas fa-angle-left"></i></span><span class="paginator-prev__text">new操作符</span></a></div><div class="paginator-next"><a class="paginator-next__link" href="/2022/02/21/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/"><span class="paginator-prev__text">浏览器工作原理</span><span class="paginator-next__icon"><i class="fas fa-angle-right"></i></span></a></div></nav></footer></div></div></div><div class="sidebar-wrap" id="sidebar-wrap"><aside class="sidebar" id="sidebar"><div class="sidebar-nav"><span class="sidebar-nav-toc current">文章目录</span><span class="sidebar-nav-ov">站点概览</span></div><section class="sidebar-toc"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#1-%E5%89%8D%E7%BD%AE%E7%9F%A5%E8%AF%86"><span class="toc-text">
          1.前置知识</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E5%92%8C%E6%99%AE%E9%80%9A%E5%87%BD%E6%95%B0"><span class="toc-text">
          (1) 构造函数和普通函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E5%87%BD%E6%95%B0%E5%AF%B9%E8%B1%A1%E5%92%8C%E5%AE%9E%E4%BE%8B%E5%AF%B9%E8%B1%A1"><span class="toc-text">
          (2) 函数对象和实例对象</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#2-%E5%8E%9F%E5%9E%8B"><span class="toc-text">
          2.原型</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#3-%E5%8E%9F%E5%9E%8B%E9%93%BE"><span class="toc-text">
          3.原型链</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#4-%E8%A1%A5%E5%85%85"><span class="toc-text">
          4.补充</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#5-%E7%BB%A7%E6%89%BF"><span class="toc-text">
          5.继承</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E9%80%9A%E8%BF%87%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E7%BB%A7%E6%89%BF%E5%B1%9E%E6%80%A7"><span class="toc-text">
          (1) 通过构造函数继承属性</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E9%80%9A%E8%BF%87%E5%8E%9F%E5%9E%8B%E5%AF%B9%E8%B1%A1%E7%BB%A7%E6%89%BF%E6%96%B9%E6%B3%95"><span class="toc-text">
          (2) 通过原型对象继承方法</span></a></li></ol></li></ol></section><!-- ov = overview--><section class="sidebar-ov hide"><div class="sidebar-ov-author"><div class="sidebar-ov-author__avatar"><img class="sidebar-ov-author__avatar_img" src="/image/site/head.png" alt="avatar"></div><p class="sidebar-ov-author__text">hello world</p></div><div class="sidebar-ov-social"><a class="sidebar-ov-social-item" href="https://github.com/LonelyTaker" target="_blank" rel="noopener" data-popover="Github" data-popover-pos="up"><span class="sidebar-ov-social-item__icon"><i class="fab fa-github"></i></span></a><a class="sidebar-ov-social-item" href="Ym1104340863" target="_blank" rel="noopener" data-popover="微信" data-popover-pos="up"><span class="sidebar-ov-social-item__icon"><i class="fab fa-weixin"></i></span></a><a class="sidebar-ov-social-item" href="1104340863" target="_blank" rel="noopener" data-popover="QQ" data-popover-pos="up"><span class="sidebar-ov-social-item__icon"><i class="fab fa-qq"></i></span></a></div><div class="sidebar-ov-state"><a class="sidebar-ov-state-item sidebar-ov-state-item--posts" href="/archives/"><div class="sidebar-ov-state-item__count">14</div><div class="sidebar-ov-state-item__name">归档</div></a><a class="sidebar-ov-state-item sidebar-ov-state-item--categories" href="/categories/"><div class="sidebar-ov-state-item__count">4</div><div class="sidebar-ov-state-item__name">分类</div></a><a class="sidebar-ov-state-item sidebar-ov-state-item--tags" href="/tags/"><div class="sidebar-ov-state-item__count">4</div><div class="sidebar-ov-state-item__name">标签</div></a></div><div class="sidebar-ov-cc"><a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.en" target="_blank" rel="noopener" data-popover="知识共享许可协议" data-popover-pos="up"><img src="/images/cc-by-nc-sa.svg"></a></div></section><div class="sidebar-reading"><div class="sidebar-reading-info"><span class="sidebar-reading-info__text">你已阅读了 </span><span class="sidebar-reading-info__num">0</span><span class="sidebar-reading-info__perc">%</span></div><div class="sidebar-reading-line"></div></div></aside></div><div class="clearfix"></div></div></main><footer class="footer" id="footer"><div class="footer-inner"><div><span>Copyright © 2022</span><span class="footer__icon"><i class="fas fa-heart"></i></span><span>LonelyTaker</span></div><div><span>由 <a href="http://hexo.io/" title="Hexo" target="_blank" rel="noopener">Hexo</a> 强力驱动</span><span> v6.0.0</span></div></div></footer><div class="loading-bar" id="loading-bar"><div class="loading-bar__progress"></div></div><div class="back2top" id="back2top"><span class="back2top__icon"><i class="fas fa-rocket"></i></span></div></div><script src="https://cdn.jsdelivr.net/npm/jquery@v3.4.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@1.5.2/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@1.5.2/velocity.ui.min.js"></script><script src="/js/utils.js?v=2.6.2"></script><script src="/js/stun-boot.js?v=2.6.2"></script><script src="/js/scroll.js?v=2.6.2"></script><script src="/js/header.js?v=2.6.2"></script><script src="/js/sidebar.js?v=2.6.2"></script></body></html>
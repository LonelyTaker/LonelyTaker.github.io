<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1"><meta name="format-detection" content="telephone=no"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="black"><link rel="icon" href="/image/site/favicon/favicon-16x16.png?v=2.6.2" type="image/png" sizes="16x16"><link rel="icon" href="/image/site/favicon/favicon-32x32.png?v=2.6.2" type="image/png" sizes="32x32"><link rel="apple-touch-icon" href="/image/site/favicon/favicon-180x180.png?v=2.6.2" sizes="180x180"><meta name="description" content="前置知识                           (1) 浏览器的组成结构       浏览器一般由七个模块组成：  用户界面（ User Interface ） 包括地址栏、后退&#x2F;前进按钮、书签目录等，也就是除了标签页窗口之外的其他部分。  浏览器引擎（ Browser Engine ） 可以在用户界面和渲染引擎之间传送指令或在客户端本地缓存中">
<meta property="og:type" content="article">
<meta property="og:title" content="浏览器工作原理">
<meta property="og:url" content="https://lonelytaker.cn/2022/02/21/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/index.html">
<meta property="og:site_name" content="LonelyTaker&#39;s Blog">
<meta property="og:description" content="前置知识                           (1) 浏览器的组成结构       浏览器一般由七个模块组成：  用户界面（ User Interface ） 包括地址栏、后退&#x2F;前进按钮、书签目录等，也就是除了标签页窗口之外的其他部分。  浏览器引擎（ Browser Engine ） 可以在用户界面和渲染引擎之间传送指令或在客户端本地缓存中">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://lonelytaker.cn/2022/02/21/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/%E6%B5%8F%E8%A7%88%E5%99%A8-%E7%BB%84%E6%88%90%E7%BB%93%E6%9E%84.png">
<meta property="og:image" content="https://lonelytaker.cn/2022/02/21/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/%E6%B5%8F%E8%A7%88%E5%99%A8-%E5%A4%9A%E8%BF%9B%E7%A8%8B.png">
<meta property="og:image" content="https://lonelytaker.cn/2022/02/21/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/DNS-DNS%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84.png">
<meta property="og:image" content="https://lonelytaker.cn/2022/02/21/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/DNS-%E6%9F%A5%E8%AF%A2%E8%BF%87%E7%A8%8B-%E8%BF%AD%E4%BB%A3.png">
<meta property="og:image" content="https://lonelytaker.cn/2022/02/21/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/DNS-%E6%9F%A5%E8%AF%A2%E8%BF%87%E7%A8%8B-%E9%80%92%E5%BD%92.png">
<meta property="og:image" content="https://lonelytaker.cn/2022/02/21/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/DNS-%E7%BC%93%E5%AD%98.png">
<meta property="og:image" content="https://lonelytaker.cn/2022/02/21/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/TCP.jpg">
<meta property="og:image" content="https://lonelytaker.cn/2022/02/21/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/TCP-%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B.png">
<meta property="og:image" content="https://lonelytaker.cn/2022/02/21/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/http-%E5%BC%BA%E7%BC%93%E5%AD%98-Cache-Control.png">
<meta property="og:image" content="https://lonelytaker.cn/2022/02/21/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/http-%E5%8D%8F%E5%95%86%E7%BC%93%E5%AD%98-Last-Modified.png">
<meta property="og:image" content="https://lonelytaker.cn/2022/02/21/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/http-%E5%8D%8F%E5%95%86%E7%BC%93%E5%AD%98-Etag.png">
<meta property="og:image" content="https://lonelytaker.cn/2022/02/21/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/http-%E7%BC%93%E5%AD%98-%E6%B5%81%E7%A8%8B.png">
<meta property="og:image" content="https://lonelytaker.cn/2022/02/21/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/%E6%B8%B2%E6%9F%93%E6%B5%81%E7%A8%8B-1.png">
<meta property="og:image" content="https://lonelytaker.cn/2022/02/21/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/%E6%B8%B2%E6%9F%93%E6%B5%81%E7%A8%8B-2.png">
<meta property="og:image" content="https://lonelytaker.cn/2022/02/21/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/%E6%B8%B2%E6%9F%93%E6%B5%81%E7%A8%8B-3.png">
<meta property="og:image" content="https://lonelytaker.cn/2022/02/21/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/%E6%B8%B2%E6%9F%93%E6%B5%81%E7%A8%8B-4.png">
<meta property="og:image" content="https://lonelytaker.cn/2022/02/21/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/%E6%B8%B2%E6%9F%93%E6%B5%81%E7%A8%8B-5.png">
<meta property="og:image" content="https://lonelytaker.cn/2022/02/21/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/%E6%B8%B2%E6%9F%93%E6%B5%81%E7%A8%8B-6.png">
<meta property="og:image" content="https://lonelytaker.cn/2022/02/21/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/%E6%B8%B2%E6%9F%93%E6%B5%81%E7%A8%8B-7.png">
<meta property="og:image" content="https://lonelytaker.cn/2022/02/21/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/%E6%B8%B2%E6%9F%93%E6%B5%81%E7%A8%8B-%E7%BB%BC%E8%BF%B0-1.png">
<meta property="og:image" content="https://lonelytaker.cn/2022/02/21/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/%E6%B8%B2%E6%9F%93%E6%B5%81%E7%A8%8B-%E7%BB%BC%E8%BF%B0-2.jpg">
<meta property="og:image" content="https://lonelytaker.cn/2022/02/21/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/TCP-%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B.png">
<meta property="article:published_time" content="2022-02-21T11:09:20.000Z">
<meta property="article:modified_time" content="2022-03-02T10:48:18.782Z">
<meta property="article:author" content="LonelyTaker">
<meta property="article:tag" content="其他">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://lonelytaker.cn/2022/02/21/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/%E6%B5%8F%E8%A7%88%E5%99%A8-%E7%BB%84%E6%88%90%E7%BB%93%E6%9E%84.png"><title>浏览器工作原理 | LonelyTaker's Blog</title><link ref="canonical" href="https://lonelytaker.cn/2022/02/21/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.12.1/css/all.min.css" type="text/css"><link rel="stylesheet" href="/css/index.css?v=2.6.2"><script>var Stun = window.Stun || {};
var CONFIG = {
  root: '/',
  algolia: undefined,
  assistSearch: undefined,
  fontIcon: {"prompt":{"success":"fas fa-check-circle","info":"fas fa-arrow-circle-right","warning":"fas fa-exclamation-circle","error":"fas fa-times-circle"},"copyBtn":"fas fa-copy"},
  sidebar: {"offsetTop":"20px","tocMaxDepth":6},
  header: {"enable":true,"showOnPost":false,"scrollDownIcon":true},
  postWidget: {"endText":true},
  nightMode: {"enable":true},
  back2top: {"enable":true},
  codeblock: {"style":"default","highlight":"light","wordWrap":false},
  reward: false,
  fancybox: false,
  zoomImage: {"gapAside":"20px"},
  galleryWaterfall: undefined,
  lazyload: false,
  pjax: undefined,
  externalLink: {"icon":{"enable":true,"name":"fas fa-external-link-alt"}},
  shortcuts: undefined,
  prompt: {"copyButton":"复制","copySuccess":"复制成功","copyError":"复制失败"},
  sourcePath: {"js":"js","css":"css","images":"images"},
};

window.CONFIG = CONFIG;</script><meta name="generator" content="Hexo 6.0.0"></head><body><div class="container" id="container"><header class="header" id="header"><div class="header-inner header-inner--height header-inner--bgcolor"><nav class="header-nav header-nav--sticky"><div class="header-nav-inner"><div class="header-nav-menubtn"><i class="fas fa-bars"></i></div><div class="header-nav-menu"><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/"><span class="header-nav-menu-item__icon"><i class="fas fa-home"></i></span><span class="header-nav-menu-item__text">首页</span></a></div><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/archives/"><span class="header-nav-menu-item__icon"><i class="fas fa-folder-open"></i></span><span class="header-nav-menu-item__text">归档</span></a></div><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/categories/"><span class="header-nav-menu-item__icon"><i class="fas fa-layer-group"></i></span><span class="header-nav-menu-item__text">分类</span></a></div><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/tags/"><span class="header-nav-menu-item__icon"><i class="fas fa-tags"></i></span><span class="header-nav-menu-item__text">标签</span></a></div></div><div class="header-nav-mode"><div class="mode"><div class="mode-track"><span class="mode-track-moon"></span><span class="mode-track-sun"></span></div><div class="mode-thumb"></div></div></div></div></nav></div></header><main class="main" id="main"><div class="main-inner"><div class="content-wrap" id="content-wrap"><div class="content" id="content"><!-- Just used to judge whether it is an article page--><div id="is-post"></div><div class="post"><header class="post-header"><h1 class="post-title">浏览器工作原理</h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">发表于</span><span class="post-meta-item__value">2022-02-21</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__info">更新于</span><span class="post-meta-item__value">2022-03-02</span></span></div></header><div class="post-body">
        <h1 id="前置知识">
          <a href="#前置知识" class="heading-link"><i class="fas fa-link"></i></a><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h1>
      
        <h2 id="1-浏览器的组成结构">
          <a href="#1-浏览器的组成结构" class="heading-link"><i class="fas fa-link"></i></a><a href="#1-浏览器的组成结构" class="headerlink" title="(1) 浏览器的组成结构"></a>(1) 浏览器的组成结构</h2>
      <p>浏览器一般由七个模块组成：</p>
<ul>
<li><p>用户界面（ <em>User Interface</em> ）</p>
<p>包括地址栏、后退/前进按钮、书签目录等，也就是除了标签页窗口之外的其他部分。</p>
</li>
<li><p>浏览器引擎（ <em>Browser Engine</em> ）</p>
<p>可以在用户界面和渲染引擎之间传送指令或在客户端本地缓存中读写数据等，是浏览器中各个部分之间相互通信的核心。</p>
</li>
<li><p>渲染引擎（ <em>Rendering Engine</em> ）</p>
<p>渲染引擎负责渲染用户请求的页面内容。在渲染引擎下还有很多小的功能模块，比如网络模块、JS解释器等。</p>
</li>
<li><p>网络（ <em>Networking</em> ）</p>
<p>用来完成网络调用或资源下载的模块。</p>
</li>
<li><p>JS解释器（ <em>JavaScript Interpreter</em> ）</p>
<p>用来解释执行JS脚本的模块。</p>
</li>
<li><p>UI后端（ <em>UI Backend</em> ）</p>
<p>用来绘制基本的浏览器窗口内控件，如输入框、按钮、单选按钮等，根据浏览器不同绘制的视觉效果也不同，但功能都是一样的。</p>
</li>
<li><p>数据持久化存储（ <em>Date Persistence</em> ）</p>
<p>浏览器在硬盘中保存 <em>cookie、localStorage</em> 等各种数据，可通过浏览器引擎提供的API进行调用。</p>
</li>
</ul>
<img src="/2022/02/21/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/%E6%B5%8F%E8%A7%88%E5%99%A8-%E7%BB%84%E6%88%90%E7%BB%93%E6%9E%84.png" class>

<p>从浏览器的组成结构来讲，我们常说的浏览器内核，指的就是渲染引擎。</p>

        <h2 id="2-浏览器的多进程结构">
          <a href="#2-浏览器的多进程结构" class="heading-link"><i class="fas fa-link"></i></a><a href="#2-浏览器的多进程结构" class="headerlink" title="(2) 浏览器的多进程结构"></a>(2) 浏览器的多进程结构</h2>
      
        <h3 id="1-进程-线程">
          <a href="#1-进程-线程" class="heading-link"><i class="fas fa-link"></i></a><a href="#1-进程-线程" class="headerlink" title="1) 进程/线程"></a>1) 进程/线程</h3>
      <p>进程是资源分配的最小单位，线程是CPU调度的最小单位。</p>
<p>早期浏览器是单进程的，单进程导致了许多问题：</p>
<ol>
<li><p>不稳定</p>
<p>一个页面卡死会导致整个浏览器不能正常使用</p>
</li>
<li><p>不安全</p>
<p>浏览器之间共享数据</p>
</li>
<li><p>不流畅</p>
<p>一个进程负责太多的事情，效率低</p>
</li>
</ol>
<p>故现在的浏览器采用了<strong>多进程结构</strong></p>

        <h3 id="2-浏览器的进程">
          <a href="#2-浏览器的进程" class="heading-link"><i class="fas fa-link"></i></a><a href="#2-浏览器的进程" class="headerlink" title="2) 浏览器的进程"></a>2) 浏览器的进程</h3>
      <p>浏览器的主要进程有：（以谷歌浏览器为例）</p>
<ul>
<li><p>浏览器进程（ <em>Browser process</em> ）</p>
<p>控制浏览器除标签页外的用户界面，包括地址栏、书签、后退和前进按钮，以及负责和浏览器的其他进程协调工作。</p>
</li>
<li><p>插件进程（ <em>Plugin process</em> ）</p>
<p>控制网站所使用的所有插件，如Flash。</p>
</li>
<li><p>渲染进程（ <em>Renderer process</em> ）</p>
<p>控制显示tab标签页内的所有内容，主要作用为页面渲染，脚本执行，事件处理等。浏览器在默认情况下会为每个标签页创建一个进程（这取决于浏览器选择的进程模型）</p>
<p>渲染进程是多线程的：</p>
<ul>
<li><p>JS引擎线程</p>
<p>负责处理Javascript脚本程序。</p>
</li>
<li><p>GUI渲染线程</p>
<p>负责渲染标签页内容，解析HTML、CSS，构建DOM树，布局和绘制等。</p>
</li>
<li><p>事件触发线程</p>
<p>主要负责将准备好的事件交给 JS 引擎线程执行，比如 setTimeout 定时器计数结束，ajax 等异步请求成功并触发回调函数，或者用户触发点击事件时，该线程会将整装待发的事件依次加入到任务队列的尾部，等待 JS 引擎线程的执行。</p>
</li>
<li><p>定时触发器线程</p>
<p>负责执行异步定时器一类的函数的线程，如setInterval，setTimeout等。</p>
</li>
<li><p>异步http请求线程</p>
<p>负责异步请求一类的函数的线程，如Promise，axios，ajax等。</p>
</li>
<li><p>…</p>
</li>
</ul>
</li>
<li><p>GPU进程（ <em>GPU process</em> ）</p>
<p>负责整个浏览器界面的渲染。</p>
<blockquote>
<p>其实，Chrome 刚开始发布的时候是没有 GPU 进程的。而 GPU 的使用初衷是为了实现 3D CSS 的效果，只是随后网页、Chrome的UI界面都选择采用 GPU 来绘制，这使得 GPU 成为浏览器普遍的需求。最后，Chrome 在其多进程架构上也引入了 GPU 进程。</p>
</blockquote>
</li>
<li><p>…</p>
</li>
</ul>
<img src="/2022/02/21/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/%E6%B5%8F%E8%A7%88%E5%99%A8-%E5%A4%9A%E8%BF%9B%E7%A8%8B.png" class>

<p>从浏览器的进程角度来讲，浏览器内核指的是渲染进程。</p>
<hr>
<p>从浏览器输入URL开始，到页面渲染完成，浏览器做了哪些事情？</p>
<p>这是一个经典问题，也是作为前端程序员必须要掌握和理解的知识点。</p>
<p>整个过程可以分为以下几步：</p>
<ol>
<li>DNS域名解析</li>
<li>建立TCP连接</li>
<li>发送HTTP请求</li>
<li>服务器处理请求并返回响应</li>
<li>浏览器解析并渲染页面</li>
<li>断开TCP连接</li>
</ol>
<p>接下来我们展开说说，以谷歌浏览器为例。</p>

        <h1 id="1-DNS域名解析">
          <a href="#1-DNS域名解析" class="heading-link"><i class="fas fa-link"></i></a><a href="#1-DNS域名解析" class="headerlink" title="1.DNS域名解析"></a>1.DNS域名解析</h1>
      <p><strong>浏览器进程</strong>的<strong>UI线程</strong>会捕捉输入框输入的内容，如果是网址，则UI线程会启动一个<strong>网络线程</strong>请求DNS进行域名解析；如果输入的不是网址而是关键字，就会使用默认配置的搜索引擎来查询。</p>
<p>我们重点关注DNS域名解析。</p>

        <h2 id="1-域名结构">
          <a href="#1-域名结构" class="heading-link"><i class="fas fa-link"></i></a><a href="#1-域名结构" class="headerlink" title="(1) 域名结构"></a>(1) 域名结构</h2>
      <p>以<code>www.bilibili.com</code>为例，我们通常认为它就是一个域名，但从严格意义上来讲，<code>bilibili.com</code>才是域名，<code>www</code>是服务器名，它表示在<code>bilibili.com</code>域名下，有一台叫做<code>www</code>的服务器。<code>服务器名.域名</code>称为完全限定域名，或者叫<strong>主机名</strong>。一个域名下可以有多个服务器，比如除了<code>www</code>外，<code>bilibili.com</code>域名下还有<code>mail</code>、<code>space</code>等服务器。</p>
<p>域名是由<code>.</code>进行划分的，<code>bilibili.com</code>中<code>bilibili</code>为二级域名，它又受<code>com</code>域名管理。<code>com</code>域名又叫做顶级域名，常见的顶级域名还有<code>cn</code>、<code>edu</code>等。那这些顶级域名又受谁管理呢？其实<code>www.bilibili.com</code>的完整写法应该是<code>www.bilibili.com.root</code>，或者简写成<code>www.bilibili.com.</code>，我们把最后这个<code>.</code>称为根域名，只不过一般我们会把这个<code>.</code>省略。</p>
<p>所以一个主机名的完整结构是：</p>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">服务器名.二级域名.顶级域名.根域名</span><br></pre></td></tr></table></div></figure>

<blockquote>
<p>有些人会把主机名也当做是域名，把服务器名也当做是一级域。所以会产生 <em><span class="exturl"><a class="exturl__link" target="_blank" rel="noopener" href="http://www.baidu.com/">www.baidu.com</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></em> 究竟是二级域名还是三级域名的讨论。这就看个人理解了。如果你认为 <em>baidu.com</em> 才是域名，<em>www</em> 是服务器名，那它就是二级域名；如果认为 <em><span class="exturl"><a class="exturl__link" target="_blank" rel="noopener" href="http://www.baidu.com/">www.baidu.com</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></em> 是域名，那它就是三级域名。</p>
</blockquote>

        <h2 id="2-DNS">
          <a href="#2-DNS" class="heading-link"><i class="fas fa-link"></i></a><a href="#2-DNS" class="headerlink" title="(2) DNS"></a>(2) DNS</h2>
      <p><em>DNS（Domain Name System）</em> ：域名系统。我们知道每一台主机都有一个IP地址，浏览器要想向输入的URL的主机名所对应的服务器发送请求，那就需要知道服务器的IP地址。DNS的作用就是<strong>将主机名转换成IP地址</strong>。</p>
<p>DNS是一个由分层的DNS服务器实现的<strong>分布式数据库</strong>，整个系统由分散在世界各地的许多台DNS服务器组成，每台DNS服务器上都保存了一些数据，这些数据能够让我们最终查询到主机名对应的IP。</p>
<p>所以，DNS域名解析，本质上就是去向DNS服务器查询IP地址。</p>

        <h2 id="3-DNS服务器">
          <a href="#3-DNS服务器" class="heading-link"><i class="fas fa-link"></i></a><a href="#3-DNS服务器" class="headerlink" title="(3) DNS服务器"></a>(3) DNS服务器</h2>
      <p>DNS服务器，也叫做<strong>域名服务器</strong>。</p>
<p>它有3种类型：</p>
<ul>
<li><p>根域名服务器</p>
<p>它的作用就是管理下一级，也就是顶级域名服务器。通过查询根域名服务器，我们可以知道一个主机名所对应的顶级域名服务器IP是多少，再继续向顶级域名服务器发起查询请求。</p>
</li>
<li><p>顶级域名服务器</p>
<p><em>Top Level Domain（TLD）</em>：顶级域名服务器。除了刚刚提到的<code>com</code>外，常见的顶级域名还有<code>cn</code>、<code>org</code>、<code>edu</code>等。顶级域名服务器提供了下一级权威域名服务器的IP地址。</p>
</li>
<li><p>权威域名服务器</p>
<p>权威域名服务器管理自己域名下主机（服务器）的IP地址，最终可以返回<code>主机名 - IP</code>的映射。</p>
</li>
</ul>
<p>层次结构图：</p>
<img src="/2022/02/21/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/DNS-DNS%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84.png" class>



<p>除了上述讲到的三种类型的DNS服务器，还有一个<strong>本地域名服务器</strong>，但是严格来讲，本地域名服务器并不属于DNS服务器的层次结构，但是它对DNS有着重要作用。当主机发起DNS请求时，该请求会被发送到本地域名服务器，本地域名服务器起着<strong>代理</strong>的作用，负责将该请求<strong>转发</strong>到DNS服务器的层次结构中。</p>
<p>下面我们还是用一个例子展示DNS的查询过程。</p>

        <h2 id="4-查询过程">
          <a href="#4-查询过程" class="heading-link"><i class="fas fa-link"></i></a><a href="#4-查询过程" class="headerlink" title="(4) 查询过程"></a>(4) 查询过程</h2>
      <p>假设想要获取<code>www.bilibili.com</code>的IP地址。</p>
<ol>
<li><p>首先主机会向本地域名服务器发送一个DNS查询报文，其中包含了需要被转换的主机名<code>www.bilibili.com</code>。</p>
</li>
<li><p>本地域名服务器将该报文转发到根域名服务器。</p>
<p>注意：根域名服务器不止一台，全球共有13台根域名服务器，本地域名服务器会找最近的根域名服务器。</p>
</li>
<li><p>根域名服务器注意到该主机名的<code>com</code>前缀，就会向本地域名服务器返回<code>com</code>所对应的顶级域名服务器的IP地址<strong>列表</strong>。</p>
<p>意思就是，我并不知道<code>www.bilibili.com</code>的IP，不过这些顶级域名服务器可能知道，你去问下他们吧。</p>
</li>
<li><p>本地域名服务器就向那些顶级域名服务器发送查询报文。</p>
</li>
<li><p>顶级域名服务器注意到了<code>bilibili.com</code>的前缀，就会向本地域名服务器返回对应的权威域名服务器的IP地址列表。</p>
<p>意思就是，我并不知道<code>www.bilibili.com</code>的IP，不过这些权威域名服务器可能知道，你去问下他们吧。</p>
</li>
<li><p>本地域名服务器就向那些权威域名服务器发送查询报文。</p>
</li>
<li><p>最终在某一权威服务器中找到并返回<code>www.bilibili.com</code>的IP地址。</p>
<p>注意：如果域名被注册，必然能在域名服务器中找到对应的IP地址。</p>
</li>
</ol>
<img src="/2022/02/21/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/DNS-%E6%9F%A5%E8%AF%A2%E8%BF%87%E7%A8%8B-%E8%BF%AD%E4%BB%A3.png" class>

<p>如图所示，本地域名服务器向其他域名服务器发送查询请求的方式，就是<strong>迭代查询</strong>，所有请求都是由本地域名服务器发出，并且所有的响应都是直接返回给本地域名服务器。</p>
<p>还有另外一种查询方式叫做<strong>递归查询</strong>，如图：</p>
<img src="/2022/02/21/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/DNS-%E6%9F%A5%E8%AF%A2%E8%BF%87%E7%A8%8B-%E9%80%92%E5%BD%92.png" class>

<p>响应结果并不直接返回给本地域名服务器，而是由当前域名服务器向下一级域名服务器继续查找，直到找到目标IP地址，再逐级返回。</p>

        <h2 id="5-DNS缓存">
          <a href="#5-DNS缓存" class="heading-link"><i class="fas fa-link"></i></a><a href="#5-DNS缓存" class="headerlink" title="(5) DNS缓存"></a>(5) DNS缓存</h2>
      <p>为了更快地获得IP，DNS广泛使用了缓存技术。</p>
<ol>
<li>在本地DNS服务器向根DNS服务器查询请求前，它会先去浏览器自身的DNS缓存中查找，如果存在，则解析结束。</li>
<li>如果浏览器自身的DNS缓存中没有，那么会尝试去读取操作系统中的hosts文件，看看是否有对应的映射关系，如果存在，则解析结束。</li>
<li>如果本地hosts文件中没有，则去查找本地DNS服务器（ISP服务器，或者自己手动设置的DNS服务器）中的DNS缓存，如果存在，则解析结束。</li>
<li>如果上述三步中都不存在相应缓存，就开始进行查询请求。</li>
</ol>
<img src="/2022/02/21/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/DNS-%E7%BC%93%E5%AD%98.png" class>




        <h1 id="2-建立TCP连接">
          <a href="#2-建立TCP连接" class="heading-link"><i class="fas fa-link"></i></a><a href="#2-建立TCP连接" class="headerlink" title="2.建立TCP连接"></a>2.建立TCP连接</h1>
      <p>通过DNS域名解析，获取到目标IP地址后，需要和其建立TCP连接，也就是我们常说的三次握手。</p>

        <h2 id="1-格式">
          <a href="#1-格式" class="heading-link"><i class="fas fa-link"></i></a><a href="#1-格式" class="headerlink" title="(1) 格式"></a>(1) 格式</h2>
      <p>TCP头部格式：</p>
<img src="/2022/02/21/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/TCP.jpg" class>

<p>其中有6个标志位：</p>
<ul>
<li>SYN（synchronous 建立联机）</li>
<li>ACK（acknowledgement  确认）</li>
<li>PSH（push 传送）</li>
<li>FIN（finish 结束）</li>
<li>RST（reset 重置）</li>
<li>URG（urgent 紧急）</li>
</ul>

        <h2 id="2-三次握手">
          <a href="#2-三次握手" class="heading-link"><i class="fas fa-link"></i></a><a href="#2-三次握手" class="headerlink" title="(2) 三次握手"></a>(2) 三次握手</h2>
      <img src="/2022/02/21/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/TCP-%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B.png" class>

<ol>
<li><p>SYN连接请求(客户端)</p>
<p>主机A发送<code>seq=x，SYN=1</code>的数据包给主机B，其中<code>seq=x</code>表示这条数据包的序号。</p>
<p>这就是第一次握手，由客户端发出，服务端接收。</p>
</li>
<li><p>SYN、ACK确认(服务端)</p>
<p>主机B接收到后根据<code>SYN=1</code>知道了A要求建立连接。向A发送<code>seq=y，ack=x+1，SYN=1，ACK=1</code>的数据包，其中<code>seq=y</code>表示这条数据包的序号，<code>ack=x+1</code>表示这条数据包是对主机A之前发送的<code>seq=x</code>的数据包的确认，只有标志位<code>ACK=1</code>时，这个确认序列号，也就是<code>ack</code>才是有效的。</p>
<p>相当于告诉主机A我已经准备好了。这就是第二次握手，由服务端发出，客户端接收。</p>
</li>
<li><p>ACK确认(客户端)</p>
<p>主机A收到后，检查<code>ACK</code>是否为1，如果是，继续检查<code>ack</code>是否正确，即第一次发送数据包的<code>seq+1</code>，同时检查<code>SYN</code>是否为1，如果都满足，则再次发送一条<code>seq=x+1，ack=y+1，ACK=1</code>的数据包，其中<code>seq=x+1</code>表示这条数据包的序号，<code>ack=y+1</code>表示这条数据包是对主机B返回的<code>seq=y</code>的数据包的确认。主机B收到后，检查<code>ACK、ack</code>是否正确，如果正确则连接建立成功。</p>
<p>这就是第三次握手，由客户端发出，服务端接收。</p>
</li>
</ol>
<blockquote>
<p>为什么要三次握手？</p>
<p>其实这是由 TCP 自身可靠传输的特点决定的。客户端和服务端要进行可靠传输，那么就需要确认双方的接收和发送能力。第一次握手可以确认客户端的发送能力，第二次握手，确认了服务端的发送能力和接收能力，所以第三次握手才可以确认客户端的接收能力。不然容易出现丢包的现象。</p>
</blockquote>

        <h1 id="3-发送HTTP请求">
          <a href="#3-发送HTTP请求" class="heading-link"><i class="fas fa-link"></i></a><a href="#3-发送HTTP请求" class="headerlink" title="3.发送HTTP请求"></a>3.发送HTTP请求</h1>
      <p>在成功和服务端建立连接之后，就可以发送http请求了。</p>

        <h2 id="1-格式-1">
          <a href="#1-格式-1" class="heading-link"><i class="fas fa-link"></i></a><a href="#1-格式-1" class="headerlink" title="(1) 格式"></a>(1) 格式</h2>
      <p><strong>请求报文：</strong></p>
<figure class="highlight javascript"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">行:GET url HTTP/<span class="number">1.1</span></span><br><span class="line">头:Content-Type:application/x-www-form-urlencoded</span><br><span class="line">空行</span><br><span class="line">体:...</span><br></pre></td></tr></table></div></figure>

<p><strong>响应报文：</strong></p>
<figure class="highlight javascript"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">行:HTTP/<span class="number">1.1</span> <span class="number">200</span> OK</span><br><span class="line">头:Content-Type: text/plain; charset=UTF-<span class="number">8</span></span><br><span class="line">空行</span><br><span class="line">体:...</span><br></pre></td></tr></table></div></figure>




        <h2 id="2-状态码">
          <a href="#2-状态码" class="heading-link"><i class="fas fa-link"></i></a><a href="#2-状态码" class="headerlink" title="(2) 状态码"></a>(2) 状态码</h2>
      <div class="table-container"><table>
<thead>
<tr>
<th>状态码</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>1xx</td>
<td>服务器收到请求</td>
</tr>
<tr>
<td>2xx</td>
<td>请求成功</td>
</tr>
<tr>
<td>3xx</td>
<td>重定向</td>
</tr>
<tr>
<td>4xx</td>
<td>客户端错误</td>
</tr>
<tr>
<td>5xx</td>
<td>服务端错误</td>
</tr>
</tbody></table></div>

        <h2 id="3-HTTP缓存">
          <a href="#3-HTTP缓存" class="heading-link"><i class="fas fa-link"></i></a><a href="#3-HTTP缓存" class="headerlink" title="(3) HTTP缓存"></a>(3) HTTP缓存</h2>
      <p>什么是HTTP缓存？当客户端向服务端请求资源时，会先去缓存中找，如果缓存中存在该资源的副本，则直接从缓存中提取而不是去向服务端请求。</p>
<p>为什么需要HTTP缓存？因为网络请求相比较于CPU的计算和页面渲染是非常慢的。使用缓存可以加快页面加载速度，同时减少服务器的负担。</p>
<p>哪些资源可以被缓存？静态资源，比如js、css、图片等。</p>
<blockquote>
<p>HTTP缓存和DNS缓存是不一样的，DNS缓存记录的是主机名到IP的映射关系，HTTP缓存的是静态资源。除此之外，还有一个浏览器缓存，即<em>Cookie、SessionStorage、LocalStorage</em>等，不过这不是本文重点，感兴趣的可以另行查看。</p>
</blockquote>
<p>HTTP缓存又两种类型：</p>
<ul>
<li>强缓存</li>
<li>协商缓存</li>
</ul>
<p>下面我们依次介绍</p>

        <h3 id="1-强缓存">
          <a href="#1-强缓存" class="heading-link"><i class="fas fa-link"></i></a><a href="#1-强缓存" class="headerlink" title="1) 强缓存"></a>1) 强缓存</h3>
      <p>强缓存就是向浏览器HTTP缓存查找该请求结果，并根据该结果的缓存规则来决定是否使用该结果的过程。</p>
<p>简单来讲，就是去设置资源的有效时间，当再次请求相同资源时，如果缓存仍然有效，直接从缓存中读取资源。</p>
<p>强缓存分了两种方式：<code>Expires</code>和<code>Cache-Control</code></p>
<ul>
<li><em>Expries</em><ul>
<li>版本：HTTP/1.0</li>
<li>来源：存在于服务端返回的响应头中</li>
<li>语法：Expires: Wed, 22 Nov 2019 08:41:00 GMT</li>
<li>缺点：服务器的时间和浏览器的时间可能并不一致导致失效</li>
</ul>
</li>
<li><em>Cache-Control</em><ul>
<li>版本：HTTP/1.1</li>
<li>来源：响应头和请求头</li>
<li>语法：Cache-Control:max-age=3600</li>
</ul>
</li>
</ul>
<p>当前HTTP版本为1.1，所以强缓存更多的是采用 <em>Cache-Control</em>，我们重点来聊 <em>Cache-Control</em>。它的具体表现就是在请求头和响应头中添加了 <em>Cache-Control</em> 字段，用来判断该资源的缓存规则。</p>
<p>该字段常见的值如下：</p>
<div class="table-container"><table>
<thead>
<tr>
<th>值</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>max-age=delta-seconds</td>
<td>缓存最大过期时间为delta-seconds秒</td>
</tr>
<tr>
<td>no-cache</td>
<td>客户端可以存储资源，但是每次都要去和服务端做新鲜度校验，来决定是重新获取还是直接使用缓存</td>
</tr>
<tr>
<td>no-store</td>
<td>永远不在客户端存储资源，永远都是去原始服务器去获取资源</td>
</tr>
</tbody></table></div>
<img src="/2022/02/21/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/http-%E5%BC%BA%E7%BC%93%E5%AD%98-Cache-Control.png" class>

<blockquote>
<p>注意：虽然请求头和响应头中都能设置 <em>Cache-Control</em> 字段，但一般是响应头发挥作用，比如请求头设置max-age为60s，响应头设置为30s，最后结果是30s缓存就失效了，也就是说服务端的设置决定了缓存的有效时间，另外，只有服务端有能力开启缓存，如果请求头设置 <em>Cache-Control</em>，而服务端不设置，缓存是不生效的。那么请求头中的 <em>Cache-Control</em> 有什么用呢？只有请求头中设置了 <em>Cache-Control</em> 值为no-store或者no-cache或者max-age=0，也就是客户端不想要走强缓存，那这个 <em>Cache-Control</em> 才是有用的。</p>
</blockquote>

        <h3 id="2-协商缓存">
          <a href="#2-协商缓存" class="heading-link"><i class="fas fa-link"></i></a><a href="#2-协商缓存" class="headerlink" title="2) 协商缓存"></a>2) 协商缓存</h3>
      <p>协商缓存就是在强制缓存失效后，浏览器携带缓存标识向服务器发起请求，由服务器根据缓存标识是否决定使用缓存的过程。</p>
<p>简单来讲，就是当强缓存失效时，我们需要去判断缓存中的资源是否仍然有效，如果仍然有效，依旧从缓存中读取资源。</p>
<p>协商缓存也有两种：</p>
<ul>
<li><p><em>Last-Modified / if-Modified-Since</em></p>
<ul>
<li>意义：资源最后修改时间</li>
<li>来源：<em>Last-Modified</em> 在响应头中，<em>if-Modified-Since</em> 在请求头中</li>
<li>判断：如果这两个值相同，表示资源并没有更新过，返回304；不一致则表示资源更新过，就返回200和新的资源以及新的 <em>Last-Modified</em></li>
</ul>
<img src="/2022/02/21/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/http-%E5%8D%8F%E5%95%86%E7%BC%93%E5%AD%98-Last-Modified.png" class></li>
<li><p><em>Etag / if-None-Match</em></p>
<ul>
<li>意义：资源的唯一标识（一个字符串，类似于人类的指纹）</li>
<li>来源：<em>Etag</em> 在响应头中，<em>if-None-Match</em> 在请求头中</li>
<li>判断： 如果这两个值相同，表示资源并没有更新过，返回304；不一致则表示资源更新过，就返回200和新的资源以及新的 <em>Etag</em></li>
</ul>
<img src="/2022/02/21/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/http-%E5%8D%8F%E5%95%86%E7%BC%93%E5%AD%98-Etag.png" class></li>
</ul>
<p>那么这两种方式有什么区别呢？其实 <em>Etag</em> 和 <em>Last-Modified</em> 判断资源的方式是一样，只不过后者是一个时间，前者是对资源按照一定方式计算出来的唯一标识，如果资源发生了更新，这个唯一标识必然会有变化。</p>
<p>两者比较：</p>
<ol>
<li>优先使用 <em>Etag</em></li>
<li><em>Last-Modified</em> 只能精确到秒</li>
<li>如果资源重复生成，但内容不变，使用 <em>Etag</em> 更精确</li>
</ol>

        <h3 id="3-综合流程">
          <a href="#3-综合流程" class="heading-link"><i class="fas fa-link"></i></a><a href="#3-综合流程" class="headerlink" title="3) 综合流程"></a>3) 综合流程</h3>
      <img src="/2022/02/21/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/http-%E7%BC%93%E5%AD%98-%E6%B5%81%E7%A8%8B.png" class>




        <h3 id="4-页面刷新对HTTP缓存的影响">
          <a href="#4-页面刷新对HTTP缓存的影响" class="heading-link"><i class="fas fa-link"></i></a><a href="#4-页面刷新对HTTP缓存的影响" class="headerlink" title="4) 页面刷新对HTTP缓存的影响"></a>4) 页面刷新对HTTP缓存的影响</h3>
      <p>有三中刷新类型：</p>
<ul>
<li><p>正常操作：浏览器输入url、连接跳转、前进后退</p>
<p>强制缓存和协商缓存都有效</p>
</li>
<li><p>手动刷新：f5、点击刷新按钮、右键菜单刷新</p>
<p>强制缓存失效，协商缓存有效</p>
</li>
<li><p>强制刷新：ctrl + f5、shift + command + r</p>
<p>强制缓存和协商缓存都失效</p>
</li>
</ul>

        <h1 id="4-服务器处理请求并返回响应">
          <a href="#4-服务器处理请求并返回响应" class="heading-link"><i class="fas fa-link"></i></a><a href="#4-服务器处理请求并返回响应" class="headerlink" title="4.服务器处理请求并返回响应"></a>4.服务器处理请求并返回响应</h1>
      <p>每台服务器上都会安装处理请求的应用—— <em>Web Server</em> 。常见的 <em>Web Server</em> 产品有 <code>apache</code>、<code>nginx</code>、<code>IIS</code> 或 <code>Lighttpd</code> 等。</p>
<p>HTTP请求一般可以分为两类，静态资源和动态资源。</p>
<p>请求访问静态资源，这个就直接根据url地址去服务器里找就好了。</p>
<p>请求动态资源的话，就需要 <em>web server</em> 把不同请求，委托给服务器上处理相应请求的程序进行处理，然后返回后台程序处理产生的结果作为响应，发送到客户端。</p>

        <h1 id="5-浏览器解析并渲染页面">
          <a href="#5-浏览器解析并渲染页面" class="heading-link"><i class="fas fa-link"></i></a><a href="#5-浏览器解析并渲染页面" class="headerlink" title="5.浏览器解析并渲染页面"></a>5.浏览器解析并渲染页面</h1>
      <p>当网络线程获取到数据后，终于要开始渲染页面了。</p>
<p>（如果是谷歌浏览器，当网络线程获取到数据后，需要通过<strong>SafeBrowsing</strong>检查站点是否是恶意站点，SafeBrowsing是谷歌内部的一套站点安全系统，通过检测该站点的数据来判断是否安全，通过安全校验后，才进入渲染流程）</p>

        <h2 id="1-渲染流程">
          <a href="#1-渲染流程" class="heading-link"><i class="fas fa-link"></i></a><a href="#1-渲染流程" class="headerlink" title="(1) 渲染流程"></a>(1) 渲染流程</h2>
      <ol>
<li><p>浏览器进程会启动一个<strong>渲染进程</strong>，并将数据（也就是html）通过<strong>IPC管道</strong>传递给渲染进程，正式开始渲染流程。</p>
<blockquote>
<p>渲染进程的核心任务就是把html、css、js、图片等资源渲染成用户能交互的web页面。</p>
</blockquote>
</li>
<li><p>渲染进程的主线程会将html进行解析，构造<strong>DOM数据结构</strong>，html首先通过<strong>Tokeniser标记化</strong>，通过语法分析将html内容解析成多个标记，根据识别后的标记进行<strong>DOM树构造</strong>，DOM树构造过程中会创建<strong>document对象</strong>，然后以document对象为根节点的DOM树不断进行修改，向其中添加各种元素。</p>
<blockquote>
<p>html中引入的其他资源，如图片、css、js等，图片和CSS等需要通过<strong>http请求下载</strong>或者从<strong>http缓存</strong>中直接加载，这些资源不会阻塞html的解析，因为它们不会影响DOM的生成，但如果解析过程中遇到script标签，就会暂停解析，<strong>先去加载解析并执行js脚本</strong>，因为js中可能会改变当前页面html结构。或者使用 <em>async</em> 或者 <em>defer</em> 属性来异步加载执行js。</p>
<p>主线程就是指JS引擎线程和GUI渲染线程，这两个线程是互斥的，JS引擎线程执行时，GUI渲染线程不执行，反之亦然。</p>
</blockquote>
<img src="/2022/02/21/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/%E6%B8%B2%E6%9F%93%E6%B5%81%E7%A8%8B-1.png" class></li>
<li><p>DOM树构建完毕后，主线程需要解析CSS并确定每个DOM节点的<strong>计算样式</strong>。</p>
<blockquote>
<p>即使你没有自定义样式，浏览器也会有自己的默认样式表。</p>
</blockquote>
<img src="/2022/02/21/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/%E6%B8%B2%E6%9F%93%E6%B5%81%E7%A8%8B-2.png" class></li>
<li><p>在知道DOM结构和每个节点的样式后，我们接下来需要知道每个节点放在页面上的哪个位置，也就是节点的坐标以及该节点需要占用多大的区域，这一阶段叫做<strong>Layout布局</strong>，主线程通过遍历DOM树和计算好的样式来生成<strong>Layout树</strong>，Layout树上的每个节点都记录了x，y坐标和边框尺寸。</p>
<blockquote>
<p>DOM树和Layout树并不是一一对应的，如设置了 <em>display:none</em> 的元素不会出现在Layout树中，而在 <em>before</em> 伪元素中添加了 <em>content</em> 值的元素，<em>content</em> 中的内容会出现在Layout树中，不会出现在DOM树中。这是因为DOM树是根据解析html所得，并不关心样式；而Layout树是根据DOM节点和计算好的样式来生成，和最终展示在页面上的节点是对应的。</p>
</blockquote>
<img src="/2022/02/21/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/%E6%B8%B2%E6%9F%93%E6%B5%81%E7%A8%8B-3.png" class></li>
<li><p>Layout树创建完毕后，我们还需要知道这些元素要以什么样的顺序进行绘制（比如z-index就会影响绘制顺序），主线程遍历Layout树，创建一个<strong>绘制记录表</strong>，该表记录了绘制的顺序，这个阶段称为**绘制(Paint)**。</p>
<img src="/2022/02/21/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/%E6%B8%B2%E6%9F%93%E6%B5%81%E7%A8%8B-4.png" class></li>
<li><p>现在知道了元素的绘制顺序，就到了需要把这些信息真正转化成像素点，显示到屏幕上的时候了，这个阶段称为**栅格化(光栅化)**。</p>
</li>
<li><p>主线程遍历Layout树，生成<strong>Layer(图层)树</strong>，将这些信息传递给<strong>合成器线程</strong>，合成器线程将每个图层栅格化，生成<strong>合成器帧</strong>。</p>
<blockquote>
<p>早期的Chrome栅格化方案：只栅格化页面显示的内容，当页面滚动时，再栅格化更多的内容来填充缺失的部分，这种方式会导致展示延迟。</p>
<p>现在的Chrome采用更为复杂的栅格化方案，称为<strong>合成</strong>：将页面内的各个部分分成多个图层，分别对其进行栅格化，并在合成器线程中单独合成页面。上述操作即采用该方案。</p>
</blockquote>
<img src="/2022/02/21/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/%E6%B8%B2%E6%9F%93%E6%B5%81%E7%A8%8B-5.png" class>

<img src="/2022/02/21/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/%E6%B8%B2%E6%9F%93%E6%B5%81%E7%A8%8B-6.png" class></li>
<li><p>合成器帧通过IPC传送给<strong>浏览器进程</strong>，接着浏览器进程将合成器帧传送到<strong>GPU</strong>，最终渲染展示到屏幕上。当页面发生变化，如滚动了页面，合成器线程则会生成一个新的合成器帧，再重复上述操作。</p>
<img src="/2022/02/21/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/%E6%B8%B2%E6%9F%93%E6%B5%81%E7%A8%8B-7.png" class></li>
</ol>
<p>综述：</p>
<img src="/2022/02/21/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/%E6%B8%B2%E6%9F%93%E6%B5%81%E7%A8%8B-%E7%BB%BC%E8%BF%B0-1.png" class>

<img src="/2022/02/21/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/%E6%B8%B2%E6%9F%93%E6%B5%81%E7%A8%8B-%E7%BB%BC%E8%BF%B0-2.jpg" class>





        <h2 id="2-重排-重绘">
          <a href="#2-重排-重绘" class="heading-link"><i class="fas fa-link"></i></a><a href="#2-重排-重绘" class="headerlink" title="(2) 重排/重绘"></a>(2) 重排/重绘</h2>
      <ul>
<li><p><strong>重排</strong></p>
<p>当改变一个元素的尺寸位置属性时，会重新进行样式计算、布局(Layout)、绘制(Paint)以及后面的所有流程，这个行为称为重排，也叫作<strong>回流(reflow)</strong></p>
</li>
<li><p><strong>重绘</strong></p>
<p>当改变某个元素的颜色属性时，不会重新触发布局(Layout)，但还是会触发样式计算和绘制(Paint)，这个行为称为<strong>重绘(repaint)</strong></p>
</li>
</ul>
<blockquote>
<p>重排一定会引起重绘，而重绘不一定会引起重排。</p>
</blockquote>
<p>由于重排重绘会占用主线程、同时JS也会抢占主线程，这就会导致页面出现卡顿情况。同时，大量的重排重绘会造成额外的计算消耗。所以要尽量减少重排重绘。那么该如何减少重排重绘呢？</p>
<ul>
<li>最小化重排重绘，比如样式集中改变，使用添加新样式类名<code>.class</code>或<code>cssText</code></li>
<li>批量操作DOM，比如读取某元素 <code>offsetWidth</code> 属性存到一个临时变量，再去使用，而不是频繁使用这个计算属性；又比如利用 <code>document.createDocumentFragment()</code> 来添加要被添加的节点，处理完之后再插入到实际 DOM 中。</li>
<li>使用 <code>absolute</code> 或 <code>fixed</code>使元素脱离文档流，这在制作复杂的动画时对性能的影响比较明显。</li>
<li>开启GPU加速，利用 css 属性 <code>transform</code> 、<code>will-change</code> 等，因为它们不会触发重排重绘。</li>
</ul>

        <h1 id="6-断开TCP连接">
          <a href="#6-断开TCP连接" class="heading-link"><i class="fas fa-link"></i></a><a href="#6-断开TCP连接" class="headerlink" title="6.断开TCP连接"></a>6.断开TCP连接</h1>
      <p>当所有操作完，关闭页面，就会断开TCP连接。也就是我们常说的四次挥手。</p>
<blockquote>
<p>http1.1是默认不断开TCP连接的，因为连接建立需要耗费资源，多个HTTP请求会复用TCP通道。所以当页面关闭时，TCP连接才断开。</p>
</blockquote>

        <h2 id="1-四次挥手">
          <a href="#1-四次挥手" class="heading-link"><i class="fas fa-link"></i></a><a href="#1-四次挥手" class="headerlink" title="(1) 四次挥手"></a>(1) 四次挥手</h2>
      <img src="/2022/02/21/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/TCP-%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B.png" class>

<p>首先要明确一点，客户端和服务端都可以发起关闭连接请求。我们假设是客户端发起关闭请求。</p>
<ol>
<li><p>FIN请求（客户端）</p>
<p>主机A发送一条<code>seq=x，FIN=1</code>的数据包给主机B，其中<code>seq=x</code>表示这条数据包的序号。</p>
<p>这就是第一次挥手。</p>
</li>
<li><p>ACK确认（服务端）</p>
<p>主机B接收到后根据<code>FIN=1</code>知道要断开连接。向A发送一条<code>seq=y，ack=x+1，ACK=1</code>的数据包，其中<code>seq=y</code>表示这条数据包的序号，<code>ack=x+1</code>表示这条数据包是对主机A<code>seq=x</code>的数据包的确认。</p>
<p>这就是第二次挥手。告诉对方我已经知道了。但是这时候还没有立刻关闭，而是处于一个<code>关闭等待</code>的状态。因为这时候服务端可能还在发送数据，只有数据发送完了才能发送FIN数据包。</p>
</li>
<li><p>FIN、ACK确认（服务端）</p>
<p>当数据发送完毕，主机B发送一条<code>seq=z，ack=x+1，ACK=1，FIN=1</code>的数据包给主机A，其中<code>seq=z</code>表示这条数据包的序号，<code>ack=x+1</code>表示这条数据包是对主机A<code>seq=x</code>的数据包的确认。</p>
<p>这就是第三次挥手。</p>
</li>
<li><p>ACK确认（客户端）</p>
<p>主机A接收到后，检查<code>ACK</code>是否为1，<code>ack</code>是否为第一次发送数据包的<code>seq+1</code>，检查<code>FIN</code>是否为1，如果都正确，主机A向主机B发送一条<code>seq=x+1，ack=z+1，ACK=1</code>的数据包。主机B收到后，检查<code>ack、ACK</code>是否正确，正确则关闭连接。</p>
<p>这就是第四次挥手。</p>
<blockquote>
<p>客户端在发送ACK数据包后，不是立刻就关闭连接，而是需要等待一段时间，因为虽然理论上四个数据包发送完毕就可以直接关闭连接了，但是网络是不可靠的，可能存在最后这个ACK数据包没有被服务端接收到的情况，服务端在长时间没有收到ACK数据包后，会重新发送一次FIN数据包。如果客户端在发送ACK数据包后立刻关闭连接，就无法收到这条重发的FIN数据包，导致服务端关闭连接失败，造成资源的浪费。所以客户端在发送ACK数据包后，需要等待一段时间，等待时间长度为2MSL，MSL（ <em>Maximum Segment Life</em> ）是TCP对数据包生存时间的限制，发送后超过这个时间还未被接收到，就认为这个数据包丢失，2MSL能确保客户端收到重发的FIN数据包。</p>
</blockquote>
</li>
</ol>
<blockquote>
<p>参考：</p>
<p><span class="exturl"><a class="exturl__link" target="_blank" rel="noopener" href="https://blog.csdn.net/BonJean/article/details/78453547">https://blog.csdn.net/BonJean/article/details/78453547</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
<p><span class="exturl"><a class="exturl__link" target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/102149546">https://zhuanlan.zhihu.com/p/102149546</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
<p><span class="exturl"><a class="exturl__link" target="_blank" rel="noopener" href="https://juejin.cn/post/6935232082482298911">https://juejin.cn/post/6935232082482298911</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
<p><span class="exturl"><a class="exturl__link" target="_blank" rel="noopener" href="https://juejin.cn/post/6990344840181940261">https://juejin.cn/post/6990344840181940261</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
<p><span class="exturl"><a class="exturl__link" target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1x54y1B7RE">https://www.bilibili.com/video/BV1x54y1B7RE</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
<p><span class="exturl"><a class="exturl__link" target="_blank" rel="noopener" href="https://juejin.cn/post/6844903779700047885">https://juejin.cn/post/6844903779700047885</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
<p><span class="exturl"><a class="exturl__link" target="_blank" rel="noopener" href="https://www.imooc.com/wenda/detail/499811">https://www.imooc.com/wenda/detail/499811</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
<p><span class="exturl"><a class="exturl__link" target="_blank" rel="noopener" href="https://juejin.cn/post/7061588533214969892">https://juejin.cn/post/7061588533214969892</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
</blockquote>
</div><footer class="post-footer"><div class="post-ending ending"><div class="ending__text">------ 本文结束，感谢您的阅读 ------</div></div><div class="post-copyright copyright"><div class="copyright-author"><span class="copyright-author__name">本文作者: </span><span class="copyright-author__value"><a href="https://lonelytaker.cn">LonelyTaker</a></span></div><div class="copyright-link"><span class="copyright-link__name">本文链接: </span><span class="copyright-link__value"><a href="https://lonelytaker.cn/2022/02/21/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/">https://lonelytaker.cn/2022/02/21/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/</a></span></div><div class="copyright-notice"><span class="copyright-notice__name">版权声明: </span><span class="copyright-notice__value">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.en" rel="external nofollow" target="_blank">BY-NC-SA</a> 许可协议。转载请注明出处！</span></div></div><div class="post-tags"><span class="post-tags-item"><span class="post-tags-item__icon"><i class="fas fa-tag"></i></span><a class="post-tags-item__link" href="https://lonelytaker.cn/tags/%E5%85%B6%E4%BB%96/">其他</a></span></div><nav class="post-paginator paginator"><div class="paginator-next"><a class="paginator-next__link" href="/2022/02/21/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"><span class="paginator-prev__text">计算机网络</span><span class="paginator-next__icon"><i class="fas fa-angle-right"></i></span></a></div></nav></footer></div></div></div><div class="sidebar-wrap" id="sidebar-wrap"><aside class="sidebar" id="sidebar"><div class="sidebar-nav"><span class="sidebar-nav-toc current">文章目录</span><span class="sidebar-nav-ov">站点概览</span></div><section class="sidebar-toc"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%89%8D%E7%BD%AE%E7%9F%A5%E8%AF%86"><span class="toc-text">
          前置知识</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9A%84%E7%BB%84%E6%88%90%E7%BB%93%E6%9E%84"><span class="toc-text">
          (1) 浏览器的组成结构</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9A%84%E5%A4%9A%E8%BF%9B%E7%A8%8B%E7%BB%93%E6%9E%84"><span class="toc-text">
          (2) 浏览器的多进程结构</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E8%BF%9B%E7%A8%8B-%E7%BA%BF%E7%A8%8B"><span class="toc-text">
          1) 进程&#x2F;线程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9A%84%E8%BF%9B%E7%A8%8B"><span class="toc-text">
          2) 浏览器的进程</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#1-DNS%E5%9F%9F%E5%90%8D%E8%A7%A3%E6%9E%90"><span class="toc-text">
          1.DNS域名解析</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E5%9F%9F%E5%90%8D%E7%BB%93%E6%9E%84"><span class="toc-text">
          (1) 域名结构</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-DNS"><span class="toc-text">
          (2) DNS</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-DNS%E6%9C%8D%E5%8A%A1%E5%99%A8"><span class="toc-text">
          (3) DNS服务器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-%E6%9F%A5%E8%AF%A2%E8%BF%87%E7%A8%8B"><span class="toc-text">
          (4) 查询过程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-DNS%E7%BC%93%E5%AD%98"><span class="toc-text">
          (5) DNS缓存</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#2-%E5%BB%BA%E7%AB%8BTCP%E8%BF%9E%E6%8E%A5"><span class="toc-text">
          2.建立TCP连接</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E6%A0%BC%E5%BC%8F"><span class="toc-text">
          (1) 格式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B"><span class="toc-text">
          (2) 三次握手</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#3-%E5%8F%91%E9%80%81HTTP%E8%AF%B7%E6%B1%82"><span class="toc-text">
          3.发送HTTP请求</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E6%A0%BC%E5%BC%8F-1"><span class="toc-text">
          (1) 格式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E7%8A%B6%E6%80%81%E7%A0%81"><span class="toc-text">
          (2) 状态码</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-HTTP%E7%BC%93%E5%AD%98"><span class="toc-text">
          (3) HTTP缓存</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E5%BC%BA%E7%BC%93%E5%AD%98"><span class="toc-text">
          1) 强缓存</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E5%8D%8F%E5%95%86%E7%BC%93%E5%AD%98"><span class="toc-text">
          2) 协商缓存</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E7%BB%BC%E5%90%88%E6%B5%81%E7%A8%8B"><span class="toc-text">
          3) 综合流程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E9%A1%B5%E9%9D%A2%E5%88%B7%E6%96%B0%E5%AF%B9HTTP%E7%BC%93%E5%AD%98%E7%9A%84%E5%BD%B1%E5%93%8D"><span class="toc-text">
          4) 页面刷新对HTTP缓存的影响</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#4-%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%A4%84%E7%90%86%E8%AF%B7%E6%B1%82%E5%B9%B6%E8%BF%94%E5%9B%9E%E5%93%8D%E5%BA%94"><span class="toc-text">
          4.服务器处理请求并返回响应</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#5-%E6%B5%8F%E8%A7%88%E5%99%A8%E8%A7%A3%E6%9E%90%E5%B9%B6%E6%B8%B2%E6%9F%93%E9%A1%B5%E9%9D%A2"><span class="toc-text">
          5.浏览器解析并渲染页面</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E6%B8%B2%E6%9F%93%E6%B5%81%E7%A8%8B"><span class="toc-text">
          (1) 渲染流程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E9%87%8D%E6%8E%92-%E9%87%8D%E7%BB%98"><span class="toc-text">
          (2) 重排&#x2F;重绘</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#6-%E6%96%AD%E5%BC%80TCP%E8%BF%9E%E6%8E%A5"><span class="toc-text">
          6.断开TCP连接</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B"><span class="toc-text">
          (1) 四次挥手</span></a></li></ol></li></ol></section><!-- ov = overview--><section class="sidebar-ov hide"><div class="sidebar-ov-author"><div class="sidebar-ov-author__avatar"><img class="sidebar-ov-author__avatar_img" src="/image/site/head.png" alt="avatar"></div><p class="sidebar-ov-author__text">hello world</p></div><div class="sidebar-ov-social"><a class="sidebar-ov-social-item" href="https://github.com/LonelyTaker" target="_blank" rel="noopener" data-popover="Github" data-popover-pos="up"><span class="sidebar-ov-social-item__icon"><i class="fab fa-github"></i></span></a><a class="sidebar-ov-social-item" href="Ym1104340863" target="_blank" rel="noopener" data-popover="微信" data-popover-pos="up"><span class="sidebar-ov-social-item__icon"><i class="fab fa-weixin"></i></span></a><a class="sidebar-ov-social-item" href="1104340863" target="_blank" rel="noopener" data-popover="QQ" data-popover-pos="up"><span class="sidebar-ov-social-item__icon"><i class="fab fa-qq"></i></span></a></div><div class="sidebar-ov-state"><a class="sidebar-ov-state-item sidebar-ov-state-item--posts" href="/archives/"><div class="sidebar-ov-state-item__count">7</div><div class="sidebar-ov-state-item__name">归档</div></a><a class="sidebar-ov-state-item sidebar-ov-state-item--categories" href="/categories/"><div class="sidebar-ov-state-item__count">3</div><div class="sidebar-ov-state-item__name">分类</div></a><a class="sidebar-ov-state-item sidebar-ov-state-item--tags" href="/tags/"><div class="sidebar-ov-state-item__count">3</div><div class="sidebar-ov-state-item__name">标签</div></a></div><div class="sidebar-ov-cc"><a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.en" target="_blank" rel="noopener" data-popover="知识共享许可协议" data-popover-pos="up"><img src="/images/cc-by-nc-sa.svg"></a></div></section><div class="sidebar-reading"><div class="sidebar-reading-info"><span class="sidebar-reading-info__text">你已阅读了 </span><span class="sidebar-reading-info__num">0</span><span class="sidebar-reading-info__perc">%</span></div><div class="sidebar-reading-line"></div></div></aside></div><div class="clearfix"></div></div></main><footer class="footer" id="footer"><div class="footer-inner"><div><span>Copyright © 2022</span><span class="footer__icon"><i class="fas fa-heart"></i></span><span>LonelyTaker</span></div><div><span>由 <a href="http://hexo.io/" title="Hexo" target="_blank" rel="noopener">Hexo</a> 强力驱动</span><span> v6.0.0</span></div></div></footer><div class="loading-bar" id="loading-bar"><div class="loading-bar__progress"></div></div><div class="back2top" id="back2top"><span class="back2top__icon"><i class="fas fa-rocket"></i></span></div></div><script src="https://cdn.jsdelivr.net/npm/jquery@v3.4.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@1.5.2/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@1.5.2/velocity.ui.min.js"></script><script src="/js/utils.js?v=2.6.2"></script><script src="/js/stun-boot.js?v=2.6.2"></script><script src="/js/scroll.js?v=2.6.2"></script><script src="/js/header.js?v=2.6.2"></script><script src="/js/sidebar.js?v=2.6.2"></script></body></html>